#
# Autogenerated by Frugal Compiler (3.7.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#



from threading import Lock

from frugal.middleware import Method
from frugal.exceptions import TApplicationExceptionType
from frugal.exceptions import TTransportExceptionType
from frugal.processor import FBaseProcessor
from frugal.processor import FProcessorFunction
from frugal.util.deprecate import deprecated
from frugal.util import make_hashable
from thrift.Thrift import TApplicationException
from thrift.Thrift import TMessageType
from thrift.transport.TTransport import TTransportException

from .ttypes import *


class Iface(object):

    def getRSAKey(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def notifyEmailConfirmationResult(self, ctx, parameterMap):
        """
        Args:
            ctx: FContext
            parameterMap: dict of <string, string>
        """
        pass

    def registerVirtualAccount(self, ctx, locale, encryptedVirtualUserId, encryptedPassword):
        """
        Args:
            ctx: FContext
            locale: string
            encryptedVirtualUserId: string
            encryptedPassword: string
        """
        pass

    def requestVirtualAccountPasswordChange(self, ctx, virtualMid, encryptedVirtualUserId, encryptedOldPassword, encryptedNewPassword):
        """
        Args:
            ctx: FContext
            virtualMid: string
            encryptedVirtualUserId: string
            encryptedOldPassword: string
            encryptedNewPassword: string
        """
        pass

    def requestVirtualAccountPasswordSet(self, ctx, virtualMid, encryptedVirtualUserId, encryptedNewPassword):
        """
        Args:
            ctx: FContext
            virtualMid: string
            encryptedVirtualUserId: string
            encryptedNewPassword: string
        """
        pass

    def unregisterVirtualAccount(self, ctx, virtualMid):
        """
        Args:
            ctx: FContext
            virtualMid: string
        """
        pass


class Client(Iface):

    def __init__(self, provider, middleware=None):
        """
        Create a new Client with an FServiceProvider containing a transport
        and protocol factory.

        Args:
            provider: FServiceProvider with TSynchronousTransport
            middleware: ServiceMiddleware or list of ServiceMiddleware
        """
        middleware = middleware or []
        if middleware and not isinstance(middleware, list):
            middleware = [middleware]
        self._transport = provider.get_transport()
        self._protocol_factory = provider.get_protocol_factory()
        self._oprot = self._protocol_factory.get_protocol(self._transport)
        self._iprot = self._protocol_factory.get_protocol(self._transport)
        self._write_lock = Lock()
        middleware += provider.get_middleware()
        self._methods = {
            'getRSAKey': Method(self._getRSAKey, middleware),
            'notifyEmailConfirmationResult': Method(self._notifyEmailConfirmationResult, middleware),
            'registerVirtualAccount': Method(self._registerVirtualAccount, middleware),
            'requestVirtualAccountPasswordChange': Method(self._requestVirtualAccountPasswordChange, middleware),
            'requestVirtualAccountPasswordSet': Method(self._requestVirtualAccountPasswordSet, middleware),
            'unregisterVirtualAccount': Method(self._unregisterVirtualAccount, middleware),
        }

    def getRSAKey(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getRSAKey']([ctx])

    def _getRSAKey(self, ctx):
        self._send_getRSAKey(ctx)
        return self._recv_getRSAKey(ctx)

    def _send_getRSAKey(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getRSAKey', TMessageType.CALL, 0)
            args = getRSAKey_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getRSAKey(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getRSAKey_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getRSAKey failed: unknown result")
        raise x

    def notifyEmailConfirmationResult(self, ctx, parameterMap):
        """
        Args:
            ctx: FContext
            parameterMap: dict of <string, string>
        """
        return self._methods['notifyEmailConfirmationResult']([ctx, parameterMap])

    def _notifyEmailConfirmationResult(self, ctx, parameterMap):
        self._send_notifyEmailConfirmationResult(ctx, parameterMap)
        self._recv_notifyEmailConfirmationResult(ctx)

    def _send_notifyEmailConfirmationResult(self, ctx, parameterMap):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('notifyEmailConfirmationResult', TMessageType.CALL, 0)
            args = notifyEmailConfirmationResult_args()
            args.parameterMap = parameterMap
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_notifyEmailConfirmationResult(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = notifyEmailConfirmationResult_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def registerVirtualAccount(self, ctx, locale, encryptedVirtualUserId, encryptedPassword):
        """
        Args:
            ctx: FContext
            locale: string
            encryptedVirtualUserId: string
            encryptedPassword: string
        """
        return self._methods['registerVirtualAccount']([ctx, locale, encryptedVirtualUserId, encryptedPassword])

    def _registerVirtualAccount(self, ctx, locale, encryptedVirtualUserId, encryptedPassword):
        self._send_registerVirtualAccount(ctx, locale, encryptedVirtualUserId, encryptedPassword)
        return self._recv_registerVirtualAccount(ctx)

    def _send_registerVirtualAccount(self, ctx, locale, encryptedVirtualUserId, encryptedPassword):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('registerVirtualAccount', TMessageType.CALL, 0)
            args = registerVirtualAccount_args()
            args.locale = locale
            args.encryptedVirtualUserId = encryptedVirtualUserId
            args.encryptedPassword = encryptedPassword
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_registerVirtualAccount(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = registerVirtualAccount_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "registerVirtualAccount failed: unknown result")
        raise x

    def requestVirtualAccountPasswordChange(self, ctx, virtualMid, encryptedVirtualUserId, encryptedOldPassword, encryptedNewPassword):
        """
        Args:
            ctx: FContext
            virtualMid: string
            encryptedVirtualUserId: string
            encryptedOldPassword: string
            encryptedNewPassword: string
        """
        return self._methods['requestVirtualAccountPasswordChange']([ctx, virtualMid, encryptedVirtualUserId, encryptedOldPassword, encryptedNewPassword])

    def _requestVirtualAccountPasswordChange(self, ctx, virtualMid, encryptedVirtualUserId, encryptedOldPassword, encryptedNewPassword):
        self._send_requestVirtualAccountPasswordChange(ctx, virtualMid, encryptedVirtualUserId, encryptedOldPassword, encryptedNewPassword)
        self._recv_requestVirtualAccountPasswordChange(ctx)

    def _send_requestVirtualAccountPasswordChange(self, ctx, virtualMid, encryptedVirtualUserId, encryptedOldPassword, encryptedNewPassword):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('requestVirtualAccountPasswordChange', TMessageType.CALL, 0)
            args = requestVirtualAccountPasswordChange_args()
            args.virtualMid = virtualMid
            args.encryptedVirtualUserId = encryptedVirtualUserId
            args.encryptedOldPassword = encryptedOldPassword
            args.encryptedNewPassword = encryptedNewPassword
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_requestVirtualAccountPasswordChange(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = requestVirtualAccountPasswordChange_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def requestVirtualAccountPasswordSet(self, ctx, virtualMid, encryptedVirtualUserId, encryptedNewPassword):
        """
        Args:
            ctx: FContext
            virtualMid: string
            encryptedVirtualUserId: string
            encryptedNewPassword: string
        """
        return self._methods['requestVirtualAccountPasswordSet']([ctx, virtualMid, encryptedVirtualUserId, encryptedNewPassword])

    def _requestVirtualAccountPasswordSet(self, ctx, virtualMid, encryptedVirtualUserId, encryptedNewPassword):
        self._send_requestVirtualAccountPasswordSet(ctx, virtualMid, encryptedVirtualUserId, encryptedNewPassword)
        self._recv_requestVirtualAccountPasswordSet(ctx)

    def _send_requestVirtualAccountPasswordSet(self, ctx, virtualMid, encryptedVirtualUserId, encryptedNewPassword):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('requestVirtualAccountPasswordSet', TMessageType.CALL, 0)
            args = requestVirtualAccountPasswordSet_args()
            args.virtualMid = virtualMid
            args.encryptedVirtualUserId = encryptedVirtualUserId
            args.encryptedNewPassword = encryptedNewPassword
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_requestVirtualAccountPasswordSet(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = requestVirtualAccountPasswordSet_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def unregisterVirtualAccount(self, ctx, virtualMid):
        """
        Args:
            ctx: FContext
            virtualMid: string
        """
        return self._methods['unregisterVirtualAccount']([ctx, virtualMid])

    def _unregisterVirtualAccount(self, ctx, virtualMid):
        self._send_unregisterVirtualAccount(ctx, virtualMid)
        self._recv_unregisterVirtualAccount(ctx)

    def _send_unregisterVirtualAccount(self, ctx, virtualMid):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('unregisterVirtualAccount', TMessageType.CALL, 0)
            args = unregisterVirtualAccount_args()
            args.virtualMid = virtualMid
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_unregisterVirtualAccount(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = unregisterVirtualAccount_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

class Processor(FBaseProcessor):

    def __init__(self, handler, middleware=None):
        """
        Create a new Processor.

        Args:
            handler: Iface
        """
        if middleware and not isinstance(middleware, list):
            middleware = [middleware]

        super(Processor, self).__init__()
        self.add_to_processor_map('getRSAKey', _getRSAKey(Method(handler.getRSAKey, middleware), self.get_write_lock()))
        self.add_to_processor_map('notifyEmailConfirmationResult', _notifyEmailConfirmationResult(Method(handler.notifyEmailConfirmationResult, middleware), self.get_write_lock()))
        self.add_to_processor_map('registerVirtualAccount', _registerVirtualAccount(Method(handler.registerVirtualAccount, middleware), self.get_write_lock()))
        self.add_to_processor_map('requestVirtualAccountPasswordChange', _requestVirtualAccountPasswordChange(Method(handler.requestVirtualAccountPasswordChange, middleware), self.get_write_lock()))
        self.add_to_processor_map('requestVirtualAccountPasswordSet', _requestVirtualAccountPasswordSet(Method(handler.requestVirtualAccountPasswordSet, middleware), self.get_write_lock()))
        self.add_to_processor_map('unregisterVirtualAccount', _unregisterVirtualAccount(Method(handler.unregisterVirtualAccount, middleware), self.get_write_lock()))


class _getRSAKey(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getRSAKey, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getRSAKey_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRSAKey_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getRSAKey", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getRSAKey", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getRSAKey', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getRSAKey", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _notifyEmailConfirmationResult(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_notifyEmailConfirmationResult, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = notifyEmailConfirmationResult_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = notifyEmailConfirmationResult_result()
        try:
            self._handler([ctx, args.parameterMap])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "notifyEmailConfirmationResult", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "notifyEmailConfirmationResult", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('notifyEmailConfirmationResult', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "notifyEmailConfirmationResult", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _registerVirtualAccount(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_registerVirtualAccount, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = registerVirtualAccount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = registerVirtualAccount_result()
        try:
            result.success = self._handler([ctx, args.locale, args.encryptedVirtualUserId, args.encryptedPassword])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerVirtualAccount", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerVirtualAccount", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('registerVirtualAccount', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "registerVirtualAccount", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _requestVirtualAccountPasswordChange(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_requestVirtualAccountPasswordChange, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = requestVirtualAccountPasswordChange_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = requestVirtualAccountPasswordChange_result()
        try:
            self._handler([ctx, args.virtualMid, args.encryptedVirtualUserId, args.encryptedOldPassword, args.encryptedNewPassword])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "requestVirtualAccountPasswordChange", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "requestVirtualAccountPasswordChange", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('requestVirtualAccountPasswordChange', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "requestVirtualAccountPasswordChange", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _requestVirtualAccountPasswordSet(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_requestVirtualAccountPasswordSet, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = requestVirtualAccountPasswordSet_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = requestVirtualAccountPasswordSet_result()
        try:
            self._handler([ctx, args.virtualMid, args.encryptedVirtualUserId, args.encryptedNewPassword])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "requestVirtualAccountPasswordSet", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "requestVirtualAccountPasswordSet", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('requestVirtualAccountPasswordSet', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "requestVirtualAccountPasswordSet", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _unregisterVirtualAccount(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_unregisterVirtualAccount, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = unregisterVirtualAccount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = unregisterVirtualAccount_result()
        try:
            self._handler([ctx, args.virtualMid])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "unregisterVirtualAccount", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "unregisterVirtualAccount", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('unregisterVirtualAccount', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "unregisterVirtualAccount", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


def _write_application_exception(ctx, oprot, method, ex_code=None, message=None, exception=None):
    if exception is not None:
        x = exception
    else:
        x = TApplicationException(type=ex_code, message=message)
    oprot.write_response_headers(ctx)
    oprot.writeMessageBegin(method, TMessageType.EXCEPTION, 0)
    x.write(oprot)
    oprot.writeMessageEnd()
    oprot.get_transport().flush()
    return x

class getRSAKey_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getRSAKey_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getRSAKey_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = RSAKey()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getRSAKey_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class notifyEmailConfirmationResult_args(object):
    """
    Attributes:
     - parameterMap
    """
    def __init__(self, parameterMap=None):
        self.parameterMap = parameterMap

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.MAP:
                    self.parameterMap = {}
                    (_, _, elem448) = iprot.readMapBegin()
                    for _ in range(elem448):
                        elem450 = iprot.readString()
                        elem449 = iprot.readString()
                        self.parameterMap[elem450] = elem449
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('notifyEmailConfirmationResult_args')
        if self.parameterMap is not None:
            oprot.writeFieldBegin('parameterMap', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameterMap))
            for elem452, elem451 in self.parameterMap.items():
                oprot.writeString(elem452)
                oprot.writeString(elem451)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.parameterMap))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class notifyEmailConfirmationResult_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('notifyEmailConfirmationResult_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerVirtualAccount_args(object):
    """
    Attributes:
     - locale
     - encryptedVirtualUserId
     - encryptedPassword
    """
    def __init__(self, locale=None, encryptedVirtualUserId=None, encryptedPassword=None):
        self.locale = locale
        self.encryptedVirtualUserId = encryptedVirtualUserId
        self.encryptedPassword = encryptedPassword

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.locale = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.encryptedVirtualUserId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.encryptedPassword = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerVirtualAccount_args')
        if self.locale is not None:
            oprot.writeFieldBegin('locale', TType.STRING, 2)
            oprot.writeString(self.locale)
            oprot.writeFieldEnd()
        if self.encryptedVirtualUserId is not None:
            oprot.writeFieldBegin('encryptedVirtualUserId', TType.STRING, 3)
            oprot.writeString(self.encryptedVirtualUserId)
            oprot.writeFieldEnd()
        if self.encryptedPassword is not None:
            oprot.writeFieldBegin('encryptedPassword', TType.STRING, 4)
            oprot.writeString(self.encryptedPassword)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.locale))
        value = (value * 31) ^ hash(make_hashable(self.encryptedVirtualUserId))
        value = (value * 31) ^ hash(make_hashable(self.encryptedPassword))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerVirtualAccount_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerVirtualAccount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class requestVirtualAccountPasswordChange_args(object):
    """
    Attributes:
     - virtualMid
     - encryptedVirtualUserId
     - encryptedOldPassword
     - encryptedNewPassword
    """
    def __init__(self, virtualMid=None, encryptedVirtualUserId=None, encryptedOldPassword=None, encryptedNewPassword=None):
        self.virtualMid = virtualMid
        self.encryptedVirtualUserId = encryptedVirtualUserId
        self.encryptedOldPassword = encryptedOldPassword
        self.encryptedNewPassword = encryptedNewPassword

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.virtualMid = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.encryptedVirtualUserId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.encryptedOldPassword = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.encryptedNewPassword = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('requestVirtualAccountPasswordChange_args')
        if self.virtualMid is not None:
            oprot.writeFieldBegin('virtualMid', TType.STRING, 2)
            oprot.writeString(self.virtualMid)
            oprot.writeFieldEnd()
        if self.encryptedVirtualUserId is not None:
            oprot.writeFieldBegin('encryptedVirtualUserId', TType.STRING, 3)
            oprot.writeString(self.encryptedVirtualUserId)
            oprot.writeFieldEnd()
        if self.encryptedOldPassword is not None:
            oprot.writeFieldBegin('encryptedOldPassword', TType.STRING, 4)
            oprot.writeString(self.encryptedOldPassword)
            oprot.writeFieldEnd()
        if self.encryptedNewPassword is not None:
            oprot.writeFieldBegin('encryptedNewPassword', TType.STRING, 5)
            oprot.writeString(self.encryptedNewPassword)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.virtualMid))
        value = (value * 31) ^ hash(make_hashable(self.encryptedVirtualUserId))
        value = (value * 31) ^ hash(make_hashable(self.encryptedOldPassword))
        value = (value * 31) ^ hash(make_hashable(self.encryptedNewPassword))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class requestVirtualAccountPasswordChange_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('requestVirtualAccountPasswordChange_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class requestVirtualAccountPasswordSet_args(object):
    """
    Attributes:
     - virtualMid
     - encryptedVirtualUserId
     - encryptedNewPassword
    """
    def __init__(self, virtualMid=None, encryptedVirtualUserId=None, encryptedNewPassword=None):
        self.virtualMid = virtualMid
        self.encryptedVirtualUserId = encryptedVirtualUserId
        self.encryptedNewPassword = encryptedNewPassword

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.virtualMid = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.encryptedVirtualUserId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.encryptedNewPassword = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('requestVirtualAccountPasswordSet_args')
        if self.virtualMid is not None:
            oprot.writeFieldBegin('virtualMid', TType.STRING, 2)
            oprot.writeString(self.virtualMid)
            oprot.writeFieldEnd()
        if self.encryptedVirtualUserId is not None:
            oprot.writeFieldBegin('encryptedVirtualUserId', TType.STRING, 3)
            oprot.writeString(self.encryptedVirtualUserId)
            oprot.writeFieldEnd()
        if self.encryptedNewPassword is not None:
            oprot.writeFieldBegin('encryptedNewPassword', TType.STRING, 4)
            oprot.writeString(self.encryptedNewPassword)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.virtualMid))
        value = (value * 31) ^ hash(make_hashable(self.encryptedVirtualUserId))
        value = (value * 31) ^ hash(make_hashable(self.encryptedNewPassword))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class requestVirtualAccountPasswordSet_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('requestVirtualAccountPasswordSet_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class unregisterVirtualAccount_args(object):
    """
    Attributes:
     - virtualMid
    """
    def __init__(self, virtualMid=None):
        self.virtualMid = virtualMid

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.virtualMid = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('unregisterVirtualAccount_args')
        if self.virtualMid is not None:
            oprot.writeFieldBegin('virtualMid', TType.STRING, 2)
            oprot.writeString(self.virtualMid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.virtualMid))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class unregisterVirtualAccount_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('unregisterVirtualAccount_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

