#
# Autogenerated by Frugal Compiler (3.7.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#



from threading import Lock

from frugal.middleware import Method
from frugal.exceptions import TApplicationExceptionType
from frugal.exceptions import TTransportExceptionType
from frugal.processor import FBaseProcessor
from frugal.processor import FProcessorFunction
from frugal.util.deprecate import deprecated
from frugal.util import make_hashable
from thrift.Thrift import TApplicationException
from thrift.Thrift import TMessageType
from thrift.transport.TTransport import TTransportException

from .ttypes import *


class Iface(object):

    def getSnsFriends(self, ctx, snsIdType, snsAccessToken, startIdx, limit):
        """
        Args:
            ctx: FContext
            snsIdType: SnsIdType
            snsAccessToken: string
            startIdx: int (signed 32 bits)
            limit: int (signed 32 bits)
        """
        pass

    def getSnsMyProfile(self, ctx, snsIdType, snsAccessToken):
        """
        Args:
            ctx: FContext
            snsIdType: SnsIdType
            snsAccessToken: string
        """
        pass

    def postSnsInvitationMessage(self, ctx, snsIdType, snsAccessToken, toSnsUserId):
        """
        Args:
            ctx: FContext
            snsIdType: SnsIdType
            snsAccessToken: string
            toSnsUserId: string
        """
        pass


class Client(Iface):

    def __init__(self, provider, middleware=None):
        """
        Create a new Client with an FServiceProvider containing a transport
        and protocol factory.

        Args:
            provider: FServiceProvider with TSynchronousTransport
            middleware: ServiceMiddleware or list of ServiceMiddleware
        """
        middleware = middleware or []
        if middleware and not isinstance(middleware, list):
            middleware = [middleware]
        self._transport = provider.get_transport()
        self._protocol_factory = provider.get_protocol_factory()
        self._oprot = self._protocol_factory.get_protocol(self._transport)
        self._iprot = self._protocol_factory.get_protocol(self._transport)
        self._write_lock = Lock()
        middleware += provider.get_middleware()
        self._methods = {
            'getSnsFriends': Method(self._getSnsFriends, middleware),
            'getSnsMyProfile': Method(self._getSnsMyProfile, middleware),
            'postSnsInvitationMessage': Method(self._postSnsInvitationMessage, middleware),
        }

    def getSnsFriends(self, ctx, snsIdType, snsAccessToken, startIdx, limit):
        """
        Args:
            ctx: FContext
            snsIdType: SnsIdType
            snsAccessToken: string
            startIdx: int (signed 32 bits)
            limit: int (signed 32 bits)
        """
        return self._methods['getSnsFriends']([ctx, snsIdType, snsAccessToken, startIdx, limit])

    def _getSnsFriends(self, ctx, snsIdType, snsAccessToken, startIdx, limit):
        self._send_getSnsFriends(ctx, snsIdType, snsAccessToken, startIdx, limit)
        return self._recv_getSnsFriends(ctx)

    def _send_getSnsFriends(self, ctx, snsIdType, snsAccessToken, startIdx, limit):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getSnsFriends', TMessageType.CALL, 0)
            args = getSnsFriends_args()
            args.snsIdType = snsIdType
            args.snsAccessToken = snsAccessToken
            args.startIdx = startIdx
            args.limit = limit
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getSnsFriends(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getSnsFriends_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getSnsFriends failed: unknown result")
        raise x

    def getSnsMyProfile(self, ctx, snsIdType, snsAccessToken):
        """
        Args:
            ctx: FContext
            snsIdType: SnsIdType
            snsAccessToken: string
        """
        return self._methods['getSnsMyProfile']([ctx, snsIdType, snsAccessToken])

    def _getSnsMyProfile(self, ctx, snsIdType, snsAccessToken):
        self._send_getSnsMyProfile(ctx, snsIdType, snsAccessToken)
        return self._recv_getSnsMyProfile(ctx)

    def _send_getSnsMyProfile(self, ctx, snsIdType, snsAccessToken):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getSnsMyProfile', TMessageType.CALL, 0)
            args = getSnsMyProfile_args()
            args.snsIdType = snsIdType
            args.snsAccessToken = snsAccessToken
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getSnsMyProfile(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getSnsMyProfile_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getSnsMyProfile failed: unknown result")
        raise x

    def postSnsInvitationMessage(self, ctx, snsIdType, snsAccessToken, toSnsUserId):
        """
        Args:
            ctx: FContext
            snsIdType: SnsIdType
            snsAccessToken: string
            toSnsUserId: string
        """
        return self._methods['postSnsInvitationMessage']([ctx, snsIdType, snsAccessToken, toSnsUserId])

    def _postSnsInvitationMessage(self, ctx, snsIdType, snsAccessToken, toSnsUserId):
        self._send_postSnsInvitationMessage(ctx, snsIdType, snsAccessToken, toSnsUserId)
        self._recv_postSnsInvitationMessage(ctx)

    def _send_postSnsInvitationMessage(self, ctx, snsIdType, snsAccessToken, toSnsUserId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('postSnsInvitationMessage', TMessageType.CALL, 0)
            args = postSnsInvitationMessage_args()
            args.snsIdType = snsIdType
            args.snsAccessToken = snsAccessToken
            args.toSnsUserId = toSnsUserId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_postSnsInvitationMessage(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = postSnsInvitationMessage_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

class Processor(FBaseProcessor):

    def __init__(self, handler, middleware=None):
        """
        Create a new Processor.

        Args:
            handler: Iface
        """
        if middleware and not isinstance(middleware, list):
            middleware = [middleware]

        super(Processor, self).__init__()
        self.add_to_processor_map('getSnsFriends', _getSnsFriends(Method(handler.getSnsFriends, middleware), self.get_write_lock()))
        self.add_to_processor_map('getSnsMyProfile', _getSnsMyProfile(Method(handler.getSnsMyProfile, middleware), self.get_write_lock()))
        self.add_to_processor_map('postSnsInvitationMessage', _postSnsInvitationMessage(Method(handler.postSnsInvitationMessage, middleware), self.get_write_lock()))


class _getSnsFriends(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getSnsFriends, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getSnsFriends_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getSnsFriends_result()
        try:
            result.success = self._handler([ctx, args.snsIdType, args.snsAccessToken, args.startIdx, args.limit])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getSnsFriends", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getSnsFriends", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getSnsFriends', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getSnsFriends", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getSnsMyProfile(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getSnsMyProfile, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getSnsMyProfile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getSnsMyProfile_result()
        try:
            result.success = self._handler([ctx, args.snsIdType, args.snsAccessToken])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getSnsMyProfile", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getSnsMyProfile", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getSnsMyProfile', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getSnsMyProfile", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _postSnsInvitationMessage(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_postSnsInvitationMessage, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = postSnsInvitationMessage_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = postSnsInvitationMessage_result()
        try:
            self._handler([ctx, args.snsIdType, args.snsAccessToken, args.toSnsUserId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "postSnsInvitationMessage", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "postSnsInvitationMessage", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('postSnsInvitationMessage', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "postSnsInvitationMessage", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


def _write_application_exception(ctx, oprot, method, ex_code=None, message=None, exception=None):
    if exception is not None:
        x = exception
    else:
        x = TApplicationException(type=ex_code, message=message)
    oprot.write_response_headers(ctx)
    oprot.writeMessageBegin(method, TMessageType.EXCEPTION, 0)
    x.write(oprot)
    oprot.writeMessageEnd()
    oprot.get_transport().flush()
    return x

class getSnsFriends_args(object):
    """
    Attributes:
     - snsIdType
     - snsAccessToken
     - startIdx
     - limit
    """
    def __init__(self, snsIdType=None, snsAccessToken=None, startIdx=None, limit=None):
        self.snsIdType = snsIdType
        self.snsAccessToken = snsAccessToken
        self.startIdx = startIdx
        self.limit = limit

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I32:
                    self.snsIdType = SnsIdType(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.snsAccessToken = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.startIdx = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getSnsFriends_args')
        if self.snsIdType is not None:
            oprot.writeFieldBegin('snsIdType', TType.I32, 2)
            oprot.writeI32(self.snsIdType)
            oprot.writeFieldEnd()
        if self.snsAccessToken is not None:
            oprot.writeFieldBegin('snsAccessToken', TType.STRING, 3)
            oprot.writeString(self.snsAccessToken)
            oprot.writeFieldEnd()
        if self.startIdx is not None:
            oprot.writeFieldBegin('startIdx', TType.I32, 4)
            oprot.writeI32(self.startIdx)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 5)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.snsIdType))
        value = (value * 31) ^ hash(make_hashable(self.snsAccessToken))
        value = (value * 31) ^ hash(make_hashable(self.startIdx))
        value = (value * 31) ^ hash(make_hashable(self.limit))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getSnsFriends_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = SnsFriends()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getSnsFriends_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getSnsMyProfile_args(object):
    """
    Attributes:
     - snsIdType
     - snsAccessToken
    """
    def __init__(self, snsIdType=None, snsAccessToken=None):
        self.snsIdType = snsIdType
        self.snsAccessToken = snsAccessToken

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I32:
                    self.snsIdType = SnsIdType(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.snsAccessToken = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getSnsMyProfile_args')
        if self.snsIdType is not None:
            oprot.writeFieldBegin('snsIdType', TType.I32, 2)
            oprot.writeI32(self.snsIdType)
            oprot.writeFieldEnd()
        if self.snsAccessToken is not None:
            oprot.writeFieldBegin('snsAccessToken', TType.STRING, 3)
            oprot.writeString(self.snsAccessToken)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.snsIdType))
        value = (value * 31) ^ hash(make_hashable(self.snsAccessToken))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getSnsMyProfile_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = SnsProfile()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getSnsMyProfile_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class postSnsInvitationMessage_args(object):
    """
    Attributes:
     - snsIdType
     - snsAccessToken
     - toSnsUserId
    """
    def __init__(self, snsIdType=None, snsAccessToken=None, toSnsUserId=None):
        self.snsIdType = snsIdType
        self.snsAccessToken = snsAccessToken
        self.toSnsUserId = toSnsUserId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I32:
                    self.snsIdType = SnsIdType(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.snsAccessToken = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.toSnsUserId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('postSnsInvitationMessage_args')
        if self.snsIdType is not None:
            oprot.writeFieldBegin('snsIdType', TType.I32, 2)
            oprot.writeI32(self.snsIdType)
            oprot.writeFieldEnd()
        if self.snsAccessToken is not None:
            oprot.writeFieldBegin('snsAccessToken', TType.STRING, 3)
            oprot.writeString(self.snsAccessToken)
            oprot.writeFieldEnd()
        if self.toSnsUserId is not None:
            oprot.writeFieldBegin('toSnsUserId', TType.STRING, 4)
            oprot.writeString(self.toSnsUserId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.snsIdType))
        value = (value * 31) ^ hash(make_hashable(self.snsAccessToken))
        value = (value * 31) ^ hash(make_hashable(self.toSnsUserId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class postSnsInvitationMessage_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('postSnsInvitationMessage_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

