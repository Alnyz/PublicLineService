#
# Autogenerated by Frugal Compiler (3.7.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#



from threading import Lock

from frugal.middleware import Method
from frugal.exceptions import TApplicationExceptionType
from frugal.exceptions import TTransportExceptionType
from frugal.processor import FBaseProcessor
from frugal.processor import FProcessorFunction
from frugal.util.deprecate import deprecated
from frugal.util import make_hashable
from thrift.Thrift import TApplicationException
from thrift.Thrift import TMessageType
from thrift.transport.TTransport import TTransportException

from .ttypes import *


class Iface(object):

    def getUserStatus(self, ctx, mid):
        """
        Args:
            ctx: FContext
            mid: string
        """
        pass

    def updateProfileAttributeForChannel(self, ctx, profileAttribute, value):
        """
        Args:
            ctx: FContext
            profileAttribute: ProfileAttribute
            value: string
        """
        pass

    def updateExtendedProfileAttribute(self, ctx, attr, extendedProfile):
        """
        Args:
            ctx: FContext
            attr: ExtendedProfileAttribute
            extendedProfile: ExtendedProfile
        """
        pass

    def getAllSimpleChannelContacts(self, ctx, statusSticonFallbackDisabled):
        """
        Args:
            ctx: FContext
            statusSticonFallbackDisabled: boolean
        """
        pass

    def getUserIdentities(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def markPaidCallAd(self, ctx, dialedNumber, language, disableCallerId):
        """
        Args:
            ctx: FContext
            dialedNumber: string
            language: string
            disableCallerId: boolean
        """
        pass

    def isGroupMember(self, ctx, groupId):
        """
        Args:
            ctx: FContext
            groupId: string
        """
        pass

    def getPhoneInfoFromPhoneNumber(self, ctx, region, phoneNumber):
        """
        Args:
            ctx: FContext
            region: string
            phoneNumber: string
        """
        pass

    def redeemPaidCallVoucher(self, ctx, serial, language):
        """
        Args:
            ctx: FContext
            serial: string
            language: string
        """
        pass

    def getPreferredDisplayName(self, ctx, mids):
        """
        Args:
            ctx: FContext
            mids: list of string
        """
        pass

    def getContactsForChannel(self, ctx, ids):
        """
        Args:
            ctx: FContext
            ids: list of string
        """
        pass

    def getCallCreditProducts(self, ctx, appStoreCode, pgCode, country, language):
        """
        Args:
            ctx: FContext
            appStoreCode: PaymentType
            pgCode: PaymentPgType
            country: string
            language: string
        """
        pass

    def getCompactContacts(self, ctx, lastModifiedTimestamp):
        """
        Args:
            ctx: FContext
            lastModifiedTimestamp: int (signed 64 bits)
        """
        pass

    def notifyNotiCenterEvent(self, ctx, event):
        """
        Args:
            ctx: FContext
            event: NotiCenterEventData
        """
        pass

    def isInContact(self, ctx, mid):
        """
        Args:
            ctx: FContext
            mid: string
        """
        pass

    def lookupGroupMembers(self, ctx, groupId, mids):
        """
        Args:
            ctx: FContext
            groupId: string
            mids: list of string
        """
        pass

    def getRoomInformation(self, ctx, roomMid):
        """
        Args:
            ctx: FContext
            roomMid: string
        """
        pass

    def getGroupCall(self, ctx, chatMid):
        """
        Args:
            ctx: FContext
            chatMid: string
        """
        pass

    def isAllowSecondaryDeviceLogin(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getPrimaryClientForChannel(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def createRoomWithBuddy(self, ctx, reqSeq, buddyMid, contactIds):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            buddyMid: string
            contactIds: list of string
        """
        pass

    def getDisplayName(self, ctx, mid):
        """
        Args:
            ctx: FContext
            mid: string
        """
        pass

    def getPaidCallMetadata(self, ctx, language):
        """
        Args:
            ctx: FContext
            language: string
        """
        pass

    def getMid(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getUserCountryForBilling(self, ctx, country, remoteIp):
        """
        Args:
            ctx: FContext
            country: string
            remoteIp: string
        """
        pass

    def getFavoriteGroupIdsForChannel(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getPaidCallHistory(self, ctx, start, size, language):
        """
        Args:
            ctx: FContext
            start: int (signed 64 bits)
            size: int (signed 32 bits)
            language: string
        """
        pass

    def sendPinCodeOperation(self, ctx, verifier):
        """
        Args:
            ctx: FContext
            verifier: string
        """
        pass

    def inviteIntoGroupCall(self, ctx, chatMid, memberMids, mediaType):
        """
        Args:
            ctx: FContext
            chatMid: string
            memberMids: list of string
            mediaType: GroupCallMediaType
        """
        pass

    def getFriendMids(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getMetaProfile(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def sendMessageForChannel(self, ctx, message):
        """
        Args:
            ctx: FContext
            message: Message
        """
        pass

    def activeBuddySubscriberCount(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getCallCreditPurchaseHistory(self, ctx, request):
        """
        Args:
            ctx: FContext
            request: CoinHistoryCondition
        """
        pass

    def isRoomMember(self, ctx, roomId):
        """
        Args:
            ctx: FContext
            roomId: string
        """
        pass

    def sendSystemOAMessage(self, ctx, message):
        """
        Args:
            ctx: FContext
            message: Message
        """
        pass

    def acquirePaidCallRoute(self, ctx, paidCallType, dialedNumber, language, networkCode, disableCallerId, referer, adSessionId):
        """
        Args:
            ctx: FContext
            paidCallType: PaidCallType
            dialedNumber: string
            language: string
            networkCode: string
            disableCallerId: boolean
            referer: string
            adSessionId: string
        """
        pass

    def getGroupsForChannel(self, ctx, groupIds):
        """
        Args:
            ctx: FContext
            groupIds: list of string
        """
        pass

    def getUserCreateTime(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def registerChannelCP(self, ctx, cpId, registerPassword):
        """
        Args:
            ctx: FContext
            cpId: string
            registerPassword: string
        """
        pass

    def reserveCallCreditPurchase(self, ctx, request):
        """
        Args:
            ctx: FContext
            request: CoinPurchaseReservation
        """
        pass

    def acquirePaidCallCurrencyExchangeRate(self, ctx, language):
        """
        Args:
            ctx: FContext
            language: string
        """
        pass

    def getRoomMemberMidsForAppPlatform(self, ctx, roomId):
        """
        Args:
            ctx: FContext
            roomId: string
        """
        pass

    def getPaidCallBalanceList(self, ctx, language):
        """
        Args:
            ctx: FContext
            language: string
        """
        pass

    def getPersonalInfos(self, ctx, requiredPersonalInfos):
        """
        Args:
            ctx: FContext
            requiredPersonalInfos: set of PersonalInfo
        """
        pass

    def getPrimaryClientsForChannel(self, ctx, userMids):
        """
        Args:
            ctx: FContext
            userMids: list of string
        """
        pass

    def addBuddyToContact(self, ctx, buddyMid):
        """
        Args:
            ctx: FContext
            buddyMid: string
        """
        pass

    def getGroupMemberMidsForAppPlatform(self, ctx, groupId):
        """
        Args:
            ctx: FContext
            groupId: string
        """
        pass

    def getUserLanguage(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def lookupPaidCall(self, ctx, dialedNumber, language, referer):
        """
        Args:
            ctx: FContext
            dialedNumber: string
            language: string
            referer: string
        """
        pass

    def getExtendedProfile(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getReverseCompactContacts(self, ctx, ids):
        """
        Args:
            ctx: FContext
            ids: list of string
        """
        pass

    def getPaidCallAdStatus(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def findContactByUseridWithoutAbuseBlockForChannel(self, ctx, userid):
        """
        Args:
            ctx: FContext
            userid: string
        """
        pass

    def getGroupMemberMids(self, ctx, groupId):
        """
        Args:
            ctx: FContext
            groupId: string
        """
        pass

    def sendMessageWithoutRelationship(self, ctx, message):
        """
        Args:
            ctx: FContext
            message: Message
        """
        pass

    def displayBuddySubscriberCountInBulk(self, ctx, mids):
        """
        Args:
            ctx: FContext
            mids: list of string
        """
        pass

    def lookupRoomMembers(self, ctx, roomId, mids):
        """
        Args:
            ctx: FContext
            roomId: string
            mids: list of string
        """
        pass

    def getFavoriteMidsForChannel(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getAllContactIdsForChannel(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def displayBuddySubscriberCount(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getProfileForChannel(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getUserTickets(self, ctx, userMids):
        """
        Args:
            ctx: FContext
            userMids: list of string
        """
        pass

    def getOAFriendMids(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def searchPaidCallUserRate(self, ctx, countryCode, language):
        """
        Args:
            ctx: FContext
            countryCode: string
            language: string
        """
        pass

    def getJoinedGroupIdsForChannel(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def acquireGroupCallRoute(self, ctx, chatMid, mediaType):
        """
        Args:
            ctx: FContext
            chatMid: string
            mediaType: GroupCallMediaType
        """
        pass

    def getUserMidsWhoAddedMe(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getIdentityCredential(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def addOperationForChannel(self, ctx, opType, param1, param2, param3):
        """
        Args:
            ctx: FContext
            opType: OpType
            param1: string
            param2: string
            param3: string
        """
        pass

    def getSimpleChannelContacts(self, ctx, ids, statusSticonFallbackDisabled):
        """
        Args:
            ctx: FContext
            ids: list of string
            statusSticonFallbackDisabled: boolean
        """
        pass

    def getUserLastSentMessageTimeStamp(self, ctx, mid):
        """
        Args:
            ctx: FContext
            mid: string
        """
        pass


class Client(Iface):

    def __init__(self, provider, middleware=None):
        """
        Create a new Client with an FServiceProvider containing a transport
        and protocol factory.

        Args:
            provider: FServiceProvider with TSynchronousTransport
            middleware: ServiceMiddleware or list of ServiceMiddleware
        """
        middleware = middleware or []
        if middleware and not isinstance(middleware, list):
            middleware = [middleware]
        self._transport = provider.get_transport()
        self._protocol_factory = provider.get_protocol_factory()
        self._oprot = self._protocol_factory.get_protocol(self._transport)
        self._iprot = self._protocol_factory.get_protocol(self._transport)
        self._write_lock = Lock()
        middleware += provider.get_middleware()
        self._methods = {
            'getUserStatus': Method(self._getUserStatus, middleware),
            'updateProfileAttributeForChannel': Method(self._updateProfileAttributeForChannel, middleware),
            'updateExtendedProfileAttribute': Method(self._updateExtendedProfileAttribute, middleware),
            'getAllSimpleChannelContacts': Method(self._getAllSimpleChannelContacts, middleware),
            'getUserIdentities': Method(self._getUserIdentities, middleware),
            'markPaidCallAd': Method(self._markPaidCallAd, middleware),
            'isGroupMember': Method(self._isGroupMember, middleware),
            'getPhoneInfoFromPhoneNumber': Method(self._getPhoneInfoFromPhoneNumber, middleware),
            'redeemPaidCallVoucher': Method(self._redeemPaidCallVoucher, middleware),
            'getPreferredDisplayName': Method(self._getPreferredDisplayName, middleware),
            'getContactsForChannel': Method(self._getContactsForChannel, middleware),
            'getCallCreditProducts': Method(self._getCallCreditProducts, middleware),
            'getCompactContacts': Method(self._getCompactContacts, middleware),
            'notifyNotiCenterEvent': Method(self._notifyNotiCenterEvent, middleware),
            'isInContact': Method(self._isInContact, middleware),
            'lookupGroupMembers': Method(self._lookupGroupMembers, middleware),
            'getRoomInformation': Method(self._getRoomInformation, middleware),
            'getGroupCall': Method(self._getGroupCall, middleware),
            'isAllowSecondaryDeviceLogin': Method(self._isAllowSecondaryDeviceLogin, middleware),
            'getPrimaryClientForChannel': Method(self._getPrimaryClientForChannel, middleware),
            'createRoomWithBuddy': Method(self._createRoomWithBuddy, middleware),
            'getDisplayName': Method(self._getDisplayName, middleware),
            'getPaidCallMetadata': Method(self._getPaidCallMetadata, middleware),
            'getMid': Method(self._getMid, middleware),
            'getUserCountryForBilling': Method(self._getUserCountryForBilling, middleware),
            'getFavoriteGroupIdsForChannel': Method(self._getFavoriteGroupIdsForChannel, middleware),
            'getPaidCallHistory': Method(self._getPaidCallHistory, middleware),
            'sendPinCodeOperation': Method(self._sendPinCodeOperation, middleware),
            'inviteIntoGroupCall': Method(self._inviteIntoGroupCall, middleware),
            'getFriendMids': Method(self._getFriendMids, middleware),
            'getMetaProfile': Method(self._getMetaProfile, middleware),
            'sendMessageForChannel': Method(self._sendMessageForChannel, middleware),
            'activeBuddySubscriberCount': Method(self._activeBuddySubscriberCount, middleware),
            'getCallCreditPurchaseHistory': Method(self._getCallCreditPurchaseHistory, middleware),
            'isRoomMember': Method(self._isRoomMember, middleware),
            'sendSystemOAMessage': Method(self._sendSystemOAMessage, middleware),
            'acquirePaidCallRoute': Method(self._acquirePaidCallRoute, middleware),
            'getGroupsForChannel': Method(self._getGroupsForChannel, middleware),
            'getUserCreateTime': Method(self._getUserCreateTime, middleware),
            'registerChannelCP': Method(self._registerChannelCP, middleware),
            'reserveCallCreditPurchase': Method(self._reserveCallCreditPurchase, middleware),
            'acquirePaidCallCurrencyExchangeRate': Method(self._acquirePaidCallCurrencyExchangeRate, middleware),
            'getRoomMemberMidsForAppPlatform': Method(self._getRoomMemberMidsForAppPlatform, middleware),
            'getPaidCallBalanceList': Method(self._getPaidCallBalanceList, middleware),
            'getPersonalInfos': Method(self._getPersonalInfos, middleware),
            'getPrimaryClientsForChannel': Method(self._getPrimaryClientsForChannel, middleware),
            'addBuddyToContact': Method(self._addBuddyToContact, middleware),
            'getGroupMemberMidsForAppPlatform': Method(self._getGroupMemberMidsForAppPlatform, middleware),
            'getUserLanguage': Method(self._getUserLanguage, middleware),
            'lookupPaidCall': Method(self._lookupPaidCall, middleware),
            'getExtendedProfile': Method(self._getExtendedProfile, middleware),
            'getReverseCompactContacts': Method(self._getReverseCompactContacts, middleware),
            'getPaidCallAdStatus': Method(self._getPaidCallAdStatus, middleware),
            'findContactByUseridWithoutAbuseBlockForChannel': Method(self._findContactByUseridWithoutAbuseBlockForChannel, middleware),
            'getGroupMemberMids': Method(self._getGroupMemberMids, middleware),
            'sendMessageWithoutRelationship': Method(self._sendMessageWithoutRelationship, middleware),
            'displayBuddySubscriberCountInBulk': Method(self._displayBuddySubscriberCountInBulk, middleware),
            'lookupRoomMembers': Method(self._lookupRoomMembers, middleware),
            'getFavoriteMidsForChannel': Method(self._getFavoriteMidsForChannel, middleware),
            'getAllContactIdsForChannel': Method(self._getAllContactIdsForChannel, middleware),
            'displayBuddySubscriberCount': Method(self._displayBuddySubscriberCount, middleware),
            'getProfileForChannel': Method(self._getProfileForChannel, middleware),
            'getUserTickets': Method(self._getUserTickets, middleware),
            'getOAFriendMids': Method(self._getOAFriendMids, middleware),
            'searchPaidCallUserRate': Method(self._searchPaidCallUserRate, middleware),
            'getJoinedGroupIdsForChannel': Method(self._getJoinedGroupIdsForChannel, middleware),
            'acquireGroupCallRoute': Method(self._acquireGroupCallRoute, middleware),
            'getUserMidsWhoAddedMe': Method(self._getUserMidsWhoAddedMe, middleware),
            'getIdentityCredential': Method(self._getIdentityCredential, middleware),
            'addOperationForChannel': Method(self._addOperationForChannel, middleware),
            'getSimpleChannelContacts': Method(self._getSimpleChannelContacts, middleware),
            'getUserLastSentMessageTimeStamp': Method(self._getUserLastSentMessageTimeStamp, middleware),
        }

    def getUserStatus(self, ctx, mid):
        """
        Args:
            ctx: FContext
            mid: string
        """
        return self._methods['getUserStatus']([ctx, mid])

    def _getUserStatus(self, ctx, mid):
        self._send_getUserStatus(ctx, mid)
        return self._recv_getUserStatus(ctx)

    def _send_getUserStatus(self, ctx, mid):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getUserStatus', TMessageType.CALL, 0)
            args = getUserStatus_args()
            args.mid = mid
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getUserStatus(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getUserStatus_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getUserStatus failed: unknown result")
        raise x

    def updateProfileAttributeForChannel(self, ctx, profileAttribute, value):
        """
        Args:
            ctx: FContext
            profileAttribute: ProfileAttribute
            value: string
        """
        return self._methods['updateProfileAttributeForChannel']([ctx, profileAttribute, value])

    def _updateProfileAttributeForChannel(self, ctx, profileAttribute, value):
        self._send_updateProfileAttributeForChannel(ctx, profileAttribute, value)
        self._recv_updateProfileAttributeForChannel(ctx)

    def _send_updateProfileAttributeForChannel(self, ctx, profileAttribute, value):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('updateProfileAttributeForChannel', TMessageType.CALL, 0)
            args = updateProfileAttributeForChannel_args()
            args.profileAttribute = profileAttribute
            args.value = value
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_updateProfileAttributeForChannel(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = updateProfileAttributeForChannel_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def updateExtendedProfileAttribute(self, ctx, attr, extendedProfile):
        """
        Args:
            ctx: FContext
            attr: ExtendedProfileAttribute
            extendedProfile: ExtendedProfile
        """
        return self._methods['updateExtendedProfileAttribute']([ctx, attr, extendedProfile])

    def _updateExtendedProfileAttribute(self, ctx, attr, extendedProfile):
        self._send_updateExtendedProfileAttribute(ctx, attr, extendedProfile)
        self._recv_updateExtendedProfileAttribute(ctx)

    def _send_updateExtendedProfileAttribute(self, ctx, attr, extendedProfile):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('updateExtendedProfileAttribute', TMessageType.CALL, 0)
            args = updateExtendedProfileAttribute_args()
            args.attr = attr
            args.extendedProfile = extendedProfile
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_updateExtendedProfileAttribute(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = updateExtendedProfileAttribute_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def getAllSimpleChannelContacts(self, ctx, statusSticonFallbackDisabled):
        """
        Args:
            ctx: FContext
            statusSticonFallbackDisabled: boolean
        """
        return self._methods['getAllSimpleChannelContacts']([ctx, statusSticonFallbackDisabled])

    def _getAllSimpleChannelContacts(self, ctx, statusSticonFallbackDisabled):
        self._send_getAllSimpleChannelContacts(ctx, statusSticonFallbackDisabled)
        return self._recv_getAllSimpleChannelContacts(ctx)

    def _send_getAllSimpleChannelContacts(self, ctx, statusSticonFallbackDisabled):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getAllSimpleChannelContacts', TMessageType.CALL, 0)
            args = getAllSimpleChannelContacts_args()
            args.statusSticonFallbackDisabled = statusSticonFallbackDisabled
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getAllSimpleChannelContacts(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getAllSimpleChannelContacts_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getAllSimpleChannelContacts failed: unknown result")
        raise x

    def getUserIdentities(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getUserIdentities']([ctx])

    def _getUserIdentities(self, ctx):
        self._send_getUserIdentities(ctx)
        return self._recv_getUserIdentities(ctx)

    def _send_getUserIdentities(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getUserIdentities', TMessageType.CALL, 0)
            args = getUserIdentities_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getUserIdentities(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getUserIdentities_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getUserIdentities failed: unknown result")
        raise x

    def markPaidCallAd(self, ctx, dialedNumber, language, disableCallerId):
        """
        Args:
            ctx: FContext
            dialedNumber: string
            language: string
            disableCallerId: boolean
        """
        return self._methods['markPaidCallAd']([ctx, dialedNumber, language, disableCallerId])

    def _markPaidCallAd(self, ctx, dialedNumber, language, disableCallerId):
        self._send_markPaidCallAd(ctx, dialedNumber, language, disableCallerId)
        return self._recv_markPaidCallAd(ctx)

    def _send_markPaidCallAd(self, ctx, dialedNumber, language, disableCallerId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('markPaidCallAd', TMessageType.CALL, 0)
            args = markPaidCallAd_args()
            args.dialedNumber = dialedNumber
            args.language = language
            args.disableCallerId = disableCallerId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_markPaidCallAd(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = markPaidCallAd_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "markPaidCallAd failed: unknown result")
        raise x

    def isGroupMember(self, ctx, groupId):
        """
        Args:
            ctx: FContext
            groupId: string
        """
        return self._methods['isGroupMember']([ctx, groupId])

    def _isGroupMember(self, ctx, groupId):
        self._send_isGroupMember(ctx, groupId)
        return self._recv_isGroupMember(ctx)

    def _send_isGroupMember(self, ctx, groupId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('isGroupMember', TMessageType.CALL, 0)
            args = isGroupMember_args()
            args.groupId = groupId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_isGroupMember(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = isGroupMember_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "isGroupMember failed: unknown result")
        raise x

    def getPhoneInfoFromPhoneNumber(self, ctx, region, phoneNumber):
        """
        Args:
            ctx: FContext
            region: string
            phoneNumber: string
        """
        return self._methods['getPhoneInfoFromPhoneNumber']([ctx, region, phoneNumber])

    def _getPhoneInfoFromPhoneNumber(self, ctx, region, phoneNumber):
        self._send_getPhoneInfoFromPhoneNumber(ctx, region, phoneNumber)
        return self._recv_getPhoneInfoFromPhoneNumber(ctx)

    def _send_getPhoneInfoFromPhoneNumber(self, ctx, region, phoneNumber):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getPhoneInfoFromPhoneNumber', TMessageType.CALL, 0)
            args = getPhoneInfoFromPhoneNumber_args()
            args.region = region
            args.phoneNumber = phoneNumber
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getPhoneInfoFromPhoneNumber(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getPhoneInfoFromPhoneNumber_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getPhoneInfoFromPhoneNumber failed: unknown result")
        raise x

    def redeemPaidCallVoucher(self, ctx, serial, language):
        """
        Args:
            ctx: FContext
            serial: string
            language: string
        """
        return self._methods['redeemPaidCallVoucher']([ctx, serial, language])

    def _redeemPaidCallVoucher(self, ctx, serial, language):
        self._send_redeemPaidCallVoucher(ctx, serial, language)
        return self._recv_redeemPaidCallVoucher(ctx)

    def _send_redeemPaidCallVoucher(self, ctx, serial, language):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('redeemPaidCallVoucher', TMessageType.CALL, 0)
            args = redeemPaidCallVoucher_args()
            args.serial = serial
            args.language = language
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_redeemPaidCallVoucher(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = redeemPaidCallVoucher_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "redeemPaidCallVoucher failed: unknown result")
        raise x

    def getPreferredDisplayName(self, ctx, mids):
        """
        Args:
            ctx: FContext
            mids: list of string
        """
        return self._methods['getPreferredDisplayName']([ctx, mids])

    def _getPreferredDisplayName(self, ctx, mids):
        self._send_getPreferredDisplayName(ctx, mids)
        return self._recv_getPreferredDisplayName(ctx)

    def _send_getPreferredDisplayName(self, ctx, mids):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getPreferredDisplayName', TMessageType.CALL, 0)
            args = getPreferredDisplayName_args()
            args.mids = mids
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getPreferredDisplayName(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getPreferredDisplayName_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getPreferredDisplayName failed: unknown result")
        raise x

    def getContactsForChannel(self, ctx, ids):
        """
        Args:
            ctx: FContext
            ids: list of string
        """
        return self._methods['getContactsForChannel']([ctx, ids])

    def _getContactsForChannel(self, ctx, ids):
        self._send_getContactsForChannel(ctx, ids)
        return self._recv_getContactsForChannel(ctx)

    def _send_getContactsForChannel(self, ctx, ids):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getContactsForChannel', TMessageType.CALL, 0)
            args = getContactsForChannel_args()
            args.ids = ids
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getContactsForChannel(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getContactsForChannel_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getContactsForChannel failed: unknown result")
        raise x

    def getCallCreditProducts(self, ctx, appStoreCode, pgCode, country, language):
        """
        Args:
            ctx: FContext
            appStoreCode: PaymentType
            pgCode: PaymentPgType
            country: string
            language: string
        """
        return self._methods['getCallCreditProducts']([ctx, appStoreCode, pgCode, country, language])

    def _getCallCreditProducts(self, ctx, appStoreCode, pgCode, country, language):
        self._send_getCallCreditProducts(ctx, appStoreCode, pgCode, country, language)
        return self._recv_getCallCreditProducts(ctx)

    def _send_getCallCreditProducts(self, ctx, appStoreCode, pgCode, country, language):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getCallCreditProducts', TMessageType.CALL, 0)
            args = getCallCreditProducts_args()
            args.appStoreCode = appStoreCode
            args.pgCode = pgCode
            args.country = country
            args.language = language
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getCallCreditProducts(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getCallCreditProducts_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getCallCreditProducts failed: unknown result")
        raise x

    def getCompactContacts(self, ctx, lastModifiedTimestamp):
        """
        Args:
            ctx: FContext
            lastModifiedTimestamp: int (signed 64 bits)
        """
        return self._methods['getCompactContacts']([ctx, lastModifiedTimestamp])

    def _getCompactContacts(self, ctx, lastModifiedTimestamp):
        self._send_getCompactContacts(ctx, lastModifiedTimestamp)
        return self._recv_getCompactContacts(ctx)

    def _send_getCompactContacts(self, ctx, lastModifiedTimestamp):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getCompactContacts', TMessageType.CALL, 0)
            args = getCompactContacts_args()
            args.lastModifiedTimestamp = lastModifiedTimestamp
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getCompactContacts(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getCompactContacts_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getCompactContacts failed: unknown result")
        raise x

    def notifyNotiCenterEvent(self, ctx, event):
        """
        Args:
            ctx: FContext
            event: NotiCenterEventData
        """
        return self._methods['notifyNotiCenterEvent']([ctx, event])

    def _notifyNotiCenterEvent(self, ctx, event):
        self._send_notifyNotiCenterEvent(ctx, event)
        self._recv_notifyNotiCenterEvent(ctx)

    def _send_notifyNotiCenterEvent(self, ctx, event):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('notifyNotiCenterEvent', TMessageType.CALL, 0)
            args = notifyNotiCenterEvent_args()
            args.event = event
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_notifyNotiCenterEvent(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = notifyNotiCenterEvent_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def isInContact(self, ctx, mid):
        """
        Args:
            ctx: FContext
            mid: string
        """
        return self._methods['isInContact']([ctx, mid])

    def _isInContact(self, ctx, mid):
        self._send_isInContact(ctx, mid)
        return self._recv_isInContact(ctx)

    def _send_isInContact(self, ctx, mid):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('isInContact', TMessageType.CALL, 0)
            args = isInContact_args()
            args.mid = mid
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_isInContact(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = isInContact_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "isInContact failed: unknown result")
        raise x

    def lookupGroupMembers(self, ctx, groupId, mids):
        """
        Args:
            ctx: FContext
            groupId: string
            mids: list of string
        """
        return self._methods['lookupGroupMembers']([ctx, groupId, mids])

    def _lookupGroupMembers(self, ctx, groupId, mids):
        self._send_lookupGroupMembers(ctx, groupId, mids)
        return self._recv_lookupGroupMembers(ctx)

    def _send_lookupGroupMembers(self, ctx, groupId, mids):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('lookupGroupMembers', TMessageType.CALL, 0)
            args = lookupGroupMembers_args()
            args.groupId = groupId
            args.mids = mids
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_lookupGroupMembers(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = lookupGroupMembers_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "lookupGroupMembers failed: unknown result")
        raise x

    def getRoomInformation(self, ctx, roomMid):
        """
        Args:
            ctx: FContext
            roomMid: string
        """
        return self._methods['getRoomInformation']([ctx, roomMid])

    def _getRoomInformation(self, ctx, roomMid):
        self._send_getRoomInformation(ctx, roomMid)
        return self._recv_getRoomInformation(ctx)

    def _send_getRoomInformation(self, ctx, roomMid):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getRoomInformation', TMessageType.CALL, 0)
            args = getRoomInformation_args()
            args.roomMid = roomMid
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getRoomInformation(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getRoomInformation_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getRoomInformation failed: unknown result")
        raise x

    def getGroupCall(self, ctx, chatMid):
        """
        Args:
            ctx: FContext
            chatMid: string
        """
        return self._methods['getGroupCall']([ctx, chatMid])

    def _getGroupCall(self, ctx, chatMid):
        self._send_getGroupCall(ctx, chatMid)
        return self._recv_getGroupCall(ctx)

    def _send_getGroupCall(self, ctx, chatMid):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getGroupCall', TMessageType.CALL, 0)
            args = getGroupCall_args()
            args.chatMid = chatMid
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getGroupCall(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getGroupCall_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getGroupCall failed: unknown result")
        raise x

    def isAllowSecondaryDeviceLogin(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['isAllowSecondaryDeviceLogin']([ctx])

    def _isAllowSecondaryDeviceLogin(self, ctx):
        self._send_isAllowSecondaryDeviceLogin(ctx)
        return self._recv_isAllowSecondaryDeviceLogin(ctx)

    def _send_isAllowSecondaryDeviceLogin(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('isAllowSecondaryDeviceLogin', TMessageType.CALL, 0)
            args = isAllowSecondaryDeviceLogin_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_isAllowSecondaryDeviceLogin(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = isAllowSecondaryDeviceLogin_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "isAllowSecondaryDeviceLogin failed: unknown result")
        raise x

    def getPrimaryClientForChannel(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getPrimaryClientForChannel']([ctx])

    def _getPrimaryClientForChannel(self, ctx):
        self._send_getPrimaryClientForChannel(ctx)
        return self._recv_getPrimaryClientForChannel(ctx)

    def _send_getPrimaryClientForChannel(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getPrimaryClientForChannel', TMessageType.CALL, 0)
            args = getPrimaryClientForChannel_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getPrimaryClientForChannel(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getPrimaryClientForChannel_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getPrimaryClientForChannel failed: unknown result")
        raise x

    def createRoomWithBuddy(self, ctx, reqSeq, buddyMid, contactIds):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            buddyMid: string
            contactIds: list of string
        """
        return self._methods['createRoomWithBuddy']([ctx, reqSeq, buddyMid, contactIds])

    def _createRoomWithBuddy(self, ctx, reqSeq, buddyMid, contactIds):
        self._send_createRoomWithBuddy(ctx, reqSeq, buddyMid, contactIds)
        return self._recv_createRoomWithBuddy(ctx)

    def _send_createRoomWithBuddy(self, ctx, reqSeq, buddyMid, contactIds):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('createRoomWithBuddy', TMessageType.CALL, 0)
            args = createRoomWithBuddy_args()
            args.reqSeq = reqSeq
            args.buddyMid = buddyMid
            args.contactIds = contactIds
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_createRoomWithBuddy(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = createRoomWithBuddy_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "createRoomWithBuddy failed: unknown result")
        raise x

    def getDisplayName(self, ctx, mid):
        """
        Args:
            ctx: FContext
            mid: string
        """
        return self._methods['getDisplayName']([ctx, mid])

    def _getDisplayName(self, ctx, mid):
        self._send_getDisplayName(ctx, mid)
        return self._recv_getDisplayName(ctx)

    def _send_getDisplayName(self, ctx, mid):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getDisplayName', TMessageType.CALL, 0)
            args = getDisplayName_args()
            args.mid = mid
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getDisplayName(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getDisplayName_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getDisplayName failed: unknown result")
        raise x

    def getPaidCallMetadata(self, ctx, language):
        """
        Args:
            ctx: FContext
            language: string
        """
        return self._methods['getPaidCallMetadata']([ctx, language])

    def _getPaidCallMetadata(self, ctx, language):
        self._send_getPaidCallMetadata(ctx, language)
        return self._recv_getPaidCallMetadata(ctx)

    def _send_getPaidCallMetadata(self, ctx, language):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getPaidCallMetadata', TMessageType.CALL, 0)
            args = getPaidCallMetadata_args()
            args.language = language
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getPaidCallMetadata(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getPaidCallMetadata_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getPaidCallMetadata failed: unknown result")
        raise x

    def getMid(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getMid']([ctx])

    def _getMid(self, ctx):
        self._send_getMid(ctx)
        return self._recv_getMid(ctx)

    def _send_getMid(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getMid', TMessageType.CALL, 0)
            args = getMid_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getMid(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getMid_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getMid failed: unknown result")
        raise x

    def getUserCountryForBilling(self, ctx, country, remoteIp):
        """
        Args:
            ctx: FContext
            country: string
            remoteIp: string
        """
        return self._methods['getUserCountryForBilling']([ctx, country, remoteIp])

    def _getUserCountryForBilling(self, ctx, country, remoteIp):
        self._send_getUserCountryForBilling(ctx, country, remoteIp)
        return self._recv_getUserCountryForBilling(ctx)

    def _send_getUserCountryForBilling(self, ctx, country, remoteIp):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getUserCountryForBilling', TMessageType.CALL, 0)
            args = getUserCountryForBilling_args()
            args.country = country
            args.remoteIp = remoteIp
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getUserCountryForBilling(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getUserCountryForBilling_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getUserCountryForBilling failed: unknown result")
        raise x

    def getFavoriteGroupIdsForChannel(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getFavoriteGroupIdsForChannel']([ctx])

    def _getFavoriteGroupIdsForChannel(self, ctx):
        self._send_getFavoriteGroupIdsForChannel(ctx)
        return self._recv_getFavoriteGroupIdsForChannel(ctx)

    def _send_getFavoriteGroupIdsForChannel(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getFavoriteGroupIdsForChannel', TMessageType.CALL, 0)
            args = getFavoriteGroupIdsForChannel_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getFavoriteGroupIdsForChannel(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getFavoriteGroupIdsForChannel_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getFavoriteGroupIdsForChannel failed: unknown result")
        raise x

    def getPaidCallHistory(self, ctx, start, size, language):
        """
        Args:
            ctx: FContext
            start: int (signed 64 bits)
            size: int (signed 32 bits)
            language: string
        """
        return self._methods['getPaidCallHistory']([ctx, start, size, language])

    def _getPaidCallHistory(self, ctx, start, size, language):
        self._send_getPaidCallHistory(ctx, start, size, language)
        return self._recv_getPaidCallHistory(ctx)

    def _send_getPaidCallHistory(self, ctx, start, size, language):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getPaidCallHistory', TMessageType.CALL, 0)
            args = getPaidCallHistory_args()
            args.start = start
            args.size = size
            args.language = language
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getPaidCallHistory(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getPaidCallHistory_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getPaidCallHistory failed: unknown result")
        raise x

    def sendPinCodeOperation(self, ctx, verifier):
        """
        Args:
            ctx: FContext
            verifier: string
        """
        return self._methods['sendPinCodeOperation']([ctx, verifier])

    def _sendPinCodeOperation(self, ctx, verifier):
        self._send_sendPinCodeOperation(ctx, verifier)
        self._recv_sendPinCodeOperation(ctx)

    def _send_sendPinCodeOperation(self, ctx, verifier):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('sendPinCodeOperation', TMessageType.CALL, 0)
            args = sendPinCodeOperation_args()
            args.verifier = verifier
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_sendPinCodeOperation(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = sendPinCodeOperation_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def inviteIntoGroupCall(self, ctx, chatMid, memberMids, mediaType):
        """
        Args:
            ctx: FContext
            chatMid: string
            memberMids: list of string
            mediaType: GroupCallMediaType
        """
        return self._methods['inviteIntoGroupCall']([ctx, chatMid, memberMids, mediaType])

    def _inviteIntoGroupCall(self, ctx, chatMid, memberMids, mediaType):
        self._send_inviteIntoGroupCall(ctx, chatMid, memberMids, mediaType)
        self._recv_inviteIntoGroupCall(ctx)

    def _send_inviteIntoGroupCall(self, ctx, chatMid, memberMids, mediaType):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('inviteIntoGroupCall', TMessageType.CALL, 0)
            args = inviteIntoGroupCall_args()
            args.chatMid = chatMid
            args.memberMids = memberMids
            args.mediaType = mediaType
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_inviteIntoGroupCall(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = inviteIntoGroupCall_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def getFriendMids(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getFriendMids']([ctx])

    def _getFriendMids(self, ctx):
        self._send_getFriendMids(ctx)
        return self._recv_getFriendMids(ctx)

    def _send_getFriendMids(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getFriendMids', TMessageType.CALL, 0)
            args = getFriendMids_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getFriendMids(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getFriendMids_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getFriendMids failed: unknown result")
        raise x

    def getMetaProfile(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getMetaProfile']([ctx])

    def _getMetaProfile(self, ctx):
        self._send_getMetaProfile(ctx)
        return self._recv_getMetaProfile(ctx)

    def _send_getMetaProfile(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getMetaProfile', TMessageType.CALL, 0)
            args = getMetaProfile_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getMetaProfile(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getMetaProfile_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getMetaProfile failed: unknown result")
        raise x

    def sendMessageForChannel(self, ctx, message):
        """
        Args:
            ctx: FContext
            message: Message
        """
        return self._methods['sendMessageForChannel']([ctx, message])

    def _sendMessageForChannel(self, ctx, message):
        self._send_sendMessageForChannel(ctx, message)
        return self._recv_sendMessageForChannel(ctx)

    def _send_sendMessageForChannel(self, ctx, message):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('sendMessageForChannel', TMessageType.CALL, 0)
            args = sendMessageForChannel_args()
            args.message = message
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_sendMessageForChannel(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = sendMessageForChannel_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "sendMessageForChannel failed: unknown result")
        raise x

    def activeBuddySubscriberCount(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['activeBuddySubscriberCount']([ctx])

    def _activeBuddySubscriberCount(self, ctx):
        self._send_activeBuddySubscriberCount(ctx)
        return self._recv_activeBuddySubscriberCount(ctx)

    def _send_activeBuddySubscriberCount(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('activeBuddySubscriberCount', TMessageType.CALL, 0)
            args = activeBuddySubscriberCount_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_activeBuddySubscriberCount(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = activeBuddySubscriberCount_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "activeBuddySubscriberCount failed: unknown result")
        raise x

    def getCallCreditPurchaseHistory(self, ctx, request):
        """
        Args:
            ctx: FContext
            request: CoinHistoryCondition
        """
        return self._methods['getCallCreditPurchaseHistory']([ctx, request])

    def _getCallCreditPurchaseHistory(self, ctx, request):
        self._send_getCallCreditPurchaseHistory(ctx, request)
        return self._recv_getCallCreditPurchaseHistory(ctx)

    def _send_getCallCreditPurchaseHistory(self, ctx, request):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getCallCreditPurchaseHistory', TMessageType.CALL, 0)
            args = getCallCreditPurchaseHistory_args()
            args.request = request
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getCallCreditPurchaseHistory(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getCallCreditPurchaseHistory_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getCallCreditPurchaseHistory failed: unknown result")
        raise x

    def isRoomMember(self, ctx, roomId):
        """
        Args:
            ctx: FContext
            roomId: string
        """
        return self._methods['isRoomMember']([ctx, roomId])

    def _isRoomMember(self, ctx, roomId):
        self._send_isRoomMember(ctx, roomId)
        return self._recv_isRoomMember(ctx)

    def _send_isRoomMember(self, ctx, roomId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('isRoomMember', TMessageType.CALL, 0)
            args = isRoomMember_args()
            args.roomId = roomId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_isRoomMember(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = isRoomMember_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "isRoomMember failed: unknown result")
        raise x

    def sendSystemOAMessage(self, ctx, message):
        """
        Args:
            ctx: FContext
            message: Message
        """
        return self._methods['sendSystemOAMessage']([ctx, message])

    def _sendSystemOAMessage(self, ctx, message):
        self._send_sendSystemOAMessage(ctx, message)
        return self._recv_sendSystemOAMessage(ctx)

    def _send_sendSystemOAMessage(self, ctx, message):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('sendSystemOAMessage', TMessageType.CALL, 0)
            args = sendSystemOAMessage_args()
            args.message = message
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_sendSystemOAMessage(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = sendSystemOAMessage_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "sendSystemOAMessage failed: unknown result")
        raise x

    def acquirePaidCallRoute(self, ctx, paidCallType, dialedNumber, language, networkCode, disableCallerId, referer, adSessionId):
        """
        Args:
            ctx: FContext
            paidCallType: PaidCallType
            dialedNumber: string
            language: string
            networkCode: string
            disableCallerId: boolean
            referer: string
            adSessionId: string
        """
        return self._methods['acquirePaidCallRoute']([ctx, paidCallType, dialedNumber, language, networkCode, disableCallerId, referer, adSessionId])

    def _acquirePaidCallRoute(self, ctx, paidCallType, dialedNumber, language, networkCode, disableCallerId, referer, adSessionId):
        self._send_acquirePaidCallRoute(ctx, paidCallType, dialedNumber, language, networkCode, disableCallerId, referer, adSessionId)
        return self._recv_acquirePaidCallRoute(ctx)

    def _send_acquirePaidCallRoute(self, ctx, paidCallType, dialedNumber, language, networkCode, disableCallerId, referer, adSessionId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('acquirePaidCallRoute', TMessageType.CALL, 0)
            args = acquirePaidCallRoute_args()
            args.paidCallType = paidCallType
            args.dialedNumber = dialedNumber
            args.language = language
            args.networkCode = networkCode
            args.disableCallerId = disableCallerId
            args.referer = referer
            args.adSessionId = adSessionId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_acquirePaidCallRoute(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = acquirePaidCallRoute_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "acquirePaidCallRoute failed: unknown result")
        raise x

    def getGroupsForChannel(self, ctx, groupIds):
        """
        Args:
            ctx: FContext
            groupIds: list of string
        """
        return self._methods['getGroupsForChannel']([ctx, groupIds])

    def _getGroupsForChannel(self, ctx, groupIds):
        self._send_getGroupsForChannel(ctx, groupIds)
        return self._recv_getGroupsForChannel(ctx)

    def _send_getGroupsForChannel(self, ctx, groupIds):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getGroupsForChannel', TMessageType.CALL, 0)
            args = getGroupsForChannel_args()
            args.groupIds = groupIds
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getGroupsForChannel(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getGroupsForChannel_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getGroupsForChannel failed: unknown result")
        raise x

    def getUserCreateTime(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getUserCreateTime']([ctx])

    def _getUserCreateTime(self, ctx):
        self._send_getUserCreateTime(ctx)
        return self._recv_getUserCreateTime(ctx)

    def _send_getUserCreateTime(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getUserCreateTime', TMessageType.CALL, 0)
            args = getUserCreateTime_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getUserCreateTime(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getUserCreateTime_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getUserCreateTime failed: unknown result")
        raise x

    def registerChannelCP(self, ctx, cpId, registerPassword):
        """
        Args:
            ctx: FContext
            cpId: string
            registerPassword: string
        """
        return self._methods['registerChannelCP']([ctx, cpId, registerPassword])

    def _registerChannelCP(self, ctx, cpId, registerPassword):
        self._send_registerChannelCP(ctx, cpId, registerPassword)
        return self._recv_registerChannelCP(ctx)

    def _send_registerChannelCP(self, ctx, cpId, registerPassword):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('registerChannelCP', TMessageType.CALL, 0)
            args = registerChannelCP_args()
            args.cpId = cpId
            args.registerPassword = registerPassword
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_registerChannelCP(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = registerChannelCP_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "registerChannelCP failed: unknown result")
        raise x

    def reserveCallCreditPurchase(self, ctx, request):
        """
        Args:
            ctx: FContext
            request: CoinPurchaseReservation
        """
        return self._methods['reserveCallCreditPurchase']([ctx, request])

    def _reserveCallCreditPurchase(self, ctx, request):
        self._send_reserveCallCreditPurchase(ctx, request)
        return self._recv_reserveCallCreditPurchase(ctx)

    def _send_reserveCallCreditPurchase(self, ctx, request):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('reserveCallCreditPurchase', TMessageType.CALL, 0)
            args = reserveCallCreditPurchase_args()
            args.request = request
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_reserveCallCreditPurchase(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = reserveCallCreditPurchase_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "reserveCallCreditPurchase failed: unknown result")
        raise x

    def acquirePaidCallCurrencyExchangeRate(self, ctx, language):
        """
        Args:
            ctx: FContext
            language: string
        """
        return self._methods['acquirePaidCallCurrencyExchangeRate']([ctx, language])

    def _acquirePaidCallCurrencyExchangeRate(self, ctx, language):
        self._send_acquirePaidCallCurrencyExchangeRate(ctx, language)
        return self._recv_acquirePaidCallCurrencyExchangeRate(ctx)

    def _send_acquirePaidCallCurrencyExchangeRate(self, ctx, language):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('acquirePaidCallCurrencyExchangeRate', TMessageType.CALL, 0)
            args = acquirePaidCallCurrencyExchangeRate_args()
            args.language = language
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_acquirePaidCallCurrencyExchangeRate(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = acquirePaidCallCurrencyExchangeRate_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "acquirePaidCallCurrencyExchangeRate failed: unknown result")
        raise x

    def getRoomMemberMidsForAppPlatform(self, ctx, roomId):
        """
        Args:
            ctx: FContext
            roomId: string
        """
        return self._methods['getRoomMemberMidsForAppPlatform']([ctx, roomId])

    def _getRoomMemberMidsForAppPlatform(self, ctx, roomId):
        self._send_getRoomMemberMidsForAppPlatform(ctx, roomId)
        return self._recv_getRoomMemberMidsForAppPlatform(ctx)

    def _send_getRoomMemberMidsForAppPlatform(self, ctx, roomId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getRoomMemberMidsForAppPlatform', TMessageType.CALL, 0)
            args = getRoomMemberMidsForAppPlatform_args()
            args.roomId = roomId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getRoomMemberMidsForAppPlatform(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getRoomMemberMidsForAppPlatform_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getRoomMemberMidsForAppPlatform failed: unknown result")
        raise x

    def getPaidCallBalanceList(self, ctx, language):
        """
        Args:
            ctx: FContext
            language: string
        """
        return self._methods['getPaidCallBalanceList']([ctx, language])

    def _getPaidCallBalanceList(self, ctx, language):
        self._send_getPaidCallBalanceList(ctx, language)
        return self._recv_getPaidCallBalanceList(ctx)

    def _send_getPaidCallBalanceList(self, ctx, language):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getPaidCallBalanceList', TMessageType.CALL, 0)
            args = getPaidCallBalanceList_args()
            args.language = language
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getPaidCallBalanceList(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getPaidCallBalanceList_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getPaidCallBalanceList failed: unknown result")
        raise x

    def getPersonalInfos(self, ctx, requiredPersonalInfos):
        """
        Args:
            ctx: FContext
            requiredPersonalInfos: set of PersonalInfo
        """
        return self._methods['getPersonalInfos']([ctx, requiredPersonalInfos])

    def _getPersonalInfos(self, ctx, requiredPersonalInfos):
        self._send_getPersonalInfos(ctx, requiredPersonalInfos)
        return self._recv_getPersonalInfos(ctx)

    def _send_getPersonalInfos(self, ctx, requiredPersonalInfos):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getPersonalInfos', TMessageType.CALL, 0)
            args = getPersonalInfos_args()
            args.requiredPersonalInfos = requiredPersonalInfos
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getPersonalInfos(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getPersonalInfos_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getPersonalInfos failed: unknown result")
        raise x

    def getPrimaryClientsForChannel(self, ctx, userMids):
        """
        Args:
            ctx: FContext
            userMids: list of string
        """
        return self._methods['getPrimaryClientsForChannel']([ctx, userMids])

    def _getPrimaryClientsForChannel(self, ctx, userMids):
        self._send_getPrimaryClientsForChannel(ctx, userMids)
        return self._recv_getPrimaryClientsForChannel(ctx)

    def _send_getPrimaryClientsForChannel(self, ctx, userMids):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getPrimaryClientsForChannel', TMessageType.CALL, 0)
            args = getPrimaryClientsForChannel_args()
            args.userMids = userMids
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getPrimaryClientsForChannel(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getPrimaryClientsForChannel_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getPrimaryClientsForChannel failed: unknown result")
        raise x

    def addBuddyToContact(self, ctx, buddyMid):
        """
        Args:
            ctx: FContext
            buddyMid: string
        """
        return self._methods['addBuddyToContact']([ctx, buddyMid])

    def _addBuddyToContact(self, ctx, buddyMid):
        self._send_addBuddyToContact(ctx, buddyMid)
        return self._recv_addBuddyToContact(ctx)

    def _send_addBuddyToContact(self, ctx, buddyMid):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('addBuddyToContact', TMessageType.CALL, 0)
            args = addBuddyToContact_args()
            args.buddyMid = buddyMid
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_addBuddyToContact(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = addBuddyToContact_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "addBuddyToContact failed: unknown result")
        raise x

    def getGroupMemberMidsForAppPlatform(self, ctx, groupId):
        """
        Args:
            ctx: FContext
            groupId: string
        """
        return self._methods['getGroupMemberMidsForAppPlatform']([ctx, groupId])

    def _getGroupMemberMidsForAppPlatform(self, ctx, groupId):
        self._send_getGroupMemberMidsForAppPlatform(ctx, groupId)
        return self._recv_getGroupMemberMidsForAppPlatform(ctx)

    def _send_getGroupMemberMidsForAppPlatform(self, ctx, groupId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getGroupMemberMidsForAppPlatform', TMessageType.CALL, 0)
            args = getGroupMemberMidsForAppPlatform_args()
            args.groupId = groupId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getGroupMemberMidsForAppPlatform(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getGroupMemberMidsForAppPlatform_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getGroupMemberMidsForAppPlatform failed: unknown result")
        raise x

    def getUserLanguage(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getUserLanguage']([ctx])

    def _getUserLanguage(self, ctx):
        self._send_getUserLanguage(ctx)
        return self._recv_getUserLanguage(ctx)

    def _send_getUserLanguage(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getUserLanguage', TMessageType.CALL, 0)
            args = getUserLanguage_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getUserLanguage(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getUserLanguage_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getUserLanguage failed: unknown result")
        raise x

    def lookupPaidCall(self, ctx, dialedNumber, language, referer):
        """
        Args:
            ctx: FContext
            dialedNumber: string
            language: string
            referer: string
        """
        return self._methods['lookupPaidCall']([ctx, dialedNumber, language, referer])

    def _lookupPaidCall(self, ctx, dialedNumber, language, referer):
        self._send_lookupPaidCall(ctx, dialedNumber, language, referer)
        return self._recv_lookupPaidCall(ctx)

    def _send_lookupPaidCall(self, ctx, dialedNumber, language, referer):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('lookupPaidCall', TMessageType.CALL, 0)
            args = lookupPaidCall_args()
            args.dialedNumber = dialedNumber
            args.language = language
            args.referer = referer
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_lookupPaidCall(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = lookupPaidCall_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "lookupPaidCall failed: unknown result")
        raise x

    def getExtendedProfile(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getExtendedProfile']([ctx])

    def _getExtendedProfile(self, ctx):
        self._send_getExtendedProfile(ctx)
        return self._recv_getExtendedProfile(ctx)

    def _send_getExtendedProfile(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getExtendedProfile', TMessageType.CALL, 0)
            args = getExtendedProfile_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getExtendedProfile(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getExtendedProfile_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getExtendedProfile failed: unknown result")
        raise x

    def getReverseCompactContacts(self, ctx, ids):
        """
        Args:
            ctx: FContext
            ids: list of string
        """
        return self._methods['getReverseCompactContacts']([ctx, ids])

    def _getReverseCompactContacts(self, ctx, ids):
        self._send_getReverseCompactContacts(ctx, ids)
        return self._recv_getReverseCompactContacts(ctx)

    def _send_getReverseCompactContacts(self, ctx, ids):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getReverseCompactContacts', TMessageType.CALL, 0)
            args = getReverseCompactContacts_args()
            args.ids = ids
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getReverseCompactContacts(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getReverseCompactContacts_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getReverseCompactContacts failed: unknown result")
        raise x

    def getPaidCallAdStatus(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getPaidCallAdStatus']([ctx])

    def _getPaidCallAdStatus(self, ctx):
        self._send_getPaidCallAdStatus(ctx)
        return self._recv_getPaidCallAdStatus(ctx)

    def _send_getPaidCallAdStatus(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getPaidCallAdStatus', TMessageType.CALL, 0)
            args = getPaidCallAdStatus_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getPaidCallAdStatus(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getPaidCallAdStatus_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getPaidCallAdStatus failed: unknown result")
        raise x

    def findContactByUseridWithoutAbuseBlockForChannel(self, ctx, userid):
        """
        Args:
            ctx: FContext
            userid: string
        """
        return self._methods['findContactByUseridWithoutAbuseBlockForChannel']([ctx, userid])

    def _findContactByUseridWithoutAbuseBlockForChannel(self, ctx, userid):
        self._send_findContactByUseridWithoutAbuseBlockForChannel(ctx, userid)
        return self._recv_findContactByUseridWithoutAbuseBlockForChannel(ctx)

    def _send_findContactByUseridWithoutAbuseBlockForChannel(self, ctx, userid):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('findContactByUseridWithoutAbuseBlockForChannel', TMessageType.CALL, 0)
            args = findContactByUseridWithoutAbuseBlockForChannel_args()
            args.userid = userid
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_findContactByUseridWithoutAbuseBlockForChannel(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = findContactByUseridWithoutAbuseBlockForChannel_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "findContactByUseridWithoutAbuseBlockForChannel failed: unknown result")
        raise x

    def getGroupMemberMids(self, ctx, groupId):
        """
        Args:
            ctx: FContext
            groupId: string
        """
        return self._methods['getGroupMemberMids']([ctx, groupId])

    def _getGroupMemberMids(self, ctx, groupId):
        self._send_getGroupMemberMids(ctx, groupId)
        return self._recv_getGroupMemberMids(ctx)

    def _send_getGroupMemberMids(self, ctx, groupId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getGroupMemberMids', TMessageType.CALL, 0)
            args = getGroupMemberMids_args()
            args.groupId = groupId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getGroupMemberMids(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getGroupMemberMids_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getGroupMemberMids failed: unknown result")
        raise x

    def sendMessageWithoutRelationship(self, ctx, message):
        """
        Args:
            ctx: FContext
            message: Message
        """
        return self._methods['sendMessageWithoutRelationship']([ctx, message])

    def _sendMessageWithoutRelationship(self, ctx, message):
        self._send_sendMessageWithoutRelationship(ctx, message)
        return self._recv_sendMessageWithoutRelationship(ctx)

    def _send_sendMessageWithoutRelationship(self, ctx, message):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('sendMessageWithoutRelationship', TMessageType.CALL, 0)
            args = sendMessageWithoutRelationship_args()
            args.message = message
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_sendMessageWithoutRelationship(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = sendMessageWithoutRelationship_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "sendMessageWithoutRelationship failed: unknown result")
        raise x

    def displayBuddySubscriberCountInBulk(self, ctx, mids):
        """
        Args:
            ctx: FContext
            mids: list of string
        """
        return self._methods['displayBuddySubscriberCountInBulk']([ctx, mids])

    def _displayBuddySubscriberCountInBulk(self, ctx, mids):
        self._send_displayBuddySubscriberCountInBulk(ctx, mids)
        return self._recv_displayBuddySubscriberCountInBulk(ctx)

    def _send_displayBuddySubscriberCountInBulk(self, ctx, mids):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('displayBuddySubscriberCountInBulk', TMessageType.CALL, 0)
            args = displayBuddySubscriberCountInBulk_args()
            args.mids = mids
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_displayBuddySubscriberCountInBulk(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = displayBuddySubscriberCountInBulk_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "displayBuddySubscriberCountInBulk failed: unknown result")
        raise x

    def lookupRoomMembers(self, ctx, roomId, mids):
        """
        Args:
            ctx: FContext
            roomId: string
            mids: list of string
        """
        return self._methods['lookupRoomMembers']([ctx, roomId, mids])

    def _lookupRoomMembers(self, ctx, roomId, mids):
        self._send_lookupRoomMembers(ctx, roomId, mids)
        return self._recv_lookupRoomMembers(ctx)

    def _send_lookupRoomMembers(self, ctx, roomId, mids):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('lookupRoomMembers', TMessageType.CALL, 0)
            args = lookupRoomMembers_args()
            args.roomId = roomId
            args.mids = mids
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_lookupRoomMembers(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = lookupRoomMembers_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "lookupRoomMembers failed: unknown result")
        raise x

    def getFavoriteMidsForChannel(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getFavoriteMidsForChannel']([ctx])

    def _getFavoriteMidsForChannel(self, ctx):
        self._send_getFavoriteMidsForChannel(ctx)
        return self._recv_getFavoriteMidsForChannel(ctx)

    def _send_getFavoriteMidsForChannel(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getFavoriteMidsForChannel', TMessageType.CALL, 0)
            args = getFavoriteMidsForChannel_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getFavoriteMidsForChannel(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getFavoriteMidsForChannel_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getFavoriteMidsForChannel failed: unknown result")
        raise x

    def getAllContactIdsForChannel(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getAllContactIdsForChannel']([ctx])

    def _getAllContactIdsForChannel(self, ctx):
        self._send_getAllContactIdsForChannel(ctx)
        return self._recv_getAllContactIdsForChannel(ctx)

    def _send_getAllContactIdsForChannel(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getAllContactIdsForChannel', TMessageType.CALL, 0)
            args = getAllContactIdsForChannel_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getAllContactIdsForChannel(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getAllContactIdsForChannel_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getAllContactIdsForChannel failed: unknown result")
        raise x

    def displayBuddySubscriberCount(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['displayBuddySubscriberCount']([ctx])

    def _displayBuddySubscriberCount(self, ctx):
        self._send_displayBuddySubscriberCount(ctx)
        return self._recv_displayBuddySubscriberCount(ctx)

    def _send_displayBuddySubscriberCount(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('displayBuddySubscriberCount', TMessageType.CALL, 0)
            args = displayBuddySubscriberCount_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_displayBuddySubscriberCount(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = displayBuddySubscriberCount_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "displayBuddySubscriberCount failed: unknown result")
        raise x

    def getProfileForChannel(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getProfileForChannel']([ctx])

    def _getProfileForChannel(self, ctx):
        self._send_getProfileForChannel(ctx)
        return self._recv_getProfileForChannel(ctx)

    def _send_getProfileForChannel(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getProfileForChannel', TMessageType.CALL, 0)
            args = getProfileForChannel_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getProfileForChannel(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getProfileForChannel_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getProfileForChannel failed: unknown result")
        raise x

    def getUserTickets(self, ctx, userMids):
        """
        Args:
            ctx: FContext
            userMids: list of string
        """
        return self._methods['getUserTickets']([ctx, userMids])

    def _getUserTickets(self, ctx, userMids):
        self._send_getUserTickets(ctx, userMids)
        return self._recv_getUserTickets(ctx)

    def _send_getUserTickets(self, ctx, userMids):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getUserTickets', TMessageType.CALL, 0)
            args = getUserTickets_args()
            args.userMids = userMids
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getUserTickets(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getUserTickets_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getUserTickets failed: unknown result")
        raise x

    def getOAFriendMids(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getOAFriendMids']([ctx])

    def _getOAFriendMids(self, ctx):
        self._send_getOAFriendMids(ctx)
        return self._recv_getOAFriendMids(ctx)

    def _send_getOAFriendMids(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getOAFriendMids', TMessageType.CALL, 0)
            args = getOAFriendMids_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getOAFriendMids(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getOAFriendMids_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getOAFriendMids failed: unknown result")
        raise x

    def searchPaidCallUserRate(self, ctx, countryCode, language):
        """
        Args:
            ctx: FContext
            countryCode: string
            language: string
        """
        return self._methods['searchPaidCallUserRate']([ctx, countryCode, language])

    def _searchPaidCallUserRate(self, ctx, countryCode, language):
        self._send_searchPaidCallUserRate(ctx, countryCode, language)
        return self._recv_searchPaidCallUserRate(ctx)

    def _send_searchPaidCallUserRate(self, ctx, countryCode, language):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('searchPaidCallUserRate', TMessageType.CALL, 0)
            args = searchPaidCallUserRate_args()
            args.countryCode = countryCode
            args.language = language
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_searchPaidCallUserRate(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = searchPaidCallUserRate_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "searchPaidCallUserRate failed: unknown result")
        raise x

    def getJoinedGroupIdsForChannel(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getJoinedGroupIdsForChannel']([ctx])

    def _getJoinedGroupIdsForChannel(self, ctx):
        self._send_getJoinedGroupIdsForChannel(ctx)
        return self._recv_getJoinedGroupIdsForChannel(ctx)

    def _send_getJoinedGroupIdsForChannel(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getJoinedGroupIdsForChannel', TMessageType.CALL, 0)
            args = getJoinedGroupIdsForChannel_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getJoinedGroupIdsForChannel(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getJoinedGroupIdsForChannel_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getJoinedGroupIdsForChannel failed: unknown result")
        raise x

    def acquireGroupCallRoute(self, ctx, chatMid, mediaType):
        """
        Args:
            ctx: FContext
            chatMid: string
            mediaType: GroupCallMediaType
        """
        return self._methods['acquireGroupCallRoute']([ctx, chatMid, mediaType])

    def _acquireGroupCallRoute(self, ctx, chatMid, mediaType):
        self._send_acquireGroupCallRoute(ctx, chatMid, mediaType)
        return self._recv_acquireGroupCallRoute(ctx)

    def _send_acquireGroupCallRoute(self, ctx, chatMid, mediaType):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('acquireGroupCallRoute', TMessageType.CALL, 0)
            args = acquireGroupCallRoute_args()
            args.chatMid = chatMid
            args.mediaType = mediaType
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_acquireGroupCallRoute(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = acquireGroupCallRoute_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "acquireGroupCallRoute failed: unknown result")
        raise x

    def getUserMidsWhoAddedMe(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getUserMidsWhoAddedMe']([ctx])

    def _getUserMidsWhoAddedMe(self, ctx):
        self._send_getUserMidsWhoAddedMe(ctx)
        return self._recv_getUserMidsWhoAddedMe(ctx)

    def _send_getUserMidsWhoAddedMe(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getUserMidsWhoAddedMe', TMessageType.CALL, 0)
            args = getUserMidsWhoAddedMe_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getUserMidsWhoAddedMe(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getUserMidsWhoAddedMe_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getUserMidsWhoAddedMe failed: unknown result")
        raise x

    def getIdentityCredential(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getIdentityCredential']([ctx])

    def _getIdentityCredential(self, ctx):
        self._send_getIdentityCredential(ctx)
        return self._recv_getIdentityCredential(ctx)

    def _send_getIdentityCredential(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getIdentityCredential', TMessageType.CALL, 0)
            args = getIdentityCredential_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getIdentityCredential(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getIdentityCredential_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getIdentityCredential failed: unknown result")
        raise x

    def addOperationForChannel(self, ctx, opType, param1, param2, param3):
        """
        Args:
            ctx: FContext
            opType: OpType
            param1: string
            param2: string
            param3: string
        """
        return self._methods['addOperationForChannel']([ctx, opType, param1, param2, param3])

    def _addOperationForChannel(self, ctx, opType, param1, param2, param3):
        self._send_addOperationForChannel(ctx, opType, param1, param2, param3)
        self._recv_addOperationForChannel(ctx)

    def _send_addOperationForChannel(self, ctx, opType, param1, param2, param3):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('addOperationForChannel', TMessageType.CALL, 0)
            args = addOperationForChannel_args()
            args.opType = opType
            args.param1 = param1
            args.param2 = param2
            args.param3 = param3
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_addOperationForChannel(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = addOperationForChannel_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def getSimpleChannelContacts(self, ctx, ids, statusSticonFallbackDisabled):
        """
        Args:
            ctx: FContext
            ids: list of string
            statusSticonFallbackDisabled: boolean
        """
        return self._methods['getSimpleChannelContacts']([ctx, ids, statusSticonFallbackDisabled])

    def _getSimpleChannelContacts(self, ctx, ids, statusSticonFallbackDisabled):
        self._send_getSimpleChannelContacts(ctx, ids, statusSticonFallbackDisabled)
        return self._recv_getSimpleChannelContacts(ctx)

    def _send_getSimpleChannelContacts(self, ctx, ids, statusSticonFallbackDisabled):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getSimpleChannelContacts', TMessageType.CALL, 0)
            args = getSimpleChannelContacts_args()
            args.ids = ids
            args.statusSticonFallbackDisabled = statusSticonFallbackDisabled
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getSimpleChannelContacts(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getSimpleChannelContacts_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getSimpleChannelContacts failed: unknown result")
        raise x

    def getUserLastSentMessageTimeStamp(self, ctx, mid):
        """
        Args:
            ctx: FContext
            mid: string
        """
        return self._methods['getUserLastSentMessageTimeStamp']([ctx, mid])

    def _getUserLastSentMessageTimeStamp(self, ctx, mid):
        self._send_getUserLastSentMessageTimeStamp(ctx, mid)
        return self._recv_getUserLastSentMessageTimeStamp(ctx)

    def _send_getUserLastSentMessageTimeStamp(self, ctx, mid):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getUserLastSentMessageTimeStamp', TMessageType.CALL, 0)
            args = getUserLastSentMessageTimeStamp_args()
            args.mid = mid
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getUserLastSentMessageTimeStamp(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getUserLastSentMessageTimeStamp_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getUserLastSentMessageTimeStamp failed: unknown result")
        raise x

class Processor(FBaseProcessor):

    def __init__(self, handler, middleware=None):
        """
        Create a new Processor.

        Args:
            handler: Iface
        """
        if middleware and not isinstance(middleware, list):
            middleware = [middleware]

        super(Processor, self).__init__()
        self.add_to_processor_map('getUserStatus', _getUserStatus(Method(handler.getUserStatus, middleware), self.get_write_lock()))
        self.add_to_processor_map('updateProfileAttributeForChannel', _updateProfileAttributeForChannel(Method(handler.updateProfileAttributeForChannel, middleware), self.get_write_lock()))
        self.add_to_processor_map('updateExtendedProfileAttribute', _updateExtendedProfileAttribute(Method(handler.updateExtendedProfileAttribute, middleware), self.get_write_lock()))
        self.add_to_processor_map('getAllSimpleChannelContacts', _getAllSimpleChannelContacts(Method(handler.getAllSimpleChannelContacts, middleware), self.get_write_lock()))
        self.add_to_processor_map('getUserIdentities', _getUserIdentities(Method(handler.getUserIdentities, middleware), self.get_write_lock()))
        self.add_to_processor_map('markPaidCallAd', _markPaidCallAd(Method(handler.markPaidCallAd, middleware), self.get_write_lock()))
        self.add_to_processor_map('isGroupMember', _isGroupMember(Method(handler.isGroupMember, middleware), self.get_write_lock()))
        self.add_to_processor_map('getPhoneInfoFromPhoneNumber', _getPhoneInfoFromPhoneNumber(Method(handler.getPhoneInfoFromPhoneNumber, middleware), self.get_write_lock()))
        self.add_to_processor_map('redeemPaidCallVoucher', _redeemPaidCallVoucher(Method(handler.redeemPaidCallVoucher, middleware), self.get_write_lock()))
        self.add_to_processor_map('getPreferredDisplayName', _getPreferredDisplayName(Method(handler.getPreferredDisplayName, middleware), self.get_write_lock()))
        self.add_to_processor_map('getContactsForChannel', _getContactsForChannel(Method(handler.getContactsForChannel, middleware), self.get_write_lock()))
        self.add_to_processor_map('getCallCreditProducts', _getCallCreditProducts(Method(handler.getCallCreditProducts, middleware), self.get_write_lock()))
        self.add_to_processor_map('getCompactContacts', _getCompactContacts(Method(handler.getCompactContacts, middleware), self.get_write_lock()))
        self.add_to_processor_map('notifyNotiCenterEvent', _notifyNotiCenterEvent(Method(handler.notifyNotiCenterEvent, middleware), self.get_write_lock()))
        self.add_to_processor_map('isInContact', _isInContact(Method(handler.isInContact, middleware), self.get_write_lock()))
        self.add_to_processor_map('lookupGroupMembers', _lookupGroupMembers(Method(handler.lookupGroupMembers, middleware), self.get_write_lock()))
        self.add_to_processor_map('getRoomInformation', _getRoomInformation(Method(handler.getRoomInformation, middleware), self.get_write_lock()))
        self.add_to_processor_map('getGroupCall', _getGroupCall(Method(handler.getGroupCall, middleware), self.get_write_lock()))
        self.add_to_processor_map('isAllowSecondaryDeviceLogin', _isAllowSecondaryDeviceLogin(Method(handler.isAllowSecondaryDeviceLogin, middleware), self.get_write_lock()))
        self.add_to_processor_map('getPrimaryClientForChannel', _getPrimaryClientForChannel(Method(handler.getPrimaryClientForChannel, middleware), self.get_write_lock()))
        self.add_to_processor_map('createRoomWithBuddy', _createRoomWithBuddy(Method(handler.createRoomWithBuddy, middleware), self.get_write_lock()))
        self.add_to_processor_map('getDisplayName', _getDisplayName(Method(handler.getDisplayName, middleware), self.get_write_lock()))
        self.add_to_processor_map('getPaidCallMetadata', _getPaidCallMetadata(Method(handler.getPaidCallMetadata, middleware), self.get_write_lock()))
        self.add_to_processor_map('getMid', _getMid(Method(handler.getMid, middleware), self.get_write_lock()))
        self.add_to_processor_map('getUserCountryForBilling', _getUserCountryForBilling(Method(handler.getUserCountryForBilling, middleware), self.get_write_lock()))
        self.add_to_processor_map('getFavoriteGroupIdsForChannel', _getFavoriteGroupIdsForChannel(Method(handler.getFavoriteGroupIdsForChannel, middleware), self.get_write_lock()))
        self.add_to_processor_map('getPaidCallHistory', _getPaidCallHistory(Method(handler.getPaidCallHistory, middleware), self.get_write_lock()))
        self.add_to_processor_map('sendPinCodeOperation', _sendPinCodeOperation(Method(handler.sendPinCodeOperation, middleware), self.get_write_lock()))
        self.add_to_processor_map('inviteIntoGroupCall', _inviteIntoGroupCall(Method(handler.inviteIntoGroupCall, middleware), self.get_write_lock()))
        self.add_to_processor_map('getFriendMids', _getFriendMids(Method(handler.getFriendMids, middleware), self.get_write_lock()))
        self.add_to_processor_map('getMetaProfile', _getMetaProfile(Method(handler.getMetaProfile, middleware), self.get_write_lock()))
        self.add_to_processor_map('sendMessageForChannel', _sendMessageForChannel(Method(handler.sendMessageForChannel, middleware), self.get_write_lock()))
        self.add_to_processor_map('activeBuddySubscriberCount', _activeBuddySubscriberCount(Method(handler.activeBuddySubscriberCount, middleware), self.get_write_lock()))
        self.add_to_processor_map('getCallCreditPurchaseHistory', _getCallCreditPurchaseHistory(Method(handler.getCallCreditPurchaseHistory, middleware), self.get_write_lock()))
        self.add_to_processor_map('isRoomMember', _isRoomMember(Method(handler.isRoomMember, middleware), self.get_write_lock()))
        self.add_to_processor_map('sendSystemOAMessage', _sendSystemOAMessage(Method(handler.sendSystemOAMessage, middleware), self.get_write_lock()))
        self.add_to_processor_map('acquirePaidCallRoute', _acquirePaidCallRoute(Method(handler.acquirePaidCallRoute, middleware), self.get_write_lock()))
        self.add_to_processor_map('getGroupsForChannel', _getGroupsForChannel(Method(handler.getGroupsForChannel, middleware), self.get_write_lock()))
        self.add_to_processor_map('getUserCreateTime', _getUserCreateTime(Method(handler.getUserCreateTime, middleware), self.get_write_lock()))
        self.add_to_processor_map('registerChannelCP', _registerChannelCP(Method(handler.registerChannelCP, middleware), self.get_write_lock()))
        self.add_to_processor_map('reserveCallCreditPurchase', _reserveCallCreditPurchase(Method(handler.reserveCallCreditPurchase, middleware), self.get_write_lock()))
        self.add_to_processor_map('acquirePaidCallCurrencyExchangeRate', _acquirePaidCallCurrencyExchangeRate(Method(handler.acquirePaidCallCurrencyExchangeRate, middleware), self.get_write_lock()))
        self.add_to_processor_map('getRoomMemberMidsForAppPlatform', _getRoomMemberMidsForAppPlatform(Method(handler.getRoomMemberMidsForAppPlatform, middleware), self.get_write_lock()))
        self.add_to_processor_map('getPaidCallBalanceList', _getPaidCallBalanceList(Method(handler.getPaidCallBalanceList, middleware), self.get_write_lock()))
        self.add_to_processor_map('getPersonalInfos', _getPersonalInfos(Method(handler.getPersonalInfos, middleware), self.get_write_lock()))
        self.add_to_processor_map('getPrimaryClientsForChannel', _getPrimaryClientsForChannel(Method(handler.getPrimaryClientsForChannel, middleware), self.get_write_lock()))
        self.add_to_processor_map('addBuddyToContact', _addBuddyToContact(Method(handler.addBuddyToContact, middleware), self.get_write_lock()))
        self.add_to_processor_map('getGroupMemberMidsForAppPlatform', _getGroupMemberMidsForAppPlatform(Method(handler.getGroupMemberMidsForAppPlatform, middleware), self.get_write_lock()))
        self.add_to_processor_map('getUserLanguage', _getUserLanguage(Method(handler.getUserLanguage, middleware), self.get_write_lock()))
        self.add_to_processor_map('lookupPaidCall', _lookupPaidCall(Method(handler.lookupPaidCall, middleware), self.get_write_lock()))
        self.add_to_processor_map('getExtendedProfile', _getExtendedProfile(Method(handler.getExtendedProfile, middleware), self.get_write_lock()))
        self.add_to_processor_map('getReverseCompactContacts', _getReverseCompactContacts(Method(handler.getReverseCompactContacts, middleware), self.get_write_lock()))
        self.add_to_processor_map('getPaidCallAdStatus', _getPaidCallAdStatus(Method(handler.getPaidCallAdStatus, middleware), self.get_write_lock()))
        self.add_to_processor_map('findContactByUseridWithoutAbuseBlockForChannel', _findContactByUseridWithoutAbuseBlockForChannel(Method(handler.findContactByUseridWithoutAbuseBlockForChannel, middleware), self.get_write_lock()))
        self.add_to_processor_map('getGroupMemberMids', _getGroupMemberMids(Method(handler.getGroupMemberMids, middleware), self.get_write_lock()))
        self.add_to_processor_map('sendMessageWithoutRelationship', _sendMessageWithoutRelationship(Method(handler.sendMessageWithoutRelationship, middleware), self.get_write_lock()))
        self.add_to_processor_map('displayBuddySubscriberCountInBulk', _displayBuddySubscriberCountInBulk(Method(handler.displayBuddySubscriberCountInBulk, middleware), self.get_write_lock()))
        self.add_to_processor_map('lookupRoomMembers', _lookupRoomMembers(Method(handler.lookupRoomMembers, middleware), self.get_write_lock()))
        self.add_to_processor_map('getFavoriteMidsForChannel', _getFavoriteMidsForChannel(Method(handler.getFavoriteMidsForChannel, middleware), self.get_write_lock()))
        self.add_to_processor_map('getAllContactIdsForChannel', _getAllContactIdsForChannel(Method(handler.getAllContactIdsForChannel, middleware), self.get_write_lock()))
        self.add_to_processor_map('displayBuddySubscriberCount', _displayBuddySubscriberCount(Method(handler.displayBuddySubscriberCount, middleware), self.get_write_lock()))
        self.add_to_processor_map('getProfileForChannel', _getProfileForChannel(Method(handler.getProfileForChannel, middleware), self.get_write_lock()))
        self.add_to_processor_map('getUserTickets', _getUserTickets(Method(handler.getUserTickets, middleware), self.get_write_lock()))
        self.add_to_processor_map('getOAFriendMids', _getOAFriendMids(Method(handler.getOAFriendMids, middleware), self.get_write_lock()))
        self.add_to_processor_map('searchPaidCallUserRate', _searchPaidCallUserRate(Method(handler.searchPaidCallUserRate, middleware), self.get_write_lock()))
        self.add_to_processor_map('getJoinedGroupIdsForChannel', _getJoinedGroupIdsForChannel(Method(handler.getJoinedGroupIdsForChannel, middleware), self.get_write_lock()))
        self.add_to_processor_map('acquireGroupCallRoute', _acquireGroupCallRoute(Method(handler.acquireGroupCallRoute, middleware), self.get_write_lock()))
        self.add_to_processor_map('getUserMidsWhoAddedMe', _getUserMidsWhoAddedMe(Method(handler.getUserMidsWhoAddedMe, middleware), self.get_write_lock()))
        self.add_to_processor_map('getIdentityCredential', _getIdentityCredential(Method(handler.getIdentityCredential, middleware), self.get_write_lock()))
        self.add_to_processor_map('addOperationForChannel', _addOperationForChannel(Method(handler.addOperationForChannel, middleware), self.get_write_lock()))
        self.add_to_processor_map('getSimpleChannelContacts', _getSimpleChannelContacts(Method(handler.getSimpleChannelContacts, middleware), self.get_write_lock()))
        self.add_to_processor_map('getUserLastSentMessageTimeStamp', _getUserLastSentMessageTimeStamp(Method(handler.getUserLastSentMessageTimeStamp, middleware), self.get_write_lock()))


class _getUserStatus(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getUserStatus, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getUserStatus_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getUserStatus_result()
        try:
            result.success = self._handler([ctx, args.mid])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getUserStatus", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getUserStatus", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getUserStatus', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getUserStatus", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _updateProfileAttributeForChannel(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_updateProfileAttributeForChannel, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = updateProfileAttributeForChannel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateProfileAttributeForChannel_result()
        try:
            self._handler([ctx, args.profileAttribute, args.value])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateProfileAttributeForChannel", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateProfileAttributeForChannel", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('updateProfileAttributeForChannel', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "updateProfileAttributeForChannel", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _updateExtendedProfileAttribute(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_updateExtendedProfileAttribute, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = updateExtendedProfileAttribute_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateExtendedProfileAttribute_result()
        try:
            self._handler([ctx, args.attr, args.extendedProfile])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateExtendedProfileAttribute", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateExtendedProfileAttribute", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('updateExtendedProfileAttribute', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "updateExtendedProfileAttribute", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getAllSimpleChannelContacts(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getAllSimpleChannelContacts, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getAllSimpleChannelContacts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAllSimpleChannelContacts_result()
        try:
            result.success = self._handler([ctx, args.statusSticonFallbackDisabled])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getAllSimpleChannelContacts", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getAllSimpleChannelContacts", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getAllSimpleChannelContacts', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getAllSimpleChannelContacts", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getUserIdentities(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getUserIdentities, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getUserIdentities_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getUserIdentities_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getUserIdentities", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getUserIdentities", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getUserIdentities', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getUserIdentities", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _markPaidCallAd(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_markPaidCallAd, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = markPaidCallAd_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = markPaidCallAd_result()
        try:
            result.success = self._handler([ctx, args.dialedNumber, args.language, args.disableCallerId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "markPaidCallAd", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "markPaidCallAd", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('markPaidCallAd', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "markPaidCallAd", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _isGroupMember(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_isGroupMember, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = isGroupMember_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = isGroupMember_result()
        try:
            result.success = self._handler([ctx, args.groupId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "isGroupMember", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "isGroupMember", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('isGroupMember', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "isGroupMember", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getPhoneInfoFromPhoneNumber(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getPhoneInfoFromPhoneNumber, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getPhoneInfoFromPhoneNumber_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getPhoneInfoFromPhoneNumber_result()
        try:
            result.success = self._handler([ctx, args.region, args.phoneNumber])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getPhoneInfoFromPhoneNumber", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getPhoneInfoFromPhoneNumber", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getPhoneInfoFromPhoneNumber', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getPhoneInfoFromPhoneNumber", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _redeemPaidCallVoucher(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_redeemPaidCallVoucher, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = redeemPaidCallVoucher_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = redeemPaidCallVoucher_result()
        try:
            result.success = self._handler([ctx, args.serial, args.language])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "redeemPaidCallVoucher", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "redeemPaidCallVoucher", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('redeemPaidCallVoucher', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "redeemPaidCallVoucher", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getPreferredDisplayName(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getPreferredDisplayName, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getPreferredDisplayName_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getPreferredDisplayName_result()
        try:
            result.success = self._handler([ctx, args.mids])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getPreferredDisplayName", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getPreferredDisplayName", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getPreferredDisplayName', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getPreferredDisplayName", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getContactsForChannel(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getContactsForChannel, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getContactsForChannel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getContactsForChannel_result()
        try:
            result.success = self._handler([ctx, args.ids])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getContactsForChannel", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getContactsForChannel", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getContactsForChannel', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getContactsForChannel", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getCallCreditProducts(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getCallCreditProducts, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getCallCreditProducts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCallCreditProducts_result()
        try:
            result.success = self._handler([ctx, args.appStoreCode, args.pgCode, args.country, args.language])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getCallCreditProducts", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getCallCreditProducts", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getCallCreditProducts', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getCallCreditProducts", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getCompactContacts(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getCompactContacts, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getCompactContacts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCompactContacts_result()
        try:
            result.success = self._handler([ctx, args.lastModifiedTimestamp])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getCompactContacts", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getCompactContacts", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getCompactContacts', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getCompactContacts", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _notifyNotiCenterEvent(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_notifyNotiCenterEvent, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = notifyNotiCenterEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = notifyNotiCenterEvent_result()
        try:
            self._handler([ctx, args.event])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "notifyNotiCenterEvent", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "notifyNotiCenterEvent", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('notifyNotiCenterEvent', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "notifyNotiCenterEvent", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _isInContact(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_isInContact, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = isInContact_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = isInContact_result()
        try:
            result.success = self._handler([ctx, args.mid])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "isInContact", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "isInContact", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('isInContact', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "isInContact", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _lookupGroupMembers(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_lookupGroupMembers, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = lookupGroupMembers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = lookupGroupMembers_result()
        try:
            result.success = self._handler([ctx, args.groupId, args.mids])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "lookupGroupMembers", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "lookupGroupMembers", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('lookupGroupMembers', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "lookupGroupMembers", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getRoomInformation(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getRoomInformation, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getRoomInformation_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRoomInformation_result()
        try:
            result.success = self._handler([ctx, args.roomMid])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getRoomInformation", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getRoomInformation", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getRoomInformation', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getRoomInformation", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getGroupCall(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getGroupCall, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getGroupCall_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getGroupCall_result()
        try:
            result.success = self._handler([ctx, args.chatMid])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getGroupCall", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getGroupCall", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getGroupCall', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getGroupCall", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _isAllowSecondaryDeviceLogin(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_isAllowSecondaryDeviceLogin, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = isAllowSecondaryDeviceLogin_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = isAllowSecondaryDeviceLogin_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "isAllowSecondaryDeviceLogin", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "isAllowSecondaryDeviceLogin", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('isAllowSecondaryDeviceLogin', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "isAllowSecondaryDeviceLogin", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getPrimaryClientForChannel(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getPrimaryClientForChannel, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getPrimaryClientForChannel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getPrimaryClientForChannel_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getPrimaryClientForChannel", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getPrimaryClientForChannel", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getPrimaryClientForChannel', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getPrimaryClientForChannel", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _createRoomWithBuddy(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_createRoomWithBuddy, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = createRoomWithBuddy_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createRoomWithBuddy_result()
        try:
            result.success = self._handler([ctx, args.reqSeq, args.buddyMid, args.contactIds])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "createRoomWithBuddy", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "createRoomWithBuddy", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('createRoomWithBuddy', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "createRoomWithBuddy", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getDisplayName(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getDisplayName, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getDisplayName_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDisplayName_result()
        try:
            result.success = self._handler([ctx, args.mid])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getDisplayName", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getDisplayName", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getDisplayName', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getDisplayName", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getPaidCallMetadata(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getPaidCallMetadata, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getPaidCallMetadata_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getPaidCallMetadata_result()
        try:
            result.success = self._handler([ctx, args.language])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getPaidCallMetadata", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getPaidCallMetadata", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getPaidCallMetadata', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getPaidCallMetadata", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getMid(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getMid, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getMid_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMid_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getMid", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getMid", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getMid', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getMid", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getUserCountryForBilling(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getUserCountryForBilling, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getUserCountryForBilling_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getUserCountryForBilling_result()
        try:
            result.success = self._handler([ctx, args.country, args.remoteIp])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getUserCountryForBilling", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getUserCountryForBilling", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getUserCountryForBilling', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getUserCountryForBilling", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getFavoriteGroupIdsForChannel(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getFavoriteGroupIdsForChannel, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getFavoriteGroupIdsForChannel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getFavoriteGroupIdsForChannel_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getFavoriteGroupIdsForChannel", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getFavoriteGroupIdsForChannel", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getFavoriteGroupIdsForChannel', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getFavoriteGroupIdsForChannel", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getPaidCallHistory(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getPaidCallHistory, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getPaidCallHistory_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getPaidCallHistory_result()
        try:
            result.success = self._handler([ctx, args.start, args.size, args.language])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getPaidCallHistory", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getPaidCallHistory", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getPaidCallHistory', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getPaidCallHistory", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _sendPinCodeOperation(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_sendPinCodeOperation, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = sendPinCodeOperation_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sendPinCodeOperation_result()
        try:
            self._handler([ctx, args.verifier])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "sendPinCodeOperation", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "sendPinCodeOperation", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('sendPinCodeOperation', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "sendPinCodeOperation", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _inviteIntoGroupCall(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_inviteIntoGroupCall, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = inviteIntoGroupCall_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = inviteIntoGroupCall_result()
        try:
            self._handler([ctx, args.chatMid, args.memberMids, args.mediaType])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "inviteIntoGroupCall", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "inviteIntoGroupCall", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('inviteIntoGroupCall', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "inviteIntoGroupCall", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getFriendMids(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getFriendMids, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getFriendMids_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getFriendMids_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getFriendMids", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getFriendMids", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getFriendMids', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getFriendMids", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getMetaProfile(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getMetaProfile, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getMetaProfile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMetaProfile_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getMetaProfile", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getMetaProfile", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getMetaProfile', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getMetaProfile", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _sendMessageForChannel(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_sendMessageForChannel, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = sendMessageForChannel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sendMessageForChannel_result()
        try:
            result.success = self._handler([ctx, args.message])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "sendMessageForChannel", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "sendMessageForChannel", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('sendMessageForChannel', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "sendMessageForChannel", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _activeBuddySubscriberCount(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_activeBuddySubscriberCount, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = activeBuddySubscriberCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = activeBuddySubscriberCount_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "activeBuddySubscriberCount", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "activeBuddySubscriberCount", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('activeBuddySubscriberCount', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "activeBuddySubscriberCount", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getCallCreditPurchaseHistory(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getCallCreditPurchaseHistory, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getCallCreditPurchaseHistory_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCallCreditPurchaseHistory_result()
        try:
            result.success = self._handler([ctx, args.request])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getCallCreditPurchaseHistory", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getCallCreditPurchaseHistory", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getCallCreditPurchaseHistory', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getCallCreditPurchaseHistory", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _isRoomMember(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_isRoomMember, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = isRoomMember_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = isRoomMember_result()
        try:
            result.success = self._handler([ctx, args.roomId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "isRoomMember", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "isRoomMember", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('isRoomMember', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "isRoomMember", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _sendSystemOAMessage(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_sendSystemOAMessage, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = sendSystemOAMessage_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sendSystemOAMessage_result()
        try:
            result.success = self._handler([ctx, args.message])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "sendSystemOAMessage", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "sendSystemOAMessage", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('sendSystemOAMessage', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "sendSystemOAMessage", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _acquirePaidCallRoute(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_acquirePaidCallRoute, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = acquirePaidCallRoute_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = acquirePaidCallRoute_result()
        try:
            result.success = self._handler([ctx, args.paidCallType, args.dialedNumber, args.language, args.networkCode, args.disableCallerId, args.referer, args.adSessionId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "acquirePaidCallRoute", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "acquirePaidCallRoute", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('acquirePaidCallRoute', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "acquirePaidCallRoute", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getGroupsForChannel(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getGroupsForChannel, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getGroupsForChannel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getGroupsForChannel_result()
        try:
            result.success = self._handler([ctx, args.groupIds])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getGroupsForChannel", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getGroupsForChannel", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getGroupsForChannel', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getGroupsForChannel", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getUserCreateTime(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getUserCreateTime, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getUserCreateTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getUserCreateTime_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getUserCreateTime", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getUserCreateTime", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getUserCreateTime', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getUserCreateTime", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _registerChannelCP(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_registerChannelCP, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = registerChannelCP_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = registerChannelCP_result()
        try:
            result.success = self._handler([ctx, args.cpId, args.registerPassword])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerChannelCP", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerChannelCP", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('registerChannelCP', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "registerChannelCP", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _reserveCallCreditPurchase(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_reserveCallCreditPurchase, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = reserveCallCreditPurchase_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = reserveCallCreditPurchase_result()
        try:
            result.success = self._handler([ctx, args.request])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "reserveCallCreditPurchase", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "reserveCallCreditPurchase", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('reserveCallCreditPurchase', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "reserveCallCreditPurchase", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _acquirePaidCallCurrencyExchangeRate(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_acquirePaidCallCurrencyExchangeRate, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = acquirePaidCallCurrencyExchangeRate_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = acquirePaidCallCurrencyExchangeRate_result()
        try:
            result.success = self._handler([ctx, args.language])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "acquirePaidCallCurrencyExchangeRate", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "acquirePaidCallCurrencyExchangeRate", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('acquirePaidCallCurrencyExchangeRate', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "acquirePaidCallCurrencyExchangeRate", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getRoomMemberMidsForAppPlatform(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getRoomMemberMidsForAppPlatform, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getRoomMemberMidsForAppPlatform_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRoomMemberMidsForAppPlatform_result()
        try:
            result.success = self._handler([ctx, args.roomId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getRoomMemberMidsForAppPlatform", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getRoomMemberMidsForAppPlatform", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getRoomMemberMidsForAppPlatform', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getRoomMemberMidsForAppPlatform", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getPaidCallBalanceList(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getPaidCallBalanceList, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getPaidCallBalanceList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getPaidCallBalanceList_result()
        try:
            result.success = self._handler([ctx, args.language])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getPaidCallBalanceList", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getPaidCallBalanceList", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getPaidCallBalanceList', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getPaidCallBalanceList", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getPersonalInfos(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getPersonalInfos, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getPersonalInfos_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getPersonalInfos_result()
        try:
            result.success = self._handler([ctx, args.requiredPersonalInfos])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getPersonalInfos", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getPersonalInfos", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getPersonalInfos', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getPersonalInfos", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getPrimaryClientsForChannel(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getPrimaryClientsForChannel, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getPrimaryClientsForChannel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getPrimaryClientsForChannel_result()
        try:
            result.success = self._handler([ctx, args.userMids])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getPrimaryClientsForChannel", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getPrimaryClientsForChannel", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getPrimaryClientsForChannel', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getPrimaryClientsForChannel", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _addBuddyToContact(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_addBuddyToContact, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = addBuddyToContact_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = addBuddyToContact_result()
        try:
            result.success = self._handler([ctx, args.buddyMid])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "addBuddyToContact", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "addBuddyToContact", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('addBuddyToContact', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "addBuddyToContact", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getGroupMemberMidsForAppPlatform(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getGroupMemberMidsForAppPlatform, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getGroupMemberMidsForAppPlatform_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getGroupMemberMidsForAppPlatform_result()
        try:
            result.success = self._handler([ctx, args.groupId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getGroupMemberMidsForAppPlatform", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getGroupMemberMidsForAppPlatform", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getGroupMemberMidsForAppPlatform', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getGroupMemberMidsForAppPlatform", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getUserLanguage(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getUserLanguage, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getUserLanguage_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getUserLanguage_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getUserLanguage", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getUserLanguage", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getUserLanguage', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getUserLanguage", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _lookupPaidCall(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_lookupPaidCall, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = lookupPaidCall_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = lookupPaidCall_result()
        try:
            result.success = self._handler([ctx, args.dialedNumber, args.language, args.referer])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "lookupPaidCall", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "lookupPaidCall", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('lookupPaidCall', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "lookupPaidCall", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getExtendedProfile(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getExtendedProfile, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getExtendedProfile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getExtendedProfile_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getExtendedProfile", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getExtendedProfile", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getExtendedProfile', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getExtendedProfile", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getReverseCompactContacts(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getReverseCompactContacts, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getReverseCompactContacts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getReverseCompactContacts_result()
        try:
            result.success = self._handler([ctx, args.ids])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getReverseCompactContacts", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getReverseCompactContacts", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getReverseCompactContacts', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getReverseCompactContacts", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getPaidCallAdStatus(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getPaidCallAdStatus, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getPaidCallAdStatus_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getPaidCallAdStatus_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getPaidCallAdStatus", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getPaidCallAdStatus", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getPaidCallAdStatus', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getPaidCallAdStatus", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _findContactByUseridWithoutAbuseBlockForChannel(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_findContactByUseridWithoutAbuseBlockForChannel, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = findContactByUseridWithoutAbuseBlockForChannel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findContactByUseridWithoutAbuseBlockForChannel_result()
        try:
            result.success = self._handler([ctx, args.userid])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "findContactByUseridWithoutAbuseBlockForChannel", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "findContactByUseridWithoutAbuseBlockForChannel", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('findContactByUseridWithoutAbuseBlockForChannel', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "findContactByUseridWithoutAbuseBlockForChannel", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getGroupMemberMids(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getGroupMemberMids, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getGroupMemberMids_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getGroupMemberMids_result()
        try:
            result.success = self._handler([ctx, args.groupId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getGroupMemberMids", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getGroupMemberMids", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getGroupMemberMids', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getGroupMemberMids", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _sendMessageWithoutRelationship(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_sendMessageWithoutRelationship, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = sendMessageWithoutRelationship_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sendMessageWithoutRelationship_result()
        try:
            result.success = self._handler([ctx, args.message])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "sendMessageWithoutRelationship", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "sendMessageWithoutRelationship", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('sendMessageWithoutRelationship', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "sendMessageWithoutRelationship", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _displayBuddySubscriberCountInBulk(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_displayBuddySubscriberCountInBulk, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = displayBuddySubscriberCountInBulk_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = displayBuddySubscriberCountInBulk_result()
        try:
            result.success = self._handler([ctx, args.mids])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "displayBuddySubscriberCountInBulk", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "displayBuddySubscriberCountInBulk", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('displayBuddySubscriberCountInBulk', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "displayBuddySubscriberCountInBulk", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _lookupRoomMembers(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_lookupRoomMembers, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = lookupRoomMembers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = lookupRoomMembers_result()
        try:
            result.success = self._handler([ctx, args.roomId, args.mids])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "lookupRoomMembers", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "lookupRoomMembers", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('lookupRoomMembers', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "lookupRoomMembers", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getFavoriteMidsForChannel(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getFavoriteMidsForChannel, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getFavoriteMidsForChannel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getFavoriteMidsForChannel_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getFavoriteMidsForChannel", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getFavoriteMidsForChannel", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getFavoriteMidsForChannel', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getFavoriteMidsForChannel", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getAllContactIdsForChannel(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getAllContactIdsForChannel, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getAllContactIdsForChannel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAllContactIdsForChannel_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getAllContactIdsForChannel", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getAllContactIdsForChannel", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getAllContactIdsForChannel', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getAllContactIdsForChannel", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _displayBuddySubscriberCount(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_displayBuddySubscriberCount, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = displayBuddySubscriberCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = displayBuddySubscriberCount_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "displayBuddySubscriberCount", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "displayBuddySubscriberCount", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('displayBuddySubscriberCount', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "displayBuddySubscriberCount", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getProfileForChannel(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getProfileForChannel, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getProfileForChannel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getProfileForChannel_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getProfileForChannel", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getProfileForChannel", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getProfileForChannel', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getProfileForChannel", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getUserTickets(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getUserTickets, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getUserTickets_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getUserTickets_result()
        try:
            result.success = self._handler([ctx, args.userMids])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getUserTickets", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getUserTickets", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getUserTickets', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getUserTickets", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getOAFriendMids(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getOAFriendMids, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getOAFriendMids_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getOAFriendMids_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getOAFriendMids", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getOAFriendMids", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getOAFriendMids', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getOAFriendMids", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _searchPaidCallUserRate(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_searchPaidCallUserRate, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = searchPaidCallUserRate_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = searchPaidCallUserRate_result()
        try:
            result.success = self._handler([ctx, args.countryCode, args.language])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "searchPaidCallUserRate", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "searchPaidCallUserRate", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('searchPaidCallUserRate', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "searchPaidCallUserRate", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getJoinedGroupIdsForChannel(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getJoinedGroupIdsForChannel, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getJoinedGroupIdsForChannel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getJoinedGroupIdsForChannel_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getJoinedGroupIdsForChannel", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getJoinedGroupIdsForChannel", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getJoinedGroupIdsForChannel', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getJoinedGroupIdsForChannel", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _acquireGroupCallRoute(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_acquireGroupCallRoute, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = acquireGroupCallRoute_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = acquireGroupCallRoute_result()
        try:
            result.success = self._handler([ctx, args.chatMid, args.mediaType])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "acquireGroupCallRoute", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "acquireGroupCallRoute", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('acquireGroupCallRoute', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "acquireGroupCallRoute", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getUserMidsWhoAddedMe(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getUserMidsWhoAddedMe, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getUserMidsWhoAddedMe_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getUserMidsWhoAddedMe_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getUserMidsWhoAddedMe", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getUserMidsWhoAddedMe", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getUserMidsWhoAddedMe', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getUserMidsWhoAddedMe", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getIdentityCredential(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getIdentityCredential, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getIdentityCredential_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getIdentityCredential_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getIdentityCredential", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getIdentityCredential", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getIdentityCredential', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getIdentityCredential", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _addOperationForChannel(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_addOperationForChannel, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = addOperationForChannel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = addOperationForChannel_result()
        try:
            self._handler([ctx, args.opType, args.param1, args.param2, args.param3])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "addOperationForChannel", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "addOperationForChannel", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('addOperationForChannel', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "addOperationForChannel", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getSimpleChannelContacts(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getSimpleChannelContacts, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getSimpleChannelContacts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getSimpleChannelContacts_result()
        try:
            result.success = self._handler([ctx, args.ids, args.statusSticonFallbackDisabled])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getSimpleChannelContacts", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getSimpleChannelContacts", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getSimpleChannelContacts', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getSimpleChannelContacts", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getUserLastSentMessageTimeStamp(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getUserLastSentMessageTimeStamp, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getUserLastSentMessageTimeStamp_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getUserLastSentMessageTimeStamp_result()
        try:
            result.success = self._handler([ctx, args.mid])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getUserLastSentMessageTimeStamp", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getUserLastSentMessageTimeStamp", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getUserLastSentMessageTimeStamp', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getUserLastSentMessageTimeStamp", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


def _write_application_exception(ctx, oprot, method, ex_code=None, message=None, exception=None):
    if exception is not None:
        x = exception
    else:
        x = TApplicationException(type=ex_code, message=message)
    oprot.write_response_headers(ctx)
    oprot.writeMessageBegin(method, TMessageType.EXCEPTION, 0)
    x.write(oprot)
    oprot.writeMessageEnd()
    oprot.get_transport().flush()
    return x

class getUserStatus_args(object):
    """
    Attributes:
     - mid
    """
    def __init__(self, mid=None):
        self.mid = mid

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.mid = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getUserStatus_args')
        if self.mid is not None:
            oprot.writeFieldBegin('mid', TType.STRING, 1)
            oprot.writeString(self.mid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.mid))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getUserStatus_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = UserStatus(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getUserStatus_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateProfileAttributeForChannel_args(object):
    """
    Attributes:
     - profileAttribute
     - value
    """
    def __init__(self, profileAttribute=None, value=None):
        self.profileAttribute = profileAttribute
        self.value = value

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I32:
                    self.profileAttribute = ProfileAttribute(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateProfileAttributeForChannel_args')
        if self.profileAttribute is not None:
            oprot.writeFieldBegin('profileAttribute', TType.I32, 2)
            oprot.writeI32(self.profileAttribute)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeString(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.profileAttribute))
        value = (value * 31) ^ hash(make_hashable(self.value))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateProfileAttributeForChannel_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateProfileAttributeForChannel_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateExtendedProfileAttribute_args(object):
    """
    Attributes:
     - attr
     - extendedProfile
    """
    def __init__(self, attr=None, extendedProfile=None):
        self.attr = attr
        self.extendedProfile = extendedProfile

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.attr = ExtendedProfileAttribute(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.extendedProfile = ExtendedProfile()
                    self.extendedProfile.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateExtendedProfileAttribute_args')
        if self.attr is not None:
            oprot.writeFieldBegin('attr', TType.I32, 1)
            oprot.writeI32(self.attr)
            oprot.writeFieldEnd()
        if self.extendedProfile is not None:
            oprot.writeFieldBegin('extendedProfile', TType.STRUCT, 2)
            self.extendedProfile.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.attr))
        value = (value * 31) ^ hash(make_hashable(self.extendedProfile))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateExtendedProfileAttribute_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateExtendedProfileAttribute_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getAllSimpleChannelContacts_args(object):
    """
    Attributes:
     - statusSticonFallbackDisabled
    """
    def __init__(self, statusSticonFallbackDisabled=None):
        self.statusSticonFallbackDisabled = statusSticonFallbackDisabled

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.statusSticonFallbackDisabled = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getAllSimpleChannelContacts_args')
        if self.statusSticonFallbackDisabled is not None:
            oprot.writeFieldBegin('statusSticonFallbackDisabled', TType.BOOL, 1)
            oprot.writeBool(self.statusSticonFallbackDisabled)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.statusSticonFallbackDisabled))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getAllSimpleChannelContacts_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem965) = iprot.readListBegin()
                    for _ in range(elem965):
                        elem966 = SimpleChannelContact()
                        elem966.read(iprot)
                        self.success.append(elem966)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getAllSimpleChannelContacts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem967 in self.success:
                elem967.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getUserIdentities_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getUserIdentities_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getUserIdentities_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_, _, elem968) = iprot.readMapBegin()
                    for _ in range(elem968):
                        elem970 = RegistrationType(iprot.readI32())
                        elem969 = iprot.readString()
                        self.success[elem970] = elem969
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getUserIdentities_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I32, TType.STRING, len(self.success))
            for elem972, elem971 in self.success.items():
                oprot.writeI32(elem972)
                oprot.writeString(elem971)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class markPaidCallAd_args(object):
    """
    Attributes:
     - dialedNumber
     - language
     - disableCallerId
    """
    def __init__(self, dialedNumber=None, language=None, disableCallerId=None):
        self.dialedNumber = dialedNumber
        self.language = language
        self.disableCallerId = disableCallerId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.dialedNumber = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.language = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.disableCallerId = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('markPaidCallAd_args')
        if self.dialedNumber is not None:
            oprot.writeFieldBegin('dialedNumber', TType.STRING, 2)
            oprot.writeString(self.dialedNumber)
            oprot.writeFieldEnd()
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 3)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        if self.disableCallerId is not None:
            oprot.writeFieldBegin('disableCallerId', TType.BOOL, 4)
            oprot.writeBool(self.disableCallerId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.dialedNumber))
        value = (value * 31) ^ hash(make_hashable(self.language))
        value = (value * 31) ^ hash(make_hashable(self.disableCallerId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class markPaidCallAd_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PaidCallDialing()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('markPaidCallAd_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class isGroupMember_args(object):
    """
    Attributes:
     - groupId
    """
    def __init__(self, groupId=None):
        self.groupId = groupId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.groupId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('isGroupMember_args')
        if self.groupId is not None:
            oprot.writeFieldBegin('groupId', TType.STRING, 1)
            oprot.writeString(self.groupId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.groupId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class isGroupMember_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('isGroupMember_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getPhoneInfoFromPhoneNumber_args(object):
    """
    Attributes:
     - region
     - phoneNumber
    """
    def __init__(self, region=None, phoneNumber=None):
        self.region = region
        self.phoneNumber = phoneNumber

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.region = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.phoneNumber = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getPhoneInfoFromPhoneNumber_args')
        if self.region is not None:
            oprot.writeFieldBegin('region', TType.STRING, 1)
            oprot.writeString(self.region)
            oprot.writeFieldEnd()
        if self.phoneNumber is not None:
            oprot.writeFieldBegin('phoneNumber', TType.STRING, 2)
            oprot.writeString(self.phoneNumber)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.region))
        value = (value * 31) ^ hash(make_hashable(self.phoneNumber))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getPhoneInfoFromPhoneNumber_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PhoneInfoForChannel()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getPhoneInfoFromPhoneNumber_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class redeemPaidCallVoucher_args(object):
    """
    Attributes:
     - serial
     - language
    """
    def __init__(self, serial=None, language=None):
        self.serial = serial
        self.language = language

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.serial = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.language = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('redeemPaidCallVoucher_args')
        if self.serial is not None:
            oprot.writeFieldBegin('serial', TType.STRING, 2)
            oprot.writeString(self.serial)
            oprot.writeFieldEnd()
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 3)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.serial))
        value = (value * 31) ^ hash(make_hashable(self.language))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class redeemPaidCallVoucher_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PaidCallRedeemResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('redeemPaidCallVoucher_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getPreferredDisplayName_args(object):
    """
    Attributes:
     - mids
    """
    def __init__(self, mids=None):
        self.mids = mids

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.mids = []
                    (_, elem973) = iprot.readListBegin()
                    for _ in range(elem973):
                        elem974 = iprot.readString()
                        self.mids.append(elem974)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getPreferredDisplayName_args')
        if self.mids is not None:
            oprot.writeFieldBegin('mids', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.mids))
            for elem975 in self.mids:
                oprot.writeString(elem975)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.mids))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getPreferredDisplayName_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_, _, elem976) = iprot.readMapBegin()
                    for _ in range(elem976):
                        elem978 = iprot.readString()
                        elem977 = iprot.readString()
                        self.success[elem978] = elem977
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getPreferredDisplayName_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for elem980, elem979 in self.success.items():
                oprot.writeString(elem980)
                oprot.writeString(elem979)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getContactsForChannel_args(object):
    """
    Attributes:
     - ids
    """
    def __init__(self, ids=None):
        self.ids = ids

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.LIST:
                    self.ids = []
                    (_, elem981) = iprot.readListBegin()
                    for _ in range(elem981):
                        elem982 = iprot.readString()
                        self.ids.append(elem982)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getContactsForChannel_args')
        if self.ids is not None:
            oprot.writeFieldBegin('ids', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.ids))
            for elem983 in self.ids:
                oprot.writeString(elem983)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.ids))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getContactsForChannel_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem984) = iprot.readListBegin()
                    for _ in range(elem984):
                        elem985 = Contact()
                        elem985.read(iprot)
                        self.success.append(elem985)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getContactsForChannel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem986 in self.success:
                elem986.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getCallCreditProducts_args(object):
    """
    Attributes:
     - appStoreCode
     - pgCode
     - country
     - language
    """
    def __init__(self, appStoreCode=None, pgCode=None, country=None, language=None):
        self.appStoreCode = appStoreCode
        self.pgCode = pgCode
        self.country = country
        self.language = language

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I32:
                    self.appStoreCode = PaymentType(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.pgCode = PaymentPgType(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.country = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.language = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getCallCreditProducts_args')
        if self.appStoreCode is not None:
            oprot.writeFieldBegin('appStoreCode', TType.I32, 2)
            oprot.writeI32(self.appStoreCode)
            oprot.writeFieldEnd()
        if self.pgCode is not None:
            oprot.writeFieldBegin('pgCode', TType.I32, 3)
            oprot.writeI32(self.pgCode)
            oprot.writeFieldEnd()
        if self.country is not None:
            oprot.writeFieldBegin('country', TType.STRING, 4)
            oprot.writeString(self.country)
            oprot.writeFieldEnd()
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 5)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.appStoreCode))
        value = (value * 31) ^ hash(make_hashable(self.pgCode))
        value = (value * 31) ^ hash(make_hashable(self.country))
        value = (value * 31) ^ hash(make_hashable(self.language))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getCallCreditProducts_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem987) = iprot.readListBegin()
                    for _ in range(elem987):
                        elem988 = CoinProductItem()
                        elem988.read(iprot)
                        self.success.append(elem988)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getCallCreditProducts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem989 in self.success:
                elem989.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getCompactContacts_args(object):
    """
    Attributes:
     - lastModifiedTimestamp
    """
    def __init__(self, lastModifiedTimestamp=None):
        self.lastModifiedTimestamp = lastModifiedTimestamp

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I64:
                    self.lastModifiedTimestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getCompactContacts_args')
        if self.lastModifiedTimestamp is not None:
            oprot.writeFieldBegin('lastModifiedTimestamp', TType.I64, 2)
            oprot.writeI64(self.lastModifiedTimestamp)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.lastModifiedTimestamp))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getCompactContacts_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem990) = iprot.readListBegin()
                    for _ in range(elem990):
                        elem991 = CompactContact()
                        elem991.read(iprot)
                        self.success.append(elem991)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getCompactContacts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem992 in self.success:
                elem992.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class notifyNotiCenterEvent_args(object):
    """
    Attributes:
     - event
    """
    def __init__(self, event=None):
        self.event = event

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.event = NotiCenterEventData()
                    self.event.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('notifyNotiCenterEvent_args')
        if self.event is not None:
            oprot.writeFieldBegin('event', TType.STRUCT, 1)
            self.event.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.event))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class notifyNotiCenterEvent_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('notifyNotiCenterEvent_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class isInContact_args(object):
    """
    Attributes:
     - mid
    """
    def __init__(self, mid=None):
        self.mid = mid

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.mid = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('isInContact_args')
        if self.mid is not None:
            oprot.writeFieldBegin('mid', TType.STRING, 2)
            oprot.writeString(self.mid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.mid))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class isInContact_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('isInContact_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class lookupGroupMembers_args(object):
    """
    Attributes:
     - groupId
     - mids
    """
    def __init__(self, groupId=None, mids=None):
        self.groupId = groupId
        self.mids = mids

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.groupId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.mids = []
                    (_, elem993) = iprot.readListBegin()
                    for _ in range(elem993):
                        elem994 = iprot.readString()
                        self.mids.append(elem994)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('lookupGroupMembers_args')
        if self.groupId is not None:
            oprot.writeFieldBegin('groupId', TType.STRING, 1)
            oprot.writeString(self.groupId)
            oprot.writeFieldEnd()
        if self.mids is not None:
            oprot.writeFieldBegin('mids', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.mids))
            for elem995 in self.mids:
                oprot.writeString(elem995)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.groupId))
        value = (value * 31) ^ hash(make_hashable(self.mids))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class lookupGroupMembers_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem996) = iprot.readListBegin()
                    for _ in range(elem996):
                        elem997 = SimpleChannelContact()
                        elem997.read(iprot)
                        self.success.append(elem997)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('lookupGroupMembers_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem998 in self.success:
                elem998.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getRoomInformation_args(object):
    """
    Attributes:
     - roomMid
    """
    def __init__(self, roomMid=None):
        self.roomMid = roomMid

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.roomMid = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getRoomInformation_args')
        if self.roomMid is not None:
            oprot.writeFieldBegin('roomMid', TType.STRING, 1)
            oprot.writeString(self.roomMid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.roomMid))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getRoomInformation_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Room()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getRoomInformation_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getGroupCall_args(object):
    """
    Attributes:
     - chatMid
    """
    def __init__(self, chatMid=None):
        self.chatMid = chatMid

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.chatMid = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getGroupCall_args')
        if self.chatMid is not None:
            oprot.writeFieldBegin('chatMid', TType.STRING, 2)
            oprot.writeString(self.chatMid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.chatMid))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getGroupCall_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GroupCall()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getGroupCall_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class isAllowSecondaryDeviceLogin_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('isAllowSecondaryDeviceLogin_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class isAllowSecondaryDeviceLogin_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('isAllowSecondaryDeviceLogin_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getPrimaryClientForChannel_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getPrimaryClientForChannel_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getPrimaryClientForChannel_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = SimpleChannelClient()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getPrimaryClientForChannel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class createRoomWithBuddy_args(object):
    """
    Attributes:
     - reqSeq
     - buddyMid
     - contactIds
    """
    def __init__(self, reqSeq=None, buddyMid=None, contactIds=None):
        self.reqSeq = reqSeq
        self.buddyMid = buddyMid
        self.contactIds = contactIds

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.buddyMid = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.contactIds = []
                    (_, elem999) = iprot.readListBegin()
                    for _ in range(elem999):
                        elem1000 = iprot.readString()
                        self.contactIds.append(elem1000)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('createRoomWithBuddy_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.buddyMid is not None:
            oprot.writeFieldBegin('buddyMid', TType.STRING, 2)
            oprot.writeString(self.buddyMid)
            oprot.writeFieldEnd()
        if self.contactIds is not None:
            oprot.writeFieldBegin('contactIds', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.contactIds))
            for elem1001 in self.contactIds:
                oprot.writeString(elem1001)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.buddyMid))
        value = (value * 31) ^ hash(make_hashable(self.contactIds))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class createRoomWithBuddy_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Room()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('createRoomWithBuddy_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getDisplayName_args(object):
    """
    Attributes:
     - mid
    """
    def __init__(self, mid=None):
        self.mid = mid

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.mid = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getDisplayName_args')
        if self.mid is not None:
            oprot.writeFieldBegin('mid', TType.STRING, 2)
            oprot.writeString(self.mid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.mid))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getDisplayName_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getDisplayName_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getPaidCallMetadata_args(object):
    """
    Attributes:
     - language
    """
    def __init__(self, language=None):
        self.language = language

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.language = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getPaidCallMetadata_args')
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 2)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.language))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getPaidCallMetadata_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PaidCallMetadataResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getPaidCallMetadata_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getMid_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getMid_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getMid_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getMid_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getUserCountryForBilling_args(object):
    """
    Attributes:
     - country
     - remoteIp
    """
    def __init__(self, country=None, remoteIp=None):
        self.country = country
        self.remoteIp = remoteIp

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.country = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.remoteIp = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getUserCountryForBilling_args')
        if self.country is not None:
            oprot.writeFieldBegin('country', TType.STRING, 2)
            oprot.writeString(self.country)
            oprot.writeFieldEnd()
        if self.remoteIp is not None:
            oprot.writeFieldBegin('remoteIp', TType.STRING, 3)
            oprot.writeString(self.remoteIp)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.country))
        value = (value * 31) ^ hash(make_hashable(self.remoteIp))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getUserCountryForBilling_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getUserCountryForBilling_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getFavoriteGroupIdsForChannel_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getFavoriteGroupIdsForChannel_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getFavoriteGroupIdsForChannel_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem1002) = iprot.readListBegin()
                    for _ in range(elem1002):
                        elem1003 = iprot.readString()
                        self.success.append(elem1003)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getFavoriteGroupIdsForChannel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for elem1004 in self.success:
                oprot.writeString(elem1004)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getPaidCallHistory_args(object):
    """
    Attributes:
     - start
     - size
     - language
    """
    def __init__(self, start=None, size=None, language=None):
        self.start = start
        self.size = size
        self.language = language

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I64:
                    self.start = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.language = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getPaidCallHistory_args')
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I64, 2)
            oprot.writeI64(self.start)
            oprot.writeFieldEnd()
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.I32, 3)
            oprot.writeI32(self.size)
            oprot.writeFieldEnd()
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 4)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.start))
        value = (value * 31) ^ hash(make_hashable(self.size))
        value = (value * 31) ^ hash(make_hashable(self.language))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getPaidCallHistory_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PaidCallHistoryResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getPaidCallHistory_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sendPinCodeOperation_args(object):
    """
    Attributes:
     - verifier
    """
    def __init__(self, verifier=None):
        self.verifier = verifier

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.verifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sendPinCodeOperation_args')
        if self.verifier is not None:
            oprot.writeFieldBegin('verifier', TType.STRING, 1)
            oprot.writeString(self.verifier)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.verifier))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sendPinCodeOperation_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sendPinCodeOperation_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class inviteIntoGroupCall_args(object):
    """
    Attributes:
     - chatMid
     - memberMids
     - mediaType
    """
    def __init__(self, chatMid=None, memberMids=None, mediaType=None):
        self.chatMid = chatMid
        self.memberMids = memberMids
        self.mediaType = mediaType

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.chatMid = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.memberMids = []
                    (_, elem1005) = iprot.readListBegin()
                    for _ in range(elem1005):
                        elem1006 = iprot.readString()
                        self.memberMids.append(elem1006)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.mediaType = GroupCallMediaType(iprot.readI32())
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('inviteIntoGroupCall_args')
        if self.chatMid is not None:
            oprot.writeFieldBegin('chatMid', TType.STRING, 2)
            oprot.writeString(self.chatMid)
            oprot.writeFieldEnd()
        if self.memberMids is not None:
            oprot.writeFieldBegin('memberMids', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.memberMids))
            for elem1007 in self.memberMids:
                oprot.writeString(elem1007)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.mediaType is not None:
            oprot.writeFieldBegin('mediaType', TType.I32, 4)
            oprot.writeI32(self.mediaType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.chatMid))
        value = (value * 31) ^ hash(make_hashable(self.memberMids))
        value = (value * 31) ^ hash(make_hashable(self.mediaType))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class inviteIntoGroupCall_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('inviteIntoGroupCall_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getFriendMids_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getFriendMids_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getFriendMids_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem1008) = iprot.readListBegin()
                    for _ in range(elem1008):
                        elem1009 = iprot.readString()
                        self.success.append(elem1009)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getFriendMids_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for elem1010 in self.success:
                oprot.writeString(elem1010)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getMetaProfile_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getMetaProfile_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getMetaProfile_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MetaProfile()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getMetaProfile_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sendMessageForChannel_args(object):
    """
    Attributes:
     - message
    """
    def __init__(self, message=None):
        self.message = message

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.message = Message()
                    self.message.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sendMessageForChannel_args')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRUCT, 2)
            self.message.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.message))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sendMessageForChannel_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Message()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sendMessageForChannel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class activeBuddySubscriberCount_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('activeBuddySubscriberCount_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class activeBuddySubscriberCount_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('activeBuddySubscriberCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getCallCreditPurchaseHistory_args(object):
    """
    Attributes:
     - request
    """
    def __init__(self, request=None):
        self.request = request

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.request = CoinHistoryCondition()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getCallCreditPurchaseHistory_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 2)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.request))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getCallCreditPurchaseHistory_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CoinHistoryResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getCallCreditPurchaseHistory_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class isRoomMember_args(object):
    """
    Attributes:
     - roomId
    """
    def __init__(self, roomId=None):
        self.roomId = roomId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.roomId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('isRoomMember_args')
        if self.roomId is not None:
            oprot.writeFieldBegin('roomId', TType.STRING, 1)
            oprot.writeString(self.roomId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.roomId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class isRoomMember_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('isRoomMember_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sendSystemOAMessage_args(object):
    """
    Attributes:
     - message
    """
    def __init__(self, message=None):
        self.message = message

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.message = Message()
                    self.message.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sendSystemOAMessage_args')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRUCT, 1)
            self.message.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.message))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sendSystemOAMessage_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Message()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sendSystemOAMessage_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class acquirePaidCallRoute_args(object):
    """
    Attributes:
     - paidCallType
     - dialedNumber
     - language
     - networkCode
     - disableCallerId
     - referer
     - adSessionId
    """
    def __init__(self, paidCallType=None, dialedNumber=None, language=None, networkCode=None, disableCallerId=None, referer=None, adSessionId=None):
        self.paidCallType = paidCallType
        self.dialedNumber = dialedNumber
        self.language = language
        self.networkCode = networkCode
        self.disableCallerId = disableCallerId
        self.referer = referer
        self.adSessionId = adSessionId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I32:
                    self.paidCallType = PaidCallType(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.dialedNumber = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.language = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.networkCode = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.disableCallerId = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.referer = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.adSessionId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('acquirePaidCallRoute_args')
        if self.paidCallType is not None:
            oprot.writeFieldBegin('paidCallType', TType.I32, 2)
            oprot.writeI32(self.paidCallType)
            oprot.writeFieldEnd()
        if self.dialedNumber is not None:
            oprot.writeFieldBegin('dialedNumber', TType.STRING, 3)
            oprot.writeString(self.dialedNumber)
            oprot.writeFieldEnd()
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 4)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        if self.networkCode is not None:
            oprot.writeFieldBegin('networkCode', TType.STRING, 5)
            oprot.writeString(self.networkCode)
            oprot.writeFieldEnd()
        if self.disableCallerId is not None:
            oprot.writeFieldBegin('disableCallerId', TType.BOOL, 6)
            oprot.writeBool(self.disableCallerId)
            oprot.writeFieldEnd()
        if self.referer is not None:
            oprot.writeFieldBegin('referer', TType.STRING, 7)
            oprot.writeString(self.referer)
            oprot.writeFieldEnd()
        if self.adSessionId is not None:
            oprot.writeFieldBegin('adSessionId', TType.STRING, 8)
            oprot.writeString(self.adSessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.paidCallType))
        value = (value * 31) ^ hash(make_hashable(self.dialedNumber))
        value = (value * 31) ^ hash(make_hashable(self.language))
        value = (value * 31) ^ hash(make_hashable(self.networkCode))
        value = (value * 31) ^ hash(make_hashable(self.disableCallerId))
        value = (value * 31) ^ hash(make_hashable(self.referer))
        value = (value * 31) ^ hash(make_hashable(self.adSessionId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class acquirePaidCallRoute_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PaidCallResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('acquirePaidCallRoute_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getGroupsForChannel_args(object):
    """
    Attributes:
     - groupIds
    """
    def __init__(self, groupIds=None):
        self.groupIds = groupIds

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.groupIds = []
                    (_, elem1011) = iprot.readListBegin()
                    for _ in range(elem1011):
                        elem1012 = iprot.readString()
                        self.groupIds.append(elem1012)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getGroupsForChannel_args')
        if self.groupIds is not None:
            oprot.writeFieldBegin('groupIds', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.groupIds))
            for elem1013 in self.groupIds:
                oprot.writeString(elem1013)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.groupIds))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getGroupsForChannel_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem1014) = iprot.readListBegin()
                    for _ in range(elem1014):
                        elem1015 = Group()
                        elem1015.read(iprot)
                        self.success.append(elem1015)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getGroupsForChannel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem1016 in self.success:
                elem1016.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getUserCreateTime_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getUserCreateTime_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getUserCreateTime_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getUserCreateTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerChannelCP_args(object):
    """
    Attributes:
     - cpId
     - registerPassword
    """
    def __init__(self, cpId=None, registerPassword=None):
        self.cpId = cpId
        self.registerPassword = registerPassword

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.cpId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.registerPassword = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerChannelCP_args')
        if self.cpId is not None:
            oprot.writeFieldBegin('cpId', TType.STRING, 2)
            oprot.writeString(self.cpId)
            oprot.writeFieldEnd()
        if self.registerPassword is not None:
            oprot.writeFieldBegin('registerPassword', TType.STRING, 3)
            oprot.writeString(self.registerPassword)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.cpId))
        value = (value * 31) ^ hash(make_hashable(self.registerPassword))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerChannelCP_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerChannelCP_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class reserveCallCreditPurchase_args(object):
    """
    Attributes:
     - request
    """
    def __init__(self, request=None):
        self.request = request

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.request = CoinPurchaseReservation()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('reserveCallCreditPurchase_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 2)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.request))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class reserveCallCreditPurchase_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PaymentReservationResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('reserveCallCreditPurchase_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class acquirePaidCallCurrencyExchangeRate_args(object):
    """
    Attributes:
     - language
    """
    def __init__(self, language=None):
        self.language = language

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.language = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('acquirePaidCallCurrencyExchangeRate_args')
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 2)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.language))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class acquirePaidCallCurrencyExchangeRate_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem1017) = iprot.readListBegin()
                    for _ in range(elem1017):
                        elem1018 = PaidCallCurrencyExchangeRate()
                        elem1018.read(iprot)
                        self.success.append(elem1018)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('acquirePaidCallCurrencyExchangeRate_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem1019 in self.success:
                elem1019.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getRoomMemberMidsForAppPlatform_args(object):
    """
    Attributes:
     - roomId
    """
    def __init__(self, roomId=None):
        self.roomId = roomId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.roomId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getRoomMemberMidsForAppPlatform_args')
        if self.roomId is not None:
            oprot.writeFieldBegin('roomId', TType.STRING, 1)
            oprot.writeString(self.roomId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.roomId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getRoomMemberMidsForAppPlatform_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem1020) = iprot.readListBegin()
                    for _ in range(elem1020):
                        elem1021 = iprot.readString()
                        self.success.append(elem1021)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getRoomMemberMidsForAppPlatform_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for elem1022 in self.success:
                oprot.writeString(elem1022)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getPaidCallBalanceList_args(object):
    """
    Attributes:
     - language
    """
    def __init__(self, language=None):
        self.language = language

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.language = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getPaidCallBalanceList_args')
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 2)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.language))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getPaidCallBalanceList_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem1023) = iprot.readListBegin()
                    for _ in range(elem1023):
                        elem1024 = PaidCallBalance()
                        elem1024.read(iprot)
                        self.success.append(elem1024)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getPaidCallBalanceList_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem1025 in self.success:
                elem1025.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getPersonalInfos_args(object):
    """
    Attributes:
     - requiredPersonalInfos
    """
    def __init__(self, requiredPersonalInfos=None):
        self.requiredPersonalInfos = requiredPersonalInfos

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.SET:
                    self.requiredPersonalInfos = set()
                    (_, elem1026) = iprot.readSetBegin()
                    for _ in range(elem1026):
                        elem1027 = PersonalInfo(iprot.readI32())
                        self.requiredPersonalInfos.add(elem1027)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getPersonalInfos_args')
        if self.requiredPersonalInfos is not None:
            oprot.writeFieldBegin('requiredPersonalInfos', TType.SET, 1)
            oprot.writeSetBegin(TType.I32, len(self.requiredPersonalInfos))
            for elem1028 in self.requiredPersonalInfos:
                oprot.writeI32(elem1028)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.requiredPersonalInfos))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getPersonalInfos_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_, _, elem1029) = iprot.readMapBegin()
                    for _ in range(elem1029):
                        elem1031 = PersonalInfo(iprot.readI32())
                        elem1030 = iprot.readString()
                        self.success[elem1031] = elem1030
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getPersonalInfos_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I32, TType.STRING, len(self.success))
            for elem1033, elem1032 in self.success.items():
                oprot.writeI32(elem1033)
                oprot.writeString(elem1032)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getPrimaryClientsForChannel_args(object):
    """
    Attributes:
     - userMids
    """
    def __init__(self, userMids=None):
        self.userMids = userMids

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.userMids = []
                    (_, elem1034) = iprot.readListBegin()
                    for _ in range(elem1034):
                        elem1035 = iprot.readString()
                        self.userMids.append(elem1035)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getPrimaryClientsForChannel_args')
        if self.userMids is not None:
            oprot.writeFieldBegin('userMids', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.userMids))
            for elem1036 in self.userMids:
                oprot.writeString(elem1036)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.userMids))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getPrimaryClientsForChannel_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem1037) = iprot.readListBegin()
                    for _ in range(elem1037):
                        elem1038 = SimpleChannelClient()
                        elem1038.read(iprot)
                        self.success.append(elem1038)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getPrimaryClientsForChannel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem1039 in self.success:
                elem1039.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class addBuddyToContact_args(object):
    """
    Attributes:
     - buddyMid
    """
    def __init__(self, buddyMid=None):
        self.buddyMid = buddyMid

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.buddyMid = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('addBuddyToContact_args')
        if self.buddyMid is not None:
            oprot.writeFieldBegin('buddyMid', TType.STRING, 1)
            oprot.writeString(self.buddyMid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.buddyMid))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class addBuddyToContact_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ContactTransition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('addBuddyToContact_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getGroupMemberMidsForAppPlatform_args(object):
    """
    Attributes:
     - groupId
    """
    def __init__(self, groupId=None):
        self.groupId = groupId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.groupId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getGroupMemberMidsForAppPlatform_args')
        if self.groupId is not None:
            oprot.writeFieldBegin('groupId', TType.STRING, 1)
            oprot.writeString(self.groupId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.groupId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getGroupMemberMidsForAppPlatform_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem1040) = iprot.readListBegin()
                    for _ in range(elem1040):
                        elem1041 = iprot.readString()
                        self.success.append(elem1041)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getGroupMemberMidsForAppPlatform_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for elem1042 in self.success:
                oprot.writeString(elem1042)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getUserLanguage_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getUserLanguage_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getUserLanguage_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getUserLanguage_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class lookupPaidCall_args(object):
    """
    Attributes:
     - dialedNumber
     - language
     - referer
    """
    def __init__(self, dialedNumber=None, language=None, referer=None):
        self.dialedNumber = dialedNumber
        self.language = language
        self.referer = referer

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.dialedNumber = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.language = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.referer = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('lookupPaidCall_args')
        if self.dialedNumber is not None:
            oprot.writeFieldBegin('dialedNumber', TType.STRING, 2)
            oprot.writeString(self.dialedNumber)
            oprot.writeFieldEnd()
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 3)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        if self.referer is not None:
            oprot.writeFieldBegin('referer', TType.STRING, 4)
            oprot.writeString(self.referer)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.dialedNumber))
        value = (value * 31) ^ hash(make_hashable(self.language))
        value = (value * 31) ^ hash(make_hashable(self.referer))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class lookupPaidCall_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PaidCallResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('lookupPaidCall_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getExtendedProfile_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getExtendedProfile_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getExtendedProfile_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ExtendedProfile()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getExtendedProfile_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getReverseCompactContacts_args(object):
    """
    Attributes:
     - ids
    """
    def __init__(self, ids=None):
        self.ids = ids

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.ids = []
                    (_, elem1043) = iprot.readListBegin()
                    for _ in range(elem1043):
                        elem1044 = iprot.readString()
                        self.ids.append(elem1044)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getReverseCompactContacts_args')
        if self.ids is not None:
            oprot.writeFieldBegin('ids', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.ids))
            for elem1045 in self.ids:
                oprot.writeString(elem1045)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.ids))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getReverseCompactContacts_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_, _, elem1046) = iprot.readMapBegin()
                    for _ in range(elem1046):
                        elem1048 = iprot.readString()
                        elem1047 = CompactContact()
                        elem1047.read(iprot)
                        self.success[elem1048] = elem1047
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getReverseCompactContacts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for elem1050, elem1049 in self.success.items():
                oprot.writeString(elem1050)
                elem1049.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getPaidCallAdStatus_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getPaidCallAdStatus_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getPaidCallAdStatus_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PaidCallAdResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getPaidCallAdStatus_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class findContactByUseridWithoutAbuseBlockForChannel_args(object):
    """
    Attributes:
     - userid
    """
    def __init__(self, userid=None):
        self.userid = userid

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.userid = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('findContactByUseridWithoutAbuseBlockForChannel_args')
        if self.userid is not None:
            oprot.writeFieldBegin('userid', TType.STRING, 2)
            oprot.writeString(self.userid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.userid))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class findContactByUseridWithoutAbuseBlockForChannel_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Contact()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('findContactByUseridWithoutAbuseBlockForChannel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getGroupMemberMids_args(object):
    """
    Attributes:
     - groupId
    """
    def __init__(self, groupId=None):
        self.groupId = groupId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.groupId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getGroupMemberMids_args')
        if self.groupId is not None:
            oprot.writeFieldBegin('groupId', TType.STRING, 1)
            oprot.writeString(self.groupId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.groupId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getGroupMemberMids_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem1051) = iprot.readListBegin()
                    for _ in range(elem1051):
                        elem1052 = iprot.readString()
                        self.success.append(elem1052)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getGroupMemberMids_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for elem1053 in self.success:
                oprot.writeString(elem1053)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sendMessageWithoutRelationship_args(object):
    """
    Attributes:
     - message
    """
    def __init__(self, message=None):
        self.message = message

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.message = Message()
                    self.message.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sendMessageWithoutRelationship_args')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRUCT, 2)
            self.message.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.message))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sendMessageWithoutRelationship_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Message()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sendMessageWithoutRelationship_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class displayBuddySubscriberCountInBulk_args(object):
    """
    Attributes:
     - mids
    """
    def __init__(self, mids=None):
        self.mids = mids

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.mids = []
                    (_, elem1054) = iprot.readListBegin()
                    for _ in range(elem1054):
                        elem1055 = iprot.readString()
                        self.mids.append(elem1055)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('displayBuddySubscriberCountInBulk_args')
        if self.mids is not None:
            oprot.writeFieldBegin('mids', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.mids))
            for elem1056 in self.mids:
                oprot.writeString(elem1056)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.mids))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class displayBuddySubscriberCountInBulk_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_, _, elem1057) = iprot.readMapBegin()
                    for _ in range(elem1057):
                        elem1059 = iprot.readString()
                        elem1058 = iprot.readI64()
                        self.success[elem1059] = elem1058
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('displayBuddySubscriberCountInBulk_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.I64, len(self.success))
            for elem1061, elem1060 in self.success.items():
                oprot.writeString(elem1061)
                oprot.writeI64(elem1060)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class lookupRoomMembers_args(object):
    """
    Attributes:
     - roomId
     - mids
    """
    def __init__(self, roomId=None, mids=None):
        self.roomId = roomId
        self.mids = mids

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.roomId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.mids = []
                    (_, elem1062) = iprot.readListBegin()
                    for _ in range(elem1062):
                        elem1063 = iprot.readString()
                        self.mids.append(elem1063)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('lookupRoomMembers_args')
        if self.roomId is not None:
            oprot.writeFieldBegin('roomId', TType.STRING, 1)
            oprot.writeString(self.roomId)
            oprot.writeFieldEnd()
        if self.mids is not None:
            oprot.writeFieldBegin('mids', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.mids))
            for elem1064 in self.mids:
                oprot.writeString(elem1064)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.roomId))
        value = (value * 31) ^ hash(make_hashable(self.mids))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class lookupRoomMembers_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem1065) = iprot.readListBegin()
                    for _ in range(elem1065):
                        elem1066 = SimpleChannelContact()
                        elem1066.read(iprot)
                        self.success.append(elem1066)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('lookupRoomMembers_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem1067 in self.success:
                elem1067.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getFavoriteMidsForChannel_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getFavoriteMidsForChannel_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getFavoriteMidsForChannel_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem1068) = iprot.readListBegin()
                    for _ in range(elem1068):
                        elem1069 = iprot.readString()
                        self.success.append(elem1069)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getFavoriteMidsForChannel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for elem1070 in self.success:
                oprot.writeString(elem1070)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getAllContactIdsForChannel_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getAllContactIdsForChannel_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getAllContactIdsForChannel_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem1071) = iprot.readListBegin()
                    for _ in range(elem1071):
                        elem1072 = iprot.readString()
                        self.success.append(elem1072)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getAllContactIdsForChannel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for elem1073 in self.success:
                oprot.writeString(elem1073)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class displayBuddySubscriberCount_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('displayBuddySubscriberCount_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class displayBuddySubscriberCount_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('displayBuddySubscriberCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getProfileForChannel_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getProfileForChannel_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getProfileForChannel_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Profile()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getProfileForChannel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getUserTickets_args(object):
    """
    Attributes:
     - userMids
    """
    def __init__(self, userMids=None):
        self.userMids = userMids

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.userMids = []
                    (_, elem1074) = iprot.readListBegin()
                    for _ in range(elem1074):
                        elem1075 = iprot.readString()
                        self.userMids.append(elem1075)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getUserTickets_args')
        if self.userMids is not None:
            oprot.writeFieldBegin('userMids', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.userMids))
            for elem1076 in self.userMids:
                oprot.writeString(elem1076)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.userMids))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getUserTickets_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem1077) = iprot.readListBegin()
                    for _ in range(elem1077):
                        elem1078 = UserTicketResponse()
                        elem1078.read(iprot)
                        self.success.append(elem1078)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getUserTickets_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem1079 in self.success:
                elem1079.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getOAFriendMids_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getOAFriendMids_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getOAFriendMids_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem1080) = iprot.readListBegin()
                    for _ in range(elem1080):
                        elem1081 = iprot.readString()
                        self.success.append(elem1081)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getOAFriendMids_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for elem1082 in self.success:
                oprot.writeString(elem1082)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class searchPaidCallUserRate_args(object):
    """
    Attributes:
     - countryCode
     - language
    """
    def __init__(self, countryCode=None, language=None):
        self.countryCode = countryCode
        self.language = language

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.countryCode = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.language = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('searchPaidCallUserRate_args')
        if self.countryCode is not None:
            oprot.writeFieldBegin('countryCode', TType.STRING, 2)
            oprot.writeString(self.countryCode)
            oprot.writeFieldEnd()
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 3)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.countryCode))
        value = (value * 31) ^ hash(make_hashable(self.language))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class searchPaidCallUserRate_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem1083) = iprot.readListBegin()
                    for _ in range(elem1083):
                        elem1084 = PaidCallUserRate()
                        elem1084.read(iprot)
                        self.success.append(elem1084)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('searchPaidCallUserRate_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem1085 in self.success:
                elem1085.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getJoinedGroupIdsForChannel_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getJoinedGroupIdsForChannel_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getJoinedGroupIdsForChannel_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem1086) = iprot.readListBegin()
                    for _ in range(elem1086):
                        elem1087 = iprot.readString()
                        self.success.append(elem1087)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getJoinedGroupIdsForChannel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for elem1088 in self.success:
                oprot.writeString(elem1088)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class acquireGroupCallRoute_args(object):
    """
    Attributes:
     - chatMid
     - mediaType
    """
    def __init__(self, chatMid=None, mediaType=None):
        self.chatMid = chatMid
        self.mediaType = mediaType

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.chatMid = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.mediaType = GroupCallMediaType(iprot.readI32())
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('acquireGroupCallRoute_args')
        if self.chatMid is not None:
            oprot.writeFieldBegin('chatMid', TType.STRING, 2)
            oprot.writeString(self.chatMid)
            oprot.writeFieldEnd()
        if self.mediaType is not None:
            oprot.writeFieldBegin('mediaType', TType.I32, 3)
            oprot.writeI32(self.mediaType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.chatMid))
        value = (value * 31) ^ hash(make_hashable(self.mediaType))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class acquireGroupCallRoute_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GroupCallRoute()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('acquireGroupCallRoute_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getUserMidsWhoAddedMe_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getUserMidsWhoAddedMe_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getUserMidsWhoAddedMe_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem1089) = iprot.readListBegin()
                    for _ in range(elem1089):
                        elem1090 = iprot.readString()
                        self.success.append(elem1090)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getUserMidsWhoAddedMe_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for elem1091 in self.success:
                oprot.writeString(elem1091)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getIdentityCredential_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getIdentityCredential_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getIdentityCredential_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = IdentityCredential()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getIdentityCredential_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class addOperationForChannel_args(object):
    """
    Attributes:
     - opType
     - param1
     - param2
     - param3
    """
    def __init__(self, opType=None, param1=None, param2=None, param3=None):
        self.opType = opType
        self.param1 = param1
        self.param2 = param2
        self.param3 = param3

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.opType = OpType(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.param1 = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.param2 = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.param3 = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('addOperationForChannel_args')
        if self.opType is not None:
            oprot.writeFieldBegin('opType', TType.I32, 1)
            oprot.writeI32(self.opType)
            oprot.writeFieldEnd()
        if self.param1 is not None:
            oprot.writeFieldBegin('param1', TType.STRING, 2)
            oprot.writeString(self.param1)
            oprot.writeFieldEnd()
        if self.param2 is not None:
            oprot.writeFieldBegin('param2', TType.STRING, 3)
            oprot.writeString(self.param2)
            oprot.writeFieldEnd()
        if self.param3 is not None:
            oprot.writeFieldBegin('param3', TType.STRING, 4)
            oprot.writeString(self.param3)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.opType))
        value = (value * 31) ^ hash(make_hashable(self.param1))
        value = (value * 31) ^ hash(make_hashable(self.param2))
        value = (value * 31) ^ hash(make_hashable(self.param3))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class addOperationForChannel_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('addOperationForChannel_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getSimpleChannelContacts_args(object):
    """
    Attributes:
     - ids
     - statusSticonFallbackDisabled
    """
    def __init__(self, ids=None, statusSticonFallbackDisabled=None):
        self.ids = ids
        self.statusSticonFallbackDisabled = statusSticonFallbackDisabled

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.ids = []
                    (_, elem1092) = iprot.readListBegin()
                    for _ in range(elem1092):
                        elem1093 = iprot.readString()
                        self.ids.append(elem1093)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.statusSticonFallbackDisabled = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getSimpleChannelContacts_args')
        if self.ids is not None:
            oprot.writeFieldBegin('ids', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.ids))
            for elem1094 in self.ids:
                oprot.writeString(elem1094)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.statusSticonFallbackDisabled is not None:
            oprot.writeFieldBegin('statusSticonFallbackDisabled', TType.BOOL, 2)
            oprot.writeBool(self.statusSticonFallbackDisabled)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.ids))
        value = (value * 31) ^ hash(make_hashable(self.statusSticonFallbackDisabled))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getSimpleChannelContacts_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem1095) = iprot.readListBegin()
                    for _ in range(elem1095):
                        elem1096 = SimpleChannelContact()
                        elem1096.read(iprot)
                        self.success.append(elem1096)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getSimpleChannelContacts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem1097 in self.success:
                elem1097.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getUserLastSentMessageTimeStamp_args(object):
    """
    Attributes:
     - mid
    """
    def __init__(self, mid=None):
        self.mid = mid

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.mid = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getUserLastSentMessageTimeStamp_args')
        if self.mid is not None:
            oprot.writeFieldBegin('mid', TType.STRING, 1)
            oprot.writeString(self.mid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.mid))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getUserLastSentMessageTimeStamp_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getUserLastSentMessageTimeStamp_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

