#
# Autogenerated by Frugal Compiler (3.7.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#



from threading import Lock

from frugal.middleware import Method
from frugal.exceptions import TApplicationExceptionType
from frugal.exceptions import TTransportExceptionType
from frugal.processor import FBaseProcessor
from frugal.processor import FProcessorFunction
from frugal.util.deprecate import deprecated
from frugal.util import make_hashable
from thrift.Thrift import TApplicationException
from thrift.Thrift import TMessageType
from thrift.transport.TTransport import TTransportException

from .ttypes import *


class Iface(object):

    def getChatRoomAnnouncementsBulk(self, ctx, chatRoomMids):
        """
        Args:
            ctx: FContext
            chatRoomMids: list of string
        """
        pass

    def getChatRoomAnnouncements(self, ctx, chatRoomMid):
        """
        Args:
            ctx: FContext
            chatRoomMid: string
        """
        pass

    def createChatRoomAnnouncement(self, ctx, reqSeq, chatRoomMid, type, contents):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            chatRoomMid: string
            type: ChatRoomAnnouncementType
            contents: ChatRoomAnnouncementContents
        """
        pass

    def removeChatRoomAnnouncement(self, ctx, reqSeq, chatRoomMid, announcementSeq):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            chatRoomMid: string
            announcementSeq: int (signed 64 bits)
        """
        pass

    def unsendMessage(self, ctx, seq, messageId):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            messageId: string
        """
        pass

    def getGroupWithoutMembers(self, ctx, groupId):
        """
        Args:
            ctx: FContext
            groupId: string
        """
        pass

    def requestResendMessage(self, ctx, reqSeq, senderMid, messageId):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            senderMid: string
            messageId: string
        """
        pass

    def respondResendMessage(self, ctx, reqSeq, receiverMid, originalMessageId, resendMessage, errorCode):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            receiverMid: string
            originalMessageId: string
            resendMessage: Message
            errorCode: ErrorCode
        """
        pass

    def acceptGroupInvitation(self, ctx, reqSeq, groupId):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            groupId: string
        """
        pass

    def acceptGroupInvitationByTicket(self, ctx, reqSeq, GroupMid, ticketId):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            GroupMid: string
            ticketId: string
        """
        pass

    def acceptProximityMatches(self, ctx, sessionId, ids):
        """
        Args:
            ctx: FContext
            sessionId: string
            ids: set of string
        """
        pass

    def acquireCallRoute(self, ctx, to):
        """
        Args:
            ctx: FContext
            to: string
        """
        pass

    def acquireCallTicket(self, ctx, to):
        """
        Args:
            ctx: FContext
            to: string
        """
        pass

    def acquireEncryptedAccessToken(self, ctx, featureType):
        """
        Args:
            ctx: FContext
            featureType: FeatureType
        """
        pass

    def addSnsId(self, ctx, snsIdType, snsAccessToken):
        """
        Args:
            ctx: FContext
            snsIdType: SnsIdType
            snsAccessToken: string
        """
        pass

    def blockContact(self, ctx, reqSeq, id):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            id: string
        """
        pass

    def blockRecommendation(self, ctx, reqSeq, id):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            id: string
        """
        pass

    def cancelGroupInvitation(self, ctx, reqSeq, groupId, contactIds):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            groupId: string
            contactIds: list of string
        """
        pass

    def changeVerificationMethod(self, ctx, sessionId, method):
        """
        Args:
            ctx: FContext
            sessionId: string
            method: VerificationMethod
        """
        pass

    def clearIdentityCredential(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def clearMessageBox(self, ctx, channelId, messageBoxId):
        """
        Args:
            ctx: FContext
            channelId: string
            messageBoxId: string
        """
        pass

    def closeProximityMatch(self, ctx, sessionId):
        """
        Args:
            ctx: FContext
            sessionId: string
        """
        pass

    def commitSendMessage(self, ctx, seq, messageId, receiverMids):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            messageId: string
            receiverMids: list of string
        """
        pass

    def commitSendMessages(self, ctx, seq, messageIds, receiverMids):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            messageIds: list of string
            receiverMids: list of string
        """
        pass

    def commitUpdateProfile(self, ctx, seq, attrs, receiverMids):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            attrs: list of ProfileAttribute
            receiverMids: list of string
        """
        pass

    def confirmEmail(self, ctx, verifier, pinCode):
        """
        Args:
            ctx: FContext
            verifier: string
            pinCode: string
        """
        pass

    def createGroup(self, ctx, seq, name, contactIds):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            name: string
            contactIds: list of string
        """
        pass

    def createQrcodeBase64Image(self, ctx, url, characterSet, imageSize, x, y, width, height):
        """
        Args:
            ctx: FContext
            url: string
            characterSet: string
            imageSize: int (signed 32 bits)
            x: int (signed 32 bits)
            y: int (signed 32 bits)
            width: int (signed 32 bits)
            height: int (signed 32 bits)
        """
        pass

    def createRoom(self, ctx, reqSeq, contactIds):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            contactIds: list of string
        """
        pass

    def createSession(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def fetchAnnouncements(self, ctx, lastFetchedIndex):
        """
        Args:
            ctx: FContext
            lastFetchedIndex: int (signed 32 bits)
        """
        pass

    def fetchMessages(self, ctx, localTs, count):
        """
        Args:
            ctx: FContext
            localTs: int (signed 64 bits)
            count: int (signed 32 bits)
        """
        pass

    def fetchOperations(self, ctx, localRev, count):
        """
        Args:
            ctx: FContext
            localRev: int (signed 64 bits)
            count: int (signed 32 bits)
        """
        pass

    def fetchOps(self, ctx, localRev, count, globalRev, individualRev):
        """
        Args:
            ctx: FContext
            localRev: int (signed 64 bits)
            count: int (signed 32 bits)
            globalRev: int (signed 64 bits)
            individualRev: int (signed 64 bits)
        """
        pass

    def findAndAddContactsByEmail(self, ctx, reqSeq, emails):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            emails: set of string
        """
        pass

    def findAndAddContactsByMid(self, ctx, reqSeq, mid, type, reference):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            mid: string
            type: ContactType
            reference: string
        """
        pass

    def findGroupByTicketV2(self, ctx, ticketId):
        """
        Args:
            ctx: FContext
            ticketId: string
        """
        pass

    def findAndAddContactsByPhone(self, ctx, reqSeq, phones):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            phones: set of string
        """
        pass

    def getFriendRequests(self, ctx, direction, lastSeenSeqId):
        """
        Args:
            ctx: FContext
            direction: FriendRequestDirection
            lastSeenSeqId: int (signed 64 bits)
        """
        pass

    def removeFriendRequest(self, ctx, direction, midOrEMid):
        """
        Args:
            ctx: FContext
            direction: FriendRequestDirection
            midOrEMid: string
        """
        pass

    def findAndAddContactsByUserid(self, ctx, reqSeq, userid):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            userid: string
        """
        pass

    def findContactByUserid(self, ctx, userid):
        """
        Args:
            ctx: FContext
            userid: string
        """
        pass

    def findContactByUserTicket(self, ctx, ticketIdWithTag):
        """
        Args:
            ctx: FContext
            ticketIdWithTag: string
        """
        pass

    def findContactsByEmail(self, ctx, emails):
        """
        Args:
            ctx: FContext
            emails: set of string
        """
        pass

    def findContactsByPhone(self, ctx, phones):
        """
        Args:
            ctx: FContext
            phones: set of string
        """
        pass

    def findSnsIdUserStatus(self, ctx, snsIdType, snsAccessToken, udidHash):
        """
        Args:
            ctx: FContext
            snsIdType: SnsIdType
            snsAccessToken: string
            udidHash: string
        """
        pass

    def finishUpdateVerification(self, ctx, sessionId):
        """
        Args:
            ctx: FContext
            sessionId: string
        """
        pass

    def generateUserTicket(self, ctx, expirationTime, maxUseCount):
        """
        Args:
            ctx: FContext
            expirationTime: int (signed 64 bits)
            maxUseCount: int (signed 32 bits)
        """
        pass

    def destroyMessage(self, ctx, seq, chatId, messageId, sessionId):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            chatId: string
            messageId: string
            sessionId: int (signed 64 bits)
        """
        pass

    def getAcceptedProximityMatches(self, ctx, sessionId):
        """
        Args:
            ctx: FContext
            sessionId: string
        """
        pass

    def getActiveBuddySubscriberIds(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getAllContactIds(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getAuthQrcode(self, ctx, keepLoggedIn, systemName):
        """
        Args:
            ctx: FContext
            keepLoggedIn: boolean
            systemName: string
        """
        pass

    def getBlockedContactIds(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def registerWithPhoneNumber(self, ctx, sessionId, migrationPincodeSessionId):
        """
        Args:
            ctx: FContext
            sessionId: string
            migrationPincodeSessionId: string
        """
        pass

    def registerWithPhoneNumberAndPassword(self, ctx, sessionId, keynm, encrypted):
        """
        Args:
            ctx: FContext
            sessionId: string
            keynm: string
            encrypted: string
        """
        pass

    def getAnalyticsInfo(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def reportClientStatistics(self, ctx, reqSeq, category, count):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            category: ReportCategory
            count: int (signed 32 bits)
        """
        pass

    def verifyPhoneNumberForLogin(self, ctx, verifierFromPhone, pinCodeForPhone, verifierFromLogin):
        """
        Args:
            ctx: FContext
            verifierFromPhone: string
            pinCodeForPhone: string
            verifierFromLogin: string
        """
        pass

    def verifyPhoneNumber(self, ctx, sessionId, pinCode, udidHash, migrationPincodeSessionId, oldUdidHash):
        """
        Args:
            ctx: FContext
            sessionId: string
            pinCode: string
            udidHash: string
            migrationPincodeSessionId: string
            oldUdidHash: string
        """
        pass

    def getBlockedContactIdsByRange(self, ctx, start, count):
        """
        Args:
            ctx: FContext
            start: int (signed 32 bits)
            count: int (signed 32 bits)
        """
        pass

    def getBlockedRecommendationIds(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getBuddyBlockerIds(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getBuddyLocation(self, ctx, mid, index):
        """
        Args:
            ctx: FContext
            mid: string
            index: int (signed 32 bits)
        """
        pass

    def getCompactContactsModifiedSince(self, ctx, timestamp):
        """
        Args:
            ctx: FContext
            timestamp: int (signed 64 bits)
        """
        pass

    def getCompactGroup(self, ctx, groupId):
        """
        Args:
            ctx: FContext
            groupId: string
        """
        pass

    def getCompactRoom(self, ctx, roomId):
        """
        Args:
            ctx: FContext
            roomId: string
        """
        pass

    def getContact(self, ctx, id):
        """
        Args:
            ctx: FContext
            id: string
        """
        pass

    def getContacts(self, ctx, ids):
        """
        Args:
            ctx: FContext
            ids: list of string
        """
        pass

    def getContactWithFriendRequestStatus(self, ctx, id):
        """
        Args:
            ctx: FContext
            id: string
        """
        pass

    def getCountryWithRequestIp(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getFavoriteMids(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getGroup(self, ctx, groupId):
        """
        Args:
            ctx: FContext
            groupId: string
        """
        pass

    def getGroupIdsInvited(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getGroupIdsJoined(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getGroups(self, ctx, groupIds):
        """
        Args:
            ctx: FContext
            groupIds: list of string
        """
        pass

    def getHiddenContactMids(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getIdentityIdentifier(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getLastAnnouncementIndex(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getLastOpRevision(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getSuggestRevisions(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getPreviousMessagesV2WithReadCount(self, ctx, messageBoxId, endMessageId, messagesCount):
        """
        Args:
            ctx: FContext
            messageBoxId: string
            endMessageId: MessageBoxV2MessageId
            messagesCount: int (signed 32 bits)
        """
        pass

    def getMessageBox(self, ctx, channelId, messageBoxId, lastMessagesCount):
        """
        Args:
            ctx: FContext
            channelId: string
            messageBoxId: string
            lastMessagesCount: int (signed 32 bits)
        """
        pass

    def getMessageBoxCompactWrapUp(self, ctx, mid):
        """
        Args:
            ctx: FContext
            mid: string
        """
        pass

    def getMessageBoxCompactWrapUpList(self, ctx, start, messageBoxCount):
        """
        Args:
            ctx: FContext
            start: int (signed 32 bits)
            messageBoxCount: int (signed 32 bits)
        """
        pass

    def getMessageBoxList(self, ctx, channelId, lastMessagesCount):
        """
        Args:
            ctx: FContext
            channelId: string
            lastMessagesCount: int (signed 32 bits)
        """
        pass

    def getMessageBoxListByStatus(self, ctx, channelId, lastMessagesCount, status):
        """
        Args:
            ctx: FContext
            channelId: string
            lastMessagesCount: int (signed 32 bits)
            status: int (signed 32 bits)
        """
        pass

    def getMessageBoxWrapUp(self, ctx, mid):
        """
        Args:
            ctx: FContext
            mid: string
        """
        pass

    def getMessageBoxWrapUpList(self, ctx, start, messageBoxCount):
        """
        Args:
            ctx: FContext
            start: int (signed 32 bits)
            messageBoxCount: int (signed 32 bits)
        """
        pass

    def getMessagesBySequenceNumber(self, ctx, channelId, messageBoxId, startSeq, endSeq):
        """
        Args:
            ctx: FContext
            channelId: string
            messageBoxId: string
            startSeq: int (signed 64 bits)
            endSeq: int (signed 64 bits)
        """
        pass

    def getNextMessages(self, ctx, messageBoxId, startSeq, messagesCount):
        """
        Args:
            ctx: FContext
            messageBoxId: string
            startSeq: int (signed 64 bits)
            messagesCount: int (signed 32 bits)
        """
        pass

    def getNotificationPolicy(self, ctx, carrier):
        """
        Args:
            ctx: FContext
            carrier: CarrierCode
        """
        pass

    def getPreviousMessages(self, ctx, messageBoxId, endSeq, messagesCount):
        """
        Args:
            ctx: FContext
            messageBoxId: string
            endSeq: int (signed 64 bits)
            messagesCount: int (signed 32 bits)
        """
        pass

    def getProfile(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getProximityMatchCandidateList(self, ctx, sessionId):
        """
        Args:
            ctx: FContext
            sessionId: string
        """
        pass

    def getProximityMatchCandidates(self, ctx, sessionId):
        """
        Args:
            ctx: FContext
            sessionId: string
        """
        pass

    def getRecentMessages(self, ctx, messageBoxId, messagesCount):
        """
        Args:
            ctx: FContext
            messageBoxId: string
            messagesCount: int (signed 32 bits)
        """
        pass

    def getRecommendationIds(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getRoom(self, ctx, roomId):
        """
        Args:
            ctx: FContext
            roomId: string
        """
        pass

    def getRSAKeyInfo(self, ctx, provider):
        """
        Args:
            ctx: FContext
            provider: IdentityProvider
        """
        pass

    def getServerTime(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getSessions(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getSettings(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getGroupsV2(self, ctx, groupIds):
        """
        Args:
            ctx: FContext
            groupIds: list of string
        """
        pass

    def getSettingsAttributes(self, ctx, attrBitset):
        """
        Args:
            ctx: FContext
            attrBitset: int (signed 32 bits)
        """
        pass

    def getSystemConfiguration(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getUserTicket(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getWapInvitation(self, ctx, invitationHash):
        """
        Args:
            ctx: FContext
            invitationHash: string
        """
        pass

    def invalidateUserTicket(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def inviteFriendsBySms(self, ctx, phoneNumberList):
        """
        Args:
            ctx: FContext
            phoneNumberList: list of string
        """
        pass

    def inviteIntoGroup(self, ctx, reqSeq, groupId, contactIds):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            groupId: string
            contactIds: list of string
        """
        pass

    def inviteIntoRoom(self, ctx, reqSeq, roomId, contactIds):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            roomId: string
            contactIds: list of string
        """
        pass

    def inviteViaEmail(self, ctx, reqSeq, email, name):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            email: string
            name: string
        """
        pass

    def isIdentityIdentifierAvailable(self, ctx, provider, identifier):
        """
        Args:
            ctx: FContext
            provider: IdentityProvider
            identifier: string
        """
        pass

    def isUseridAvailable(self, ctx, userid):
        """
        Args:
            ctx: FContext
            userid: string
        """
        pass

    def kickoutFromGroup(self, ctx, reqSeq, groupId, contactIds):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            groupId: string
            contactIds: list of string
        """
        pass

    def reissueGroupTicket(self, ctx, groupMid):
        """
        Args:
            ctx: FContext
            groupMid: string
        """
        pass

    def findGroupByTicket(self, ctx, ticketId):
        """
        Args:
            ctx: FContext
            ticketId: string
        """
        pass

    def leaveGroup(self, ctx, reqSeq, groupId):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            groupId: string
        """
        pass

    def leaveRoom(self, ctx, reqSeq, roomId):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            roomId: string
        """
        pass

    def loginWithIdentityCredential(self, ctx, identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate):
        """
        Args:
            ctx: FContext
            identityProvider: IdentityProvider
            identifier: string
            password: string
            keepLoggedIn: boolean
            accessLocation: string
            systemName: string
            certificate: string
        """
        pass

    def loginWithIdentityCredentialForCertificate(self, ctx, identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate):
        """
        Args:
            ctx: FContext
            identityProvider: IdentityProvider
            identifier: string
            password: string
            keepLoggedIn: boolean
            accessLocation: string
            systemName: string
            certificate: string
        """
        pass

    def loginWithVerifier(self, ctx, verifier):
        """
        Args:
            ctx: FContext
            verifier: string
        """
        pass

    def loginWithVerifierForCerificate(self, ctx, verifier):
        """
        Args:
            ctx: FContext
            verifier: string
        """
        pass

    def loginWithVerifierForCertificate(self, ctx, verifier):
        """
        Args:
            ctx: FContext
            verifier: string
        """
        pass

    def logout(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def logoutSession(self, ctx, tokenKey):
        """
        Args:
            ctx: FContext
            tokenKey: string
        """
        pass

    def noop(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def notifiedRedirect(self, ctx, paramMap):
        """
        Args:
            ctx: FContext
            paramMap: dict of <string, string>
        """
        pass

    def notifyBuddyOnAir(self, ctx, seq, receiverMids):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            receiverMids: list of string
        """
        pass

    def notifyIndividualEvent(self, ctx, notificationStatus, receiverMids):
        """
        Args:
            ctx: FContext
            notificationStatus: NotificationStatus
            receiverMids: list of string
        """
        pass

    def notifyInstalled(self, ctx, udidHash, applicationTypeWithExtensions):
        """
        Args:
            ctx: FContext
            udidHash: string
            applicationTypeWithExtensions: string
        """
        pass

    def notifyRegistrationComplete(self, ctx, udidHash, applicationTypeWithExtensions):
        """
        Args:
            ctx: FContext
            udidHash: string
            applicationTypeWithExtensions: string
        """
        pass

    def notifySleep(self, ctx, lastRev, badge):
        """
        Args:
            ctx: FContext
            lastRev: int (signed 64 bits)
            badge: int (signed 32 bits)
        """
        pass

    def notifyUpdated(self, ctx, lastRev, deviceInfo):
        """
        Args:
            ctx: FContext
            lastRev: int (signed 64 bits)
            deviceInfo: DeviceInfo
        """
        pass

    def openProximityMatch(self, ctx, location):
        """
        Args:
            ctx: FContext
            location: Location
        """
        pass

    def registerBuddyUser(self, ctx, buddyId, registrarPassword):
        """
        Args:
            ctx: FContext
            buddyId: string
            registrarPassword: string
        """
        pass

    def registerBuddyUserid(self, ctx, seq, userid):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            userid: string
        """
        pass

    def registerDevice(self, ctx, sessionId):
        """
        Args:
            ctx: FContext
            sessionId: string
        """
        pass

    def registerDeviceWithIdentityCredential(self, ctx, sessionId, provider, identifier, verifier):
        """
        Args:
            ctx: FContext
            sessionId: string
            provider: IdentityProvider
            identifier: string
            verifier: string
        """
        pass

    def registerDeviceWithoutPhoneNumber(self, ctx, region, udidHash, deviceInfo):
        """
        Args:
            ctx: FContext
            region: string
            udidHash: string
            deviceInfo: DeviceInfo
        """
        pass

    def registerDeviceWithoutPhoneNumberWithIdentityCredential(self, ctx, region, udidHash, deviceInfo, provider, identifier, verifier, mid, migrationPincodeSessionId):
        """
        Args:
            ctx: FContext
            region: string
            udidHash: string
            deviceInfo: DeviceInfo
            provider: IdentityProvider
            identifier: string
            verifier: string
            mid: string
            migrationPincodeSessionId: string
        """
        pass

    def registerUserid(self, ctx, reqSeq, userid):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            userid: string
        """
        pass

    def registerWapDevice(self, ctx, invitationHash, guidHash, email, deviceInfo):
        """
        Args:
            ctx: FContext
            invitationHash: string
            guidHash: string
            email: string
            deviceInfo: DeviceInfo
        """
        pass

    def registerWithExistingSnsIdAndIdentityCredential(self, ctx, identityCredential, region, udidHash, deviceInfo):
        """
        Args:
            ctx: FContext
            identityCredential: IdentityCredential
            region: string
            udidHash: string
            deviceInfo: DeviceInfo
        """
        pass

    def registerWithSnsId(self, ctx, snsIdType, snsAccessToken, region, udidHash, deviceInfo, mid):
        """
        Args:
            ctx: FContext
            snsIdType: SnsIdType
            snsAccessToken: string
            region: string
            udidHash: string
            deviceInfo: DeviceInfo
            mid: string
        """
        pass

    def registerWithSnsIdAndIdentityCredential(self, ctx, snsIdType, snsAccessToken, identityCredential, region, udidHash, deviceInfo):
        """
        Args:
            ctx: FContext
            snsIdType: SnsIdType
            snsAccessToken: string
            identityCredential: IdentityCredential
            region: string
            udidHash: string
            deviceInfo: DeviceInfo
        """
        pass

    def reissueDeviceCredential(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def reissueUserTicket(self, ctx, expirationTime, maxUseCount):
        """
        Args:
            ctx: FContext
            expirationTime: int (signed 64 bits)
            maxUseCount: int (signed 32 bits)
        """
        pass

    def getMessageReadRange(self, ctx, chatIds):
        """
        Args:
            ctx: FContext
            chatIds: list of string
        """
        pass

    def rejectGroupInvitation(self, ctx, reqSeq, groupId):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            groupId: string
        """
        pass

    def releaseSession(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def removeAllMessages(self, ctx, seq, lastMessageId):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            lastMessageId: string
        """
        pass

    def removeBuddyLocation(self, ctx, mid, index):
        """
        Args:
            ctx: FContext
            mid: string
            index: int (signed 32 bits)
        """
        pass

    def removeMessage(self, ctx, messageId):
        """
        Args:
            ctx: FContext
            messageId: string
        """
        pass

    def makeUserAddMyselfAsContact(self, ctx, contactOwnerMid):
        """
        Args:
            ctx: FContext
            contactOwnerMid: string
        """
        pass

    def removeMessageFromMyHome(self, ctx, messageId):
        """
        Args:
            ctx: FContext
            messageId: string
        """
        pass

    def removeSnsId(self, ctx, snsIdType):
        """
        Args:
            ctx: FContext
            snsIdType: SnsIdType
        """
        pass

    def report(self, ctx, syncOpRevision, category, report):
        """
        Args:
            ctx: FContext
            syncOpRevision: int (signed 64 bits)
            category: SyncCategory
            report: string
        """
        pass

    def reportContacts(self, ctx, syncOpRevision, category, contactReports, actionType):
        """
        Args:
            ctx: FContext
            syncOpRevision: int (signed 64 bits)
            category: SyncCategory
            contactReports: list of ContactReport
            actionType: SyncActionType
        """
        pass

    def reportGroups(self, ctx, syncOpRevision, groups):
        """
        Args:
            ctx: FContext
            syncOpRevision: int (signed 64 bits)
            groups: list of Group
        """
        pass

    def reportProfile(self, ctx, syncOpRevision, profile):
        """
        Args:
            ctx: FContext
            syncOpRevision: int (signed 64 bits)
            profile: Profile
        """
        pass

    def reportRooms(self, ctx, syncOpRevision, rooms):
        """
        Args:
            ctx: FContext
            syncOpRevision: int (signed 64 bits)
            rooms: list of Room
        """
        pass

    def findAndAddContactByMetaTag(self, ctx, reqSeq, userid, reference):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            userid: string
            reference: string
        """
        pass

    def reportSettings(self, ctx, syncOpRevision, settings):
        """
        Args:
            ctx: FContext
            syncOpRevision: int (signed 64 bits)
            settings: Settings
        """
        pass

    def reportSpam(self, ctx, chatMid, memberMids, spammerReasons, senderMids, spamMessageIds, spamMessages):
        """
        Args:
            ctx: FContext
            chatMid: string
            memberMids: list of string
            spammerReasons: list of SpammerReason
            senderMids: list of string
            spamMessageIds: list of string
            spamMessages: list of string
        """
        pass

    def reportSpammer(self, ctx, spammerMid, spammerReasons, spamMessageIds):
        """
        Args:
            ctx: FContext
            spammerMid: string
            spammerReasons: list of SpammerReason
            spamMessageIds: list of string
        """
        pass

    def requestAccountPasswordReset(self, ctx, provider, identifier, locale):
        """
        Args:
            ctx: FContext
            provider: IdentityProvider
            identifier: string
            locale: string
        """
        pass

    def requestEmailConfirmation(self, ctx, emailConfirmation):
        """
        Args:
            ctx: FContext
            emailConfirmation: EmailConfirmation
        """
        pass

    def requestIdentityUnbind(self, ctx, provider, identifier):
        """
        Args:
            ctx: FContext
            provider: IdentityProvider
            identifier: string
        """
        pass

    def resendEmailConfirmation(self, ctx, verifier):
        """
        Args:
            ctx: FContext
            verifier: string
        """
        pass

    def resendPinCode(self, ctx, sessionId):
        """
        Args:
            ctx: FContext
            sessionId: string
        """
        pass

    def resendPinCodeBySMS(self, ctx, sessionId):
        """
        Args:
            ctx: FContext
            sessionId: string
        """
        pass

    def sendChatChecked(self, ctx, seq, consumer, lastMessageId):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            consumer: string
            lastMessageId: string
        """
        pass

    def sendMessageAwaitCommit(self, ctx, seq, message):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            message: Message
        """
        pass

    def sendChatRemoved(self, ctx, seq, consumer, lastMessageId):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            consumer: string
            lastMessageId: string
        """
        pass

    def sendContentPreviewUpdated(self, ctx, esq, messageId, receiverMids):
        """
        Args:
            ctx: FContext
            esq: int (signed 32 bits)
            messageId: string
            receiverMids: list of string
        """
        pass

    def sendContentReceipt(self, ctx, seq, consumer, messageId):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            consumer: string
            messageId: string
        """
        pass

    def sendDummyPush(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def removeE2EEPublicKey(self, ctx, publicKey):
        """
        Args:
            ctx: FContext
            publicKey: E2EEPublicKey
        """
        pass

    def negotiateE2EEPublicKey(self, ctx, mid):
        """
        Args:
            ctx: FContext
            mid: string
        """
        pass

    def getE2EEPublicKey(self, ctx, mid, version, keyId):
        """
        Args:
            ctx: FContext
            mid: string
            version: int (signed 32 bits)
            keyId: int (signed 32 bits)
        """
        pass

    def requestE2EEKeyExchange(self, ctx, reqSeq, temporalPublicKey, publicKey, verifier):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            temporalPublicKey: binary string
            publicKey: E2EEPublicKey
            verifier: binary string
        """
        pass

    def getLastE2EEPublicKeys(self, ctx, chatMid):
        """
        Args:
            ctx: FContext
            chatMid: string
        """
        pass

    def registerE2EEPublicKey(self, ctx, reqSeq, publicKey):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            publicKey: E2EEPublicKey
        """
        pass

    def getE2EEPublicKeys(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getE2EEPublicKeysEx(self, ctx, ignoreE2EEStatus):
        """
        Args:
            ctx: FContext
            ignoreE2EEStatus: boolean
        """
        pass

    def getReadMessageOpsInBulk(self, ctx, chatIds):
        """
        Args:
            ctx: FContext
            chatIds: list of string
        """
        pass

    def sendEvent(self, ctx, seq, message):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            message: Message
        """
        pass

    def sendMessage(self, ctx, seq, message):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            message: Message
        """
        pass

    def sendMessageIgnored(self, ctx, seq, consumer, messageIds):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            consumer: string
            messageIds: list of string
        """
        pass

    def sendMessageReceipt(self, ctx, seq, consumer, messageIds):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            consumer: string
            messageIds: list of string
        """
        pass

    def findContactByMetaTag(self, ctx, userid, reference):
        """
        Args:
            ctx: FContext
            userid: string
            reference: string
        """
        pass

    def sendMessageToMyHome(self, ctx, seq, message):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            message: Message
        """
        pass

    def setBuddyLocation(self, ctx, mid, index, location):
        """
        Args:
            ctx: FContext
            mid: string
            index: int (signed 32 bits)
            location: Geolocation
        """
        pass

    def setIdentityCredential(self, ctx, identifier, verifier, provider):
        """
        Args:
            ctx: FContext
            identifier: string
            verifier: string
            provider: IdentityProvider
        """
        pass

    def setNotificationsEnabled(self, ctx, reqSeq, type, target, enablement):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            type: MIDType
            target: string
            enablement: boolean
        """
        pass

    def startUpdateVerification(self, ctx, region, carrier, phone, udidHash, deviceInfo, networkCode, locale):
        """
        Args:
            ctx: FContext
            region: string
            carrier: CarrierCode
            phone: string
            udidHash: string
            deviceInfo: DeviceInfo
            networkCode: string
            locale: string
        """
        pass

    def startVerification(self, ctx, region, carrier, phone, udidHash, deviceInfo, networkCode, mid, locale, simInfo, oldUdidHash):
        """
        Args:
            ctx: FContext
            region: string
            carrier: CarrierCode
            phone: string
            udidHash: string
            deviceInfo: DeviceInfo
            networkCode: string
            mid: string
            locale: string
            simInfo: SIMInfo
            oldUdidHash: string
        """
        pass

    def updateGroupPreferenceAttribute(self, ctx, reqSeq, groupMid, updatedAttrs):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            groupMid: string
            updatedAttrs: dict of <GroupPreferenceAttribute, string>
        """
        pass

    def createRoomV2(self, ctx, reqSeq, contactIds):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            contactIds: list of string
        """
        pass

    def storeUpdateProfileAttribute(self, ctx, seq, profileAttribute, value):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            profileAttribute: ProfileAttribute
            value: string
        """
        pass

    def syncContactBySnsIds(self, ctx, reqSeq, modifications):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            modifications: list of SnsFriendModification
        """
        pass

    def syncContacts(self, ctx, reqSeq, localContacts):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            localContacts: list of ContactModification
        """
        pass

    def trySendMessage(self, ctx, seq, message):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            message: Message
        """
        pass

    def getNextMessagesV2(self, ctx, messageBoxId, startMessageId, messagesCount):
        """
        Args:
            ctx: FContext
            messageBoxId: string
            startMessageId: MessageBoxV2MessageId
            messagesCount: int (signed 32 bits)
        """
        pass

    def getMessageBoxCompactWrapUpV2(self, ctx, messageBoxId):
        """
        Args:
            ctx: FContext
            messageBoxId: string
        """
        pass

    def getRecentMessagesV2(self, ctx, messageBoxId, messagesCount):
        """
        Args:
            ctx: FContext
            messageBoxId: string
            messagesCount: int (signed 32 bits)
        """
        pass

    def validateContactsOnBot(self, ctx, contacts):
        """
        Args:
            ctx: FContext
            contacts: list of string
        """
        pass

    def tryFriendRequest(self, ctx, midOrEMid, method, friendRequestParams):
        """
        Args:
            ctx: FContext
            midOrEMid: string
            method: FriendRequestMethod
            friendRequestParams: string
        """
        pass

    def unblockContact(self, ctx, reqSeq, id):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            id: string
        """
        pass

    def unblockRecommendation(self, ctx, reqSeq, id):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            id: string
        """
        pass

    def unregisterUserAndDevice(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def updateApnsDeviceToken(self, ctx, apnsDeviceToken):
        """
        Args:
            ctx: FContext
            apnsDeviceToken: binary string
        """
        pass

    def updateBuddySetting(self, ctx, key, value):
        """
        Args:
            ctx: FContext
            key: string
            value: string
        """
        pass

    def updateC2DMRegistrationId(self, ctx, registrationId):
        """
        Args:
            ctx: FContext
            registrationId: string
        """
        pass

    def updateContactSetting(self, ctx, reqSeq, mid, flag, value):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            mid: string
            flag: ContactSetting
            value: string
        """
        pass

    def updateCustomModeSettings(self, ctx, customMode, paramMap):
        """
        Args:
            ctx: FContext
            customMode: CustomMode
            paramMap: dict of <string, string>
        """
        pass

    def updateDeviceInfo(self, ctx, deviceUid, deviceInfo):
        """
        Args:
            ctx: FContext
            deviceUid: string
            deviceInfo: DeviceInfo
        """
        pass

    def updateGroup(self, ctx, reqSeq, group):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            group: Group
        """
        pass

    def updateNotificationToken(self, ctx, type, token):
        """
        Args:
            ctx: FContext
            type: NotificationType
            token: string
        """
        pass

    def updateNotificationTokenWithBytes(self, ctx, type, token):
        """
        Args:
            ctx: FContext
            type: NotificationType
            token: binary string
        """
        pass

    def updateProfile(self, ctx, reqSeq, profile):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            profile: Profile
        """
        pass

    def updateProfileAttribute(self, ctx, reqSeq, attr, value):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            attr: ProfileAttribute
            value: string
        """
        pass

    def updateRegion(self, ctx, region):
        """
        Args:
            ctx: FContext
            region: string
        """
        pass

    def updateSettings(self, ctx, reqSeq, settings):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            settings: Settings
        """
        pass

    def updateSettings2(self, ctx, reqSeq, settings):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            settings: Settings
        """
        pass

    def updateSettingsAttribute(self, ctx, reqSeq, attr, value):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            attr: SettingsAttribute
            value: string
        """
        pass

    def updateSettingsAttributes(self, ctx, reqSeq, attrBitset, settings):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            attrBitset: int (signed 32 bits)
            settings: Settings
        """
        pass

    def verifyIdentityCredential(self, ctx, identityProvider, identifier, password):
        """
        Args:
            ctx: FContext
            identityProvider: IdentityProvider
            identifier: string
            password: string
        """
        pass

    def verifyIdentityCredentialWithResult(self, ctx, identityCredential):
        """
        Args:
            ctx: FContext
            identityCredential: IdentityCredential
        """
        pass

    def verifyPhone(self, ctx, sessionId, pinCode, udidHash):
        """
        Args:
            ctx: FContext
            sessionId: string
            pinCode: string
            udidHash: string
        """
        pass

    def verifyQrcode(self, ctx, verifier, pinCode):
        """
        Args:
            ctx: FContext
            verifier: string
            pinCode: string
        """
        pass


class Client(Iface):

    def __init__(self, provider, middleware=None):
        """
        Create a new Client with an FServiceProvider containing a transport
        and protocol factory.

        Args:
            provider: FServiceProvider with TSynchronousTransport
            middleware: ServiceMiddleware or list of ServiceMiddleware
        """
        middleware = middleware or []
        if middleware and not isinstance(middleware, list):
            middleware = [middleware]
        self._transport = provider.get_transport()
        self._protocol_factory = provider.get_protocol_factory()
        self._oprot = self._protocol_factory.get_protocol(self._transport)
        self._iprot = self._protocol_factory.get_protocol(self._transport)
        self._write_lock = Lock()
        middleware += provider.get_middleware()
        self._methods = {
            'getChatRoomAnnouncementsBulk': Method(self._getChatRoomAnnouncementsBulk, middleware),
            'getChatRoomAnnouncements': Method(self._getChatRoomAnnouncements, middleware),
            'createChatRoomAnnouncement': Method(self._createChatRoomAnnouncement, middleware),
            'removeChatRoomAnnouncement': Method(self._removeChatRoomAnnouncement, middleware),
            'unsendMessage': Method(self._unsendMessage, middleware),
            'getGroupWithoutMembers': Method(self._getGroupWithoutMembers, middleware),
            'requestResendMessage': Method(self._requestResendMessage, middleware),
            'respondResendMessage': Method(self._respondResendMessage, middleware),
            'acceptGroupInvitation': Method(self._acceptGroupInvitation, middleware),
            'acceptGroupInvitationByTicket': Method(self._acceptGroupInvitationByTicket, middleware),
            'acceptProximityMatches': Method(self._acceptProximityMatches, middleware),
            'acquireCallRoute': Method(self._acquireCallRoute, middleware),
            'acquireCallTicket': Method(self._acquireCallTicket, middleware),
            'acquireEncryptedAccessToken': Method(self._acquireEncryptedAccessToken, middleware),
            'addSnsId': Method(self._addSnsId, middleware),
            'blockContact': Method(self._blockContact, middleware),
            'blockRecommendation': Method(self._blockRecommendation, middleware),
            'cancelGroupInvitation': Method(self._cancelGroupInvitation, middleware),
            'changeVerificationMethod': Method(self._changeVerificationMethod, middleware),
            'clearIdentityCredential': Method(self._clearIdentityCredential, middleware),
            'clearMessageBox': Method(self._clearMessageBox, middleware),
            'closeProximityMatch': Method(self._closeProximityMatch, middleware),
            'commitSendMessage': Method(self._commitSendMessage, middleware),
            'commitSendMessages': Method(self._commitSendMessages, middleware),
            'commitUpdateProfile': Method(self._commitUpdateProfile, middleware),
            'confirmEmail': Method(self._confirmEmail, middleware),
            'createGroup': Method(self._createGroup, middleware),
            'createQrcodeBase64Image': Method(self._createQrcodeBase64Image, middleware),
            'createRoom': Method(self._createRoom, middleware),
            'createSession': Method(self._createSession, middleware),
            'fetchAnnouncements': Method(self._fetchAnnouncements, middleware),
            'fetchMessages': Method(self._fetchMessages, middleware),
            'fetchOperations': Method(self._fetchOperations, middleware),
            'fetchOps': Method(self._fetchOps, middleware),
            'findAndAddContactsByEmail': Method(self._findAndAddContactsByEmail, middleware),
            'findAndAddContactsByMid': Method(self._findAndAddContactsByMid, middleware),
            'findGroupByTicketV2': Method(self._findGroupByTicketV2, middleware),
            'findAndAddContactsByPhone': Method(self._findAndAddContactsByPhone, middleware),
            'getFriendRequests': Method(self._getFriendRequests, middleware),
            'removeFriendRequest': Method(self._removeFriendRequest, middleware),
            'findAndAddContactsByUserid': Method(self._findAndAddContactsByUserid, middleware),
            'findContactByUserid': Method(self._findContactByUserid, middleware),
            'findContactByUserTicket': Method(self._findContactByUserTicket, middleware),
            'findContactsByEmail': Method(self._findContactsByEmail, middleware),
            'findContactsByPhone': Method(self._findContactsByPhone, middleware),
            'findSnsIdUserStatus': Method(self._findSnsIdUserStatus, middleware),
            'finishUpdateVerification': Method(self._finishUpdateVerification, middleware),
            'generateUserTicket': Method(self._generateUserTicket, middleware),
            'destroyMessage': Method(self._destroyMessage, middleware),
            'getAcceptedProximityMatches': Method(self._getAcceptedProximityMatches, middleware),
            'getActiveBuddySubscriberIds': Method(self._getActiveBuddySubscriberIds, middleware),
            'getAllContactIds': Method(self._getAllContactIds, middleware),
            'getAuthQrcode': Method(self._getAuthQrcode, middleware),
            'getBlockedContactIds': Method(self._getBlockedContactIds, middleware),
            'registerWithPhoneNumber': Method(self._registerWithPhoneNumber, middleware),
            'registerWithPhoneNumberAndPassword': Method(self._registerWithPhoneNumberAndPassword, middleware),
            'getAnalyticsInfo': Method(self._getAnalyticsInfo, middleware),
            'reportClientStatistics': Method(self._reportClientStatistics, middleware),
            'verifyPhoneNumberForLogin': Method(self._verifyPhoneNumberForLogin, middleware),
            'verifyPhoneNumber': Method(self._verifyPhoneNumber, middleware),
            'getBlockedContactIdsByRange': Method(self._getBlockedContactIdsByRange, middleware),
            'getBlockedRecommendationIds': Method(self._getBlockedRecommendationIds, middleware),
            'getBuddyBlockerIds': Method(self._getBuddyBlockerIds, middleware),
            'getBuddyLocation': Method(self._getBuddyLocation, middleware),
            'getCompactContactsModifiedSince': Method(self._getCompactContactsModifiedSince, middleware),
            'getCompactGroup': Method(self._getCompactGroup, middleware),
            'getCompactRoom': Method(self._getCompactRoom, middleware),
            'getContact': Method(self._getContact, middleware),
            'getContacts': Method(self._getContacts, middleware),
            'getContactWithFriendRequestStatus': Method(self._getContactWithFriendRequestStatus, middleware),
            'getCountryWithRequestIp': Method(self._getCountryWithRequestIp, middleware),
            'getFavoriteMids': Method(self._getFavoriteMids, middleware),
            'getGroup': Method(self._getGroup, middleware),
            'getGroupIdsInvited': Method(self._getGroupIdsInvited, middleware),
            'getGroupIdsJoined': Method(self._getGroupIdsJoined, middleware),
            'getGroups': Method(self._getGroups, middleware),
            'getHiddenContactMids': Method(self._getHiddenContactMids, middleware),
            'getIdentityIdentifier': Method(self._getIdentityIdentifier, middleware),
            'getLastAnnouncementIndex': Method(self._getLastAnnouncementIndex, middleware),
            'getLastOpRevision': Method(self._getLastOpRevision, middleware),
            'getSuggestRevisions': Method(self._getSuggestRevisions, middleware),
            'getPreviousMessagesV2WithReadCount': Method(self._getPreviousMessagesV2WithReadCount, middleware),
            'getMessageBox': Method(self._getMessageBox, middleware),
            'getMessageBoxCompactWrapUp': Method(self._getMessageBoxCompactWrapUp, middleware),
            'getMessageBoxCompactWrapUpList': Method(self._getMessageBoxCompactWrapUpList, middleware),
            'getMessageBoxList': Method(self._getMessageBoxList, middleware),
            'getMessageBoxListByStatus': Method(self._getMessageBoxListByStatus, middleware),
            'getMessageBoxWrapUp': Method(self._getMessageBoxWrapUp, middleware),
            'getMessageBoxWrapUpList': Method(self._getMessageBoxWrapUpList, middleware),
            'getMessagesBySequenceNumber': Method(self._getMessagesBySequenceNumber, middleware),
            'getNextMessages': Method(self._getNextMessages, middleware),
            'getNotificationPolicy': Method(self._getNotificationPolicy, middleware),
            'getPreviousMessages': Method(self._getPreviousMessages, middleware),
            'getProfile': Method(self._getProfile, middleware),
            'getProximityMatchCandidateList': Method(self._getProximityMatchCandidateList, middleware),
            'getProximityMatchCandidates': Method(self._getProximityMatchCandidates, middleware),
            'getRecentMessages': Method(self._getRecentMessages, middleware),
            'getRecommendationIds': Method(self._getRecommendationIds, middleware),
            'getRoom': Method(self._getRoom, middleware),
            'getRSAKeyInfo': Method(self._getRSAKeyInfo, middleware),
            'getServerTime': Method(self._getServerTime, middleware),
            'getSessions': Method(self._getSessions, middleware),
            'getSettings': Method(self._getSettings, middleware),
            'getGroupsV2': Method(self._getGroupsV2, middleware),
            'getSettingsAttributes': Method(self._getSettingsAttributes, middleware),
            'getSystemConfiguration': Method(self._getSystemConfiguration, middleware),
            'getUserTicket': Method(self._getUserTicket, middleware),
            'getWapInvitation': Method(self._getWapInvitation, middleware),
            'invalidateUserTicket': Method(self._invalidateUserTicket, middleware),
            'inviteFriendsBySms': Method(self._inviteFriendsBySms, middleware),
            'inviteIntoGroup': Method(self._inviteIntoGroup, middleware),
            'inviteIntoRoom': Method(self._inviteIntoRoom, middleware),
            'inviteViaEmail': Method(self._inviteViaEmail, middleware),
            'isIdentityIdentifierAvailable': Method(self._isIdentityIdentifierAvailable, middleware),
            'isUseridAvailable': Method(self._isUseridAvailable, middleware),
            'kickoutFromGroup': Method(self._kickoutFromGroup, middleware),
            'reissueGroupTicket': Method(self._reissueGroupTicket, middleware),
            'findGroupByTicket': Method(self._findGroupByTicket, middleware),
            'leaveGroup': Method(self._leaveGroup, middleware),
            'leaveRoom': Method(self._leaveRoom, middleware),
            'loginWithIdentityCredential': Method(self._loginWithIdentityCredential, middleware),
            'loginWithIdentityCredentialForCertificate': Method(self._loginWithIdentityCredentialForCertificate, middleware),
            'loginWithVerifier': Method(self._loginWithVerifier, middleware),
            'loginWithVerifierForCerificate': Method(self._loginWithVerifierForCerificate, middleware),
            'loginWithVerifierForCertificate': Method(self._loginWithVerifierForCertificate, middleware),
            'logout': Method(self._logout, middleware),
            'logoutSession': Method(self._logoutSession, middleware),
            'noop': Method(self._noop, middleware),
            'notifiedRedirect': Method(self._notifiedRedirect, middleware),
            'notifyBuddyOnAir': Method(self._notifyBuddyOnAir, middleware),
            'notifyIndividualEvent': Method(self._notifyIndividualEvent, middleware),
            'notifyInstalled': Method(self._notifyInstalled, middleware),
            'notifyRegistrationComplete': Method(self._notifyRegistrationComplete, middleware),
            'notifySleep': Method(self._notifySleep, middleware),
            'notifyUpdated': Method(self._notifyUpdated, middleware),
            'openProximityMatch': Method(self._openProximityMatch, middleware),
            'registerBuddyUser': Method(self._registerBuddyUser, middleware),
            'registerBuddyUserid': Method(self._registerBuddyUserid, middleware),
            'registerDevice': Method(self._registerDevice, middleware),
            'registerDeviceWithIdentityCredential': Method(self._registerDeviceWithIdentityCredential, middleware),
            'registerDeviceWithoutPhoneNumber': Method(self._registerDeviceWithoutPhoneNumber, middleware),
            'registerDeviceWithoutPhoneNumberWithIdentityCredential': Method(self._registerDeviceWithoutPhoneNumberWithIdentityCredential, middleware),
            'registerUserid': Method(self._registerUserid, middleware),
            'registerWapDevice': Method(self._registerWapDevice, middleware),
            'registerWithExistingSnsIdAndIdentityCredential': Method(self._registerWithExistingSnsIdAndIdentityCredential, middleware),
            'registerWithSnsId': Method(self._registerWithSnsId, middleware),
            'registerWithSnsIdAndIdentityCredential': Method(self._registerWithSnsIdAndIdentityCredential, middleware),
            'reissueDeviceCredential': Method(self._reissueDeviceCredential, middleware),
            'reissueUserTicket': Method(self._reissueUserTicket, middleware),
            'getMessageReadRange': Method(self._getMessageReadRange, middleware),
            'rejectGroupInvitation': Method(self._rejectGroupInvitation, middleware),
            'releaseSession': Method(self._releaseSession, middleware),
            'removeAllMessages': Method(self._removeAllMessages, middleware),
            'removeBuddyLocation': Method(self._removeBuddyLocation, middleware),
            'removeMessage': Method(self._removeMessage, middleware),
            'makeUserAddMyselfAsContact': Method(self._makeUserAddMyselfAsContact, middleware),
            'removeMessageFromMyHome': Method(self._removeMessageFromMyHome, middleware),
            'removeSnsId': Method(self._removeSnsId, middleware),
            'report': Method(self._report, middleware),
            'reportContacts': Method(self._reportContacts, middleware),
            'reportGroups': Method(self._reportGroups, middleware),
            'reportProfile': Method(self._reportProfile, middleware),
            'reportRooms': Method(self._reportRooms, middleware),
            'findAndAddContactByMetaTag': Method(self._findAndAddContactByMetaTag, middleware),
            'reportSettings': Method(self._reportSettings, middleware),
            'reportSpam': Method(self._reportSpam, middleware),
            'reportSpammer': Method(self._reportSpammer, middleware),
            'requestAccountPasswordReset': Method(self._requestAccountPasswordReset, middleware),
            'requestEmailConfirmation': Method(self._requestEmailConfirmation, middleware),
            'requestIdentityUnbind': Method(self._requestIdentityUnbind, middleware),
            'resendEmailConfirmation': Method(self._resendEmailConfirmation, middleware),
            'resendPinCode': Method(self._resendPinCode, middleware),
            'resendPinCodeBySMS': Method(self._resendPinCodeBySMS, middleware),
            'sendChatChecked': Method(self._sendChatChecked, middleware),
            'sendMessageAwaitCommit': Method(self._sendMessageAwaitCommit, middleware),
            'sendChatRemoved': Method(self._sendChatRemoved, middleware),
            'sendContentPreviewUpdated': Method(self._sendContentPreviewUpdated, middleware),
            'sendContentReceipt': Method(self._sendContentReceipt, middleware),
            'sendDummyPush': Method(self._sendDummyPush, middleware),
            'removeE2EEPublicKey': Method(self._removeE2EEPublicKey, middleware),
            'negotiateE2EEPublicKey': Method(self._negotiateE2EEPublicKey, middleware),
            'getE2EEPublicKey': Method(self._getE2EEPublicKey, middleware),
            'requestE2EEKeyExchange': Method(self._requestE2EEKeyExchange, middleware),
            'getLastE2EEPublicKeys': Method(self._getLastE2EEPublicKeys, middleware),
            'registerE2EEPublicKey': Method(self._registerE2EEPublicKey, middleware),
            'getE2EEPublicKeys': Method(self._getE2EEPublicKeys, middleware),
            'getE2EEPublicKeysEx': Method(self._getE2EEPublicKeysEx, middleware),
            'getReadMessageOpsInBulk': Method(self._getReadMessageOpsInBulk, middleware),
            'sendEvent': Method(self._sendEvent, middleware),
            'sendMessage': Method(self._sendMessage, middleware),
            'sendMessageIgnored': Method(self._sendMessageIgnored, middleware),
            'sendMessageReceipt': Method(self._sendMessageReceipt, middleware),
            'findContactByMetaTag': Method(self._findContactByMetaTag, middleware),
            'sendMessageToMyHome': Method(self._sendMessageToMyHome, middleware),
            'setBuddyLocation': Method(self._setBuddyLocation, middleware),
            'setIdentityCredential': Method(self._setIdentityCredential, middleware),
            'setNotificationsEnabled': Method(self._setNotificationsEnabled, middleware),
            'startUpdateVerification': Method(self._startUpdateVerification, middleware),
            'startVerification': Method(self._startVerification, middleware),
            'updateGroupPreferenceAttribute': Method(self._updateGroupPreferenceAttribute, middleware),
            'createRoomV2': Method(self._createRoomV2, middleware),
            'storeUpdateProfileAttribute': Method(self._storeUpdateProfileAttribute, middleware),
            'syncContactBySnsIds': Method(self._syncContactBySnsIds, middleware),
            'syncContacts': Method(self._syncContacts, middleware),
            'trySendMessage': Method(self._trySendMessage, middleware),
            'getNextMessagesV2': Method(self._getNextMessagesV2, middleware),
            'getMessageBoxCompactWrapUpV2': Method(self._getMessageBoxCompactWrapUpV2, middleware),
            'getRecentMessagesV2': Method(self._getRecentMessagesV2, middleware),
            'validateContactsOnBot': Method(self._validateContactsOnBot, middleware),
            'tryFriendRequest': Method(self._tryFriendRequest, middleware),
            'unblockContact': Method(self._unblockContact, middleware),
            'unblockRecommendation': Method(self._unblockRecommendation, middleware),
            'unregisterUserAndDevice': Method(self._unregisterUserAndDevice, middleware),
            'updateApnsDeviceToken': Method(self._updateApnsDeviceToken, middleware),
            'updateBuddySetting': Method(self._updateBuddySetting, middleware),
            'updateC2DMRegistrationId': Method(self._updateC2DMRegistrationId, middleware),
            'updateContactSetting': Method(self._updateContactSetting, middleware),
            'updateCustomModeSettings': Method(self._updateCustomModeSettings, middleware),
            'updateDeviceInfo': Method(self._updateDeviceInfo, middleware),
            'updateGroup': Method(self._updateGroup, middleware),
            'updateNotificationToken': Method(self._updateNotificationToken, middleware),
            'updateNotificationTokenWithBytes': Method(self._updateNotificationTokenWithBytes, middleware),
            'updateProfile': Method(self._updateProfile, middleware),
            'updateProfileAttribute': Method(self._updateProfileAttribute, middleware),
            'updateRegion': Method(self._updateRegion, middleware),
            'updateSettings': Method(self._updateSettings, middleware),
            'updateSettings2': Method(self._updateSettings2, middleware),
            'updateSettingsAttribute': Method(self._updateSettingsAttribute, middleware),
            'updateSettingsAttributes': Method(self._updateSettingsAttributes, middleware),
            'verifyIdentityCredential': Method(self._verifyIdentityCredential, middleware),
            'verifyIdentityCredentialWithResult': Method(self._verifyIdentityCredentialWithResult, middleware),
            'verifyPhone': Method(self._verifyPhone, middleware),
            'verifyQrcode': Method(self._verifyQrcode, middleware),
        }

    def getChatRoomAnnouncementsBulk(self, ctx, chatRoomMids):
        """
        Args:
            ctx: FContext
            chatRoomMids: list of string
        """
        return self._methods['getChatRoomAnnouncementsBulk']([ctx, chatRoomMids])

    def _getChatRoomAnnouncementsBulk(self, ctx, chatRoomMids):
        self._send_getChatRoomAnnouncementsBulk(ctx, chatRoomMids)
        return self._recv_getChatRoomAnnouncementsBulk(ctx)

    def _send_getChatRoomAnnouncementsBulk(self, ctx, chatRoomMids):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getChatRoomAnnouncementsBulk', TMessageType.CALL, 0)
            args = getChatRoomAnnouncementsBulk_args()
            args.chatRoomMids = chatRoomMids
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getChatRoomAnnouncementsBulk(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getChatRoomAnnouncementsBulk_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getChatRoomAnnouncementsBulk failed: unknown result")
        raise x

    def getChatRoomAnnouncements(self, ctx, chatRoomMid):
        """
        Args:
            ctx: FContext
            chatRoomMid: string
        """
        return self._methods['getChatRoomAnnouncements']([ctx, chatRoomMid])

    def _getChatRoomAnnouncements(self, ctx, chatRoomMid):
        self._send_getChatRoomAnnouncements(ctx, chatRoomMid)
        return self._recv_getChatRoomAnnouncements(ctx)

    def _send_getChatRoomAnnouncements(self, ctx, chatRoomMid):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getChatRoomAnnouncements', TMessageType.CALL, 0)
            args = getChatRoomAnnouncements_args()
            args.chatRoomMid = chatRoomMid
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getChatRoomAnnouncements(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getChatRoomAnnouncements_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getChatRoomAnnouncements failed: unknown result")
        raise x

    def createChatRoomAnnouncement(self, ctx, reqSeq, chatRoomMid, type, contents):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            chatRoomMid: string
            type: ChatRoomAnnouncementType
            contents: ChatRoomAnnouncementContents
        """
        return self._methods['createChatRoomAnnouncement']([ctx, reqSeq, chatRoomMid, type, contents])

    def _createChatRoomAnnouncement(self, ctx, reqSeq, chatRoomMid, type, contents):
        self._send_createChatRoomAnnouncement(ctx, reqSeq, chatRoomMid, type, contents)
        return self._recv_createChatRoomAnnouncement(ctx)

    def _send_createChatRoomAnnouncement(self, ctx, reqSeq, chatRoomMid, type, contents):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('createChatRoomAnnouncement', TMessageType.CALL, 0)
            args = createChatRoomAnnouncement_args()
            args.reqSeq = reqSeq
            args.chatRoomMid = chatRoomMid
            args.type = type
            args.contents = contents
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_createChatRoomAnnouncement(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = createChatRoomAnnouncement_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "createChatRoomAnnouncement failed: unknown result")
        raise x

    def removeChatRoomAnnouncement(self, ctx, reqSeq, chatRoomMid, announcementSeq):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            chatRoomMid: string
            announcementSeq: int (signed 64 bits)
        """
        return self._methods['removeChatRoomAnnouncement']([ctx, reqSeq, chatRoomMid, announcementSeq])

    def _removeChatRoomAnnouncement(self, ctx, reqSeq, chatRoomMid, announcementSeq):
        self._send_removeChatRoomAnnouncement(ctx, reqSeq, chatRoomMid, announcementSeq)
        self._recv_removeChatRoomAnnouncement(ctx)

    def _send_removeChatRoomAnnouncement(self, ctx, reqSeq, chatRoomMid, announcementSeq):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('removeChatRoomAnnouncement', TMessageType.CALL, 0)
            args = removeChatRoomAnnouncement_args()
            args.reqSeq = reqSeq
            args.chatRoomMid = chatRoomMid
            args.announcementSeq = announcementSeq
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_removeChatRoomAnnouncement(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = removeChatRoomAnnouncement_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def unsendMessage(self, ctx, seq, messageId):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            messageId: string
        """
        return self._methods['unsendMessage']([ctx, seq, messageId])

    def _unsendMessage(self, ctx, seq, messageId):
        self._send_unsendMessage(ctx, seq, messageId)
        self._recv_unsendMessage(ctx)

    def _send_unsendMessage(self, ctx, seq, messageId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('unsendMessage', TMessageType.CALL, 0)
            args = unsendMessage_args()
            args.seq = seq
            args.messageId = messageId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_unsendMessage(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = unsendMessage_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def getGroupWithoutMembers(self, ctx, groupId):
        """
        Args:
            ctx: FContext
            groupId: string
        """
        return self._methods['getGroupWithoutMembers']([ctx, groupId])

    def _getGroupWithoutMembers(self, ctx, groupId):
        self._send_getGroupWithoutMembers(ctx, groupId)
        return self._recv_getGroupWithoutMembers(ctx)

    def _send_getGroupWithoutMembers(self, ctx, groupId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getGroupWithoutMembers', TMessageType.CALL, 0)
            args = getGroupWithoutMembers_args()
            args.groupId = groupId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getGroupWithoutMembers(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getGroupWithoutMembers_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getGroupWithoutMembers failed: unknown result")
        raise x

    def requestResendMessage(self, ctx, reqSeq, senderMid, messageId):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            senderMid: string
            messageId: string
        """
        return self._methods['requestResendMessage']([ctx, reqSeq, senderMid, messageId])

    def _requestResendMessage(self, ctx, reqSeq, senderMid, messageId):
        self._send_requestResendMessage(ctx, reqSeq, senderMid, messageId)
        self._recv_requestResendMessage(ctx)

    def _send_requestResendMessage(self, ctx, reqSeq, senderMid, messageId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('requestResendMessage', TMessageType.CALL, 0)
            args = requestResendMessage_args()
            args.reqSeq = reqSeq
            args.senderMid = senderMid
            args.messageId = messageId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_requestResendMessage(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = requestResendMessage_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def respondResendMessage(self, ctx, reqSeq, receiverMid, originalMessageId, resendMessage, errorCode):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            receiverMid: string
            originalMessageId: string
            resendMessage: Message
            errorCode: ErrorCode
        """
        return self._methods['respondResendMessage']([ctx, reqSeq, receiverMid, originalMessageId, resendMessage, errorCode])

    def _respondResendMessage(self, ctx, reqSeq, receiverMid, originalMessageId, resendMessage, errorCode):
        self._send_respondResendMessage(ctx, reqSeq, receiverMid, originalMessageId, resendMessage, errorCode)
        self._recv_respondResendMessage(ctx)

    def _send_respondResendMessage(self, ctx, reqSeq, receiverMid, originalMessageId, resendMessage, errorCode):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('respondResendMessage', TMessageType.CALL, 0)
            args = respondResendMessage_args()
            args.reqSeq = reqSeq
            args.receiverMid = receiverMid
            args.originalMessageId = originalMessageId
            args.resendMessage = resendMessage
            args.errorCode = errorCode
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_respondResendMessage(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = respondResendMessage_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def acceptGroupInvitation(self, ctx, reqSeq, groupId):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            groupId: string
        """
        return self._methods['acceptGroupInvitation']([ctx, reqSeq, groupId])

    def _acceptGroupInvitation(self, ctx, reqSeq, groupId):
        self._send_acceptGroupInvitation(ctx, reqSeq, groupId)
        self._recv_acceptGroupInvitation(ctx)

    def _send_acceptGroupInvitation(self, ctx, reqSeq, groupId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('acceptGroupInvitation', TMessageType.CALL, 0)
            args = acceptGroupInvitation_args()
            args.reqSeq = reqSeq
            args.groupId = groupId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_acceptGroupInvitation(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = acceptGroupInvitation_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def acceptGroupInvitationByTicket(self, ctx, reqSeq, GroupMid, ticketId):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            GroupMid: string
            ticketId: string
        """
        return self._methods['acceptGroupInvitationByTicket']([ctx, reqSeq, GroupMid, ticketId])

    def _acceptGroupInvitationByTicket(self, ctx, reqSeq, GroupMid, ticketId):
        self._send_acceptGroupInvitationByTicket(ctx, reqSeq, GroupMid, ticketId)
        self._recv_acceptGroupInvitationByTicket(ctx)

    def _send_acceptGroupInvitationByTicket(self, ctx, reqSeq, GroupMid, ticketId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('acceptGroupInvitationByTicket', TMessageType.CALL, 0)
            args = acceptGroupInvitationByTicket_args()
            args.reqSeq = reqSeq
            args.GroupMid = GroupMid
            args.ticketId = ticketId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_acceptGroupInvitationByTicket(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = acceptGroupInvitationByTicket_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def acceptProximityMatches(self, ctx, sessionId, ids):
        """
        Args:
            ctx: FContext
            sessionId: string
            ids: set of string
        """
        return self._methods['acceptProximityMatches']([ctx, sessionId, ids])

    def _acceptProximityMatches(self, ctx, sessionId, ids):
        self._send_acceptProximityMatches(ctx, sessionId, ids)
        self._recv_acceptProximityMatches(ctx)

    def _send_acceptProximityMatches(self, ctx, sessionId, ids):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('acceptProximityMatches', TMessageType.CALL, 0)
            args = acceptProximityMatches_args()
            args.sessionId = sessionId
            args.ids = ids
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_acceptProximityMatches(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = acceptProximityMatches_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def acquireCallRoute(self, ctx, to):
        """
        Args:
            ctx: FContext
            to: string
        """
        return self._methods['acquireCallRoute']([ctx, to])

    def _acquireCallRoute(self, ctx, to):
        self._send_acquireCallRoute(ctx, to)
        return self._recv_acquireCallRoute(ctx)

    def _send_acquireCallRoute(self, ctx, to):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('acquireCallRoute', TMessageType.CALL, 0)
            args = acquireCallRoute_args()
            args.to = to
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_acquireCallRoute(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = acquireCallRoute_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "acquireCallRoute failed: unknown result")
        raise x

    def acquireCallTicket(self, ctx, to):
        """
        Args:
            ctx: FContext
            to: string
        """
        return self._methods['acquireCallTicket']([ctx, to])

    def _acquireCallTicket(self, ctx, to):
        self._send_acquireCallTicket(ctx, to)
        return self._recv_acquireCallTicket(ctx)

    def _send_acquireCallTicket(self, ctx, to):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('acquireCallTicket', TMessageType.CALL, 0)
            args = acquireCallTicket_args()
            args.to = to
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_acquireCallTicket(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = acquireCallTicket_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "acquireCallTicket failed: unknown result")
        raise x

    def acquireEncryptedAccessToken(self, ctx, featureType):
        """
        Args:
            ctx: FContext
            featureType: FeatureType
        """
        return self._methods['acquireEncryptedAccessToken']([ctx, featureType])

    def _acquireEncryptedAccessToken(self, ctx, featureType):
        self._send_acquireEncryptedAccessToken(ctx, featureType)
        return self._recv_acquireEncryptedAccessToken(ctx)

    def _send_acquireEncryptedAccessToken(self, ctx, featureType):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('acquireEncryptedAccessToken', TMessageType.CALL, 0)
            args = acquireEncryptedAccessToken_args()
            args.featureType = featureType
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_acquireEncryptedAccessToken(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = acquireEncryptedAccessToken_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "acquireEncryptedAccessToken failed: unknown result")
        raise x

    def addSnsId(self, ctx, snsIdType, snsAccessToken):
        """
        Args:
            ctx: FContext
            snsIdType: SnsIdType
            snsAccessToken: string
        """
        return self._methods['addSnsId']([ctx, snsIdType, snsAccessToken])

    def _addSnsId(self, ctx, snsIdType, snsAccessToken):
        self._send_addSnsId(ctx, snsIdType, snsAccessToken)
        return self._recv_addSnsId(ctx)

    def _send_addSnsId(self, ctx, snsIdType, snsAccessToken):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('addSnsId', TMessageType.CALL, 0)
            args = addSnsId_args()
            args.snsIdType = snsIdType
            args.snsAccessToken = snsAccessToken
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_addSnsId(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = addSnsId_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "addSnsId failed: unknown result")
        raise x

    def blockContact(self, ctx, reqSeq, id):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            id: string
        """
        return self._methods['blockContact']([ctx, reqSeq, id])

    def _blockContact(self, ctx, reqSeq, id):
        self._send_blockContact(ctx, reqSeq, id)
        self._recv_blockContact(ctx)

    def _send_blockContact(self, ctx, reqSeq, id):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('blockContact', TMessageType.CALL, 0)
            args = blockContact_args()
            args.reqSeq = reqSeq
            args.id = id
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_blockContact(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = blockContact_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def blockRecommendation(self, ctx, reqSeq, id):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            id: string
        """
        return self._methods['blockRecommendation']([ctx, reqSeq, id])

    def _blockRecommendation(self, ctx, reqSeq, id):
        self._send_blockRecommendation(ctx, reqSeq, id)
        self._recv_blockRecommendation(ctx)

    def _send_blockRecommendation(self, ctx, reqSeq, id):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('blockRecommendation', TMessageType.CALL, 0)
            args = blockRecommendation_args()
            args.reqSeq = reqSeq
            args.id = id
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_blockRecommendation(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = blockRecommendation_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def cancelGroupInvitation(self, ctx, reqSeq, groupId, contactIds):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            groupId: string
            contactIds: list of string
        """
        return self._methods['cancelGroupInvitation']([ctx, reqSeq, groupId, contactIds])

    def _cancelGroupInvitation(self, ctx, reqSeq, groupId, contactIds):
        self._send_cancelGroupInvitation(ctx, reqSeq, groupId, contactIds)
        self._recv_cancelGroupInvitation(ctx)

    def _send_cancelGroupInvitation(self, ctx, reqSeq, groupId, contactIds):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('cancelGroupInvitation', TMessageType.CALL, 0)
            args = cancelGroupInvitation_args()
            args.reqSeq = reqSeq
            args.groupId = groupId
            args.contactIds = contactIds
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_cancelGroupInvitation(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = cancelGroupInvitation_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def changeVerificationMethod(self, ctx, sessionId, method):
        """
        Args:
            ctx: FContext
            sessionId: string
            method: VerificationMethod
        """
        return self._methods['changeVerificationMethod']([ctx, sessionId, method])

    def _changeVerificationMethod(self, ctx, sessionId, method):
        self._send_changeVerificationMethod(ctx, sessionId, method)
        return self._recv_changeVerificationMethod(ctx)

    def _send_changeVerificationMethod(self, ctx, sessionId, method):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('changeVerificationMethod', TMessageType.CALL, 0)
            args = changeVerificationMethod_args()
            args.sessionId = sessionId
            args.method = method
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_changeVerificationMethod(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = changeVerificationMethod_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "changeVerificationMethod failed: unknown result")
        raise x

    def clearIdentityCredential(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['clearIdentityCredential']([ctx])

    def _clearIdentityCredential(self, ctx):
        self._send_clearIdentityCredential(ctx)
        self._recv_clearIdentityCredential(ctx)

    def _send_clearIdentityCredential(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('clearIdentityCredential', TMessageType.CALL, 0)
            args = clearIdentityCredential_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_clearIdentityCredential(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = clearIdentityCredential_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def clearMessageBox(self, ctx, channelId, messageBoxId):
        """
        Args:
            ctx: FContext
            channelId: string
            messageBoxId: string
        """
        return self._methods['clearMessageBox']([ctx, channelId, messageBoxId])

    def _clearMessageBox(self, ctx, channelId, messageBoxId):
        self._send_clearMessageBox(ctx, channelId, messageBoxId)
        self._recv_clearMessageBox(ctx)

    def _send_clearMessageBox(self, ctx, channelId, messageBoxId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('clearMessageBox', TMessageType.CALL, 0)
            args = clearMessageBox_args()
            args.channelId = channelId
            args.messageBoxId = messageBoxId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_clearMessageBox(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = clearMessageBox_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def closeProximityMatch(self, ctx, sessionId):
        """
        Args:
            ctx: FContext
            sessionId: string
        """
        return self._methods['closeProximityMatch']([ctx, sessionId])

    def _closeProximityMatch(self, ctx, sessionId):
        self._send_closeProximityMatch(ctx, sessionId)
        self._recv_closeProximityMatch(ctx)

    def _send_closeProximityMatch(self, ctx, sessionId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('closeProximityMatch', TMessageType.CALL, 0)
            args = closeProximityMatch_args()
            args.sessionId = sessionId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_closeProximityMatch(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = closeProximityMatch_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def commitSendMessage(self, ctx, seq, messageId, receiverMids):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            messageId: string
            receiverMids: list of string
        """
        return self._methods['commitSendMessage']([ctx, seq, messageId, receiverMids])

    def _commitSendMessage(self, ctx, seq, messageId, receiverMids):
        self._send_commitSendMessage(ctx, seq, messageId, receiverMids)
        return self._recv_commitSendMessage(ctx)

    def _send_commitSendMessage(self, ctx, seq, messageId, receiverMids):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('commitSendMessage', TMessageType.CALL, 0)
            args = commitSendMessage_args()
            args.seq = seq
            args.messageId = messageId
            args.receiverMids = receiverMids
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_commitSendMessage(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = commitSendMessage_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "commitSendMessage failed: unknown result")
        raise x

    def commitSendMessages(self, ctx, seq, messageIds, receiverMids):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            messageIds: list of string
            receiverMids: list of string
        """
        return self._methods['commitSendMessages']([ctx, seq, messageIds, receiverMids])

    def _commitSendMessages(self, ctx, seq, messageIds, receiverMids):
        self._send_commitSendMessages(ctx, seq, messageIds, receiverMids)
        return self._recv_commitSendMessages(ctx)

    def _send_commitSendMessages(self, ctx, seq, messageIds, receiverMids):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('commitSendMessages', TMessageType.CALL, 0)
            args = commitSendMessages_args()
            args.seq = seq
            args.messageIds = messageIds
            args.receiverMids = receiverMids
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_commitSendMessages(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = commitSendMessages_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "commitSendMessages failed: unknown result")
        raise x

    def commitUpdateProfile(self, ctx, seq, attrs, receiverMids):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            attrs: list of ProfileAttribute
            receiverMids: list of string
        """
        return self._methods['commitUpdateProfile']([ctx, seq, attrs, receiverMids])

    def _commitUpdateProfile(self, ctx, seq, attrs, receiverMids):
        self._send_commitUpdateProfile(ctx, seq, attrs, receiverMids)
        return self._recv_commitUpdateProfile(ctx)

    def _send_commitUpdateProfile(self, ctx, seq, attrs, receiverMids):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('commitUpdateProfile', TMessageType.CALL, 0)
            args = commitUpdateProfile_args()
            args.seq = seq
            args.attrs = attrs
            args.receiverMids = receiverMids
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_commitUpdateProfile(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = commitUpdateProfile_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "commitUpdateProfile failed: unknown result")
        raise x

    def confirmEmail(self, ctx, verifier, pinCode):
        """
        Args:
            ctx: FContext
            verifier: string
            pinCode: string
        """
        return self._methods['confirmEmail']([ctx, verifier, pinCode])

    def _confirmEmail(self, ctx, verifier, pinCode):
        self._send_confirmEmail(ctx, verifier, pinCode)
        self._recv_confirmEmail(ctx)

    def _send_confirmEmail(self, ctx, verifier, pinCode):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('confirmEmail', TMessageType.CALL, 0)
            args = confirmEmail_args()
            args.verifier = verifier
            args.pinCode = pinCode
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_confirmEmail(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = confirmEmail_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def createGroup(self, ctx, seq, name, contactIds):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            name: string
            contactIds: list of string
        """
        return self._methods['createGroup']([ctx, seq, name, contactIds])

    def _createGroup(self, ctx, seq, name, contactIds):
        self._send_createGroup(ctx, seq, name, contactIds)
        return self._recv_createGroup(ctx)

    def _send_createGroup(self, ctx, seq, name, contactIds):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('createGroup', TMessageType.CALL, 0)
            args = createGroup_args()
            args.seq = seq
            args.name = name
            args.contactIds = contactIds
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_createGroup(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = createGroup_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "createGroup failed: unknown result")
        raise x

    def createQrcodeBase64Image(self, ctx, url, characterSet, imageSize, x, y, width, height):
        """
        Args:
            ctx: FContext
            url: string
            characterSet: string
            imageSize: int (signed 32 bits)
            x: int (signed 32 bits)
            y: int (signed 32 bits)
            width: int (signed 32 bits)
            height: int (signed 32 bits)
        """
        return self._methods['createQrcodeBase64Image']([ctx, url, characterSet, imageSize, x, y, width, height])

    def _createQrcodeBase64Image(self, ctx, url, characterSet, imageSize, x, y, width, height):
        self._send_createQrcodeBase64Image(ctx, url, characterSet, imageSize, x, y, width, height)
        return self._recv_createQrcodeBase64Image(ctx)

    def _send_createQrcodeBase64Image(self, ctx, url, characterSet, imageSize, x, y, width, height):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('createQrcodeBase64Image', TMessageType.CALL, 0)
            args = createQrcodeBase64Image_args()
            args.url = url
            args.characterSet = characterSet
            args.imageSize = imageSize
            args.x = x
            args.y = y
            args.width = width
            args.height = height
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_createQrcodeBase64Image(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = createQrcodeBase64Image_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "createQrcodeBase64Image failed: unknown result")
        raise x

    def createRoom(self, ctx, reqSeq, contactIds):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            contactIds: list of string
        """
        return self._methods['createRoom']([ctx, reqSeq, contactIds])

    def _createRoom(self, ctx, reqSeq, contactIds):
        self._send_createRoom(ctx, reqSeq, contactIds)
        return self._recv_createRoom(ctx)

    def _send_createRoom(self, ctx, reqSeq, contactIds):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('createRoom', TMessageType.CALL, 0)
            args = createRoom_args()
            args.reqSeq = reqSeq
            args.contactIds = contactIds
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_createRoom(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = createRoom_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "createRoom failed: unknown result")
        raise x

    def createSession(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['createSession']([ctx])

    def _createSession(self, ctx):
        self._send_createSession(ctx)
        return self._recv_createSession(ctx)

    def _send_createSession(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('createSession', TMessageType.CALL, 0)
            args = createSession_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_createSession(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = createSession_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "createSession failed: unknown result")
        raise x

    def fetchAnnouncements(self, ctx, lastFetchedIndex):
        """
        Args:
            ctx: FContext
            lastFetchedIndex: int (signed 32 bits)
        """
        return self._methods['fetchAnnouncements']([ctx, lastFetchedIndex])

    def _fetchAnnouncements(self, ctx, lastFetchedIndex):
        self._send_fetchAnnouncements(ctx, lastFetchedIndex)
        return self._recv_fetchAnnouncements(ctx)

    def _send_fetchAnnouncements(self, ctx, lastFetchedIndex):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('fetchAnnouncements', TMessageType.CALL, 0)
            args = fetchAnnouncements_args()
            args.lastFetchedIndex = lastFetchedIndex
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_fetchAnnouncements(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = fetchAnnouncements_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "fetchAnnouncements failed: unknown result")
        raise x

    def fetchMessages(self, ctx, localTs, count):
        """
        Args:
            ctx: FContext
            localTs: int (signed 64 bits)
            count: int (signed 32 bits)
        """
        return self._methods['fetchMessages']([ctx, localTs, count])

    def _fetchMessages(self, ctx, localTs, count):
        self._send_fetchMessages(ctx, localTs, count)
        return self._recv_fetchMessages(ctx)

    def _send_fetchMessages(self, ctx, localTs, count):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('fetchMessages', TMessageType.CALL, 0)
            args = fetchMessages_args()
            args.localTs = localTs
            args.count = count
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_fetchMessages(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = fetchMessages_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "fetchMessages failed: unknown result")
        raise x

    def fetchOperations(self, ctx, localRev, count):
        """
        Args:
            ctx: FContext
            localRev: int (signed 64 bits)
            count: int (signed 32 bits)
        """
        return self._methods['fetchOperations']([ctx, localRev, count])

    def _fetchOperations(self, ctx, localRev, count):
        self._send_fetchOperations(ctx, localRev, count)
        return self._recv_fetchOperations(ctx)

    def _send_fetchOperations(self, ctx, localRev, count):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('fetchOperations', TMessageType.CALL, 0)
            args = fetchOperations_args()
            args.localRev = localRev
            args.count = count
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_fetchOperations(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = fetchOperations_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "fetchOperations failed: unknown result")
        raise x

    def fetchOps(self, ctx, localRev, count, globalRev, individualRev):
        """
        Args:
            ctx: FContext
            localRev: int (signed 64 bits)
            count: int (signed 32 bits)
            globalRev: int (signed 64 bits)
            individualRev: int (signed 64 bits)
        """
        return self._methods['fetchOps']([ctx, localRev, count, globalRev, individualRev])

    def _fetchOps(self, ctx, localRev, count, globalRev, individualRev):
        self._send_fetchOps(ctx, localRev, count, globalRev, individualRev)
        return self._recv_fetchOps(ctx)

    def _send_fetchOps(self, ctx, localRev, count, globalRev, individualRev):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('fetchOps', TMessageType.CALL, 0)
            args = fetchOps_args()
            args.localRev = localRev
            args.count = count
            args.globalRev = globalRev
            args.individualRev = individualRev
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_fetchOps(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = fetchOps_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "fetchOps failed: unknown result")
        raise x

    def findAndAddContactsByEmail(self, ctx, reqSeq, emails):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            emails: set of string
        """
        return self._methods['findAndAddContactsByEmail']([ctx, reqSeq, emails])

    def _findAndAddContactsByEmail(self, ctx, reqSeq, emails):
        self._send_findAndAddContactsByEmail(ctx, reqSeq, emails)
        return self._recv_findAndAddContactsByEmail(ctx)

    def _send_findAndAddContactsByEmail(self, ctx, reqSeq, emails):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('findAndAddContactsByEmail', TMessageType.CALL, 0)
            args = findAndAddContactsByEmail_args()
            args.reqSeq = reqSeq
            args.emails = emails
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_findAndAddContactsByEmail(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = findAndAddContactsByEmail_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "findAndAddContactsByEmail failed: unknown result")
        raise x

    def findAndAddContactsByMid(self, ctx, reqSeq, mid, type, reference):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            mid: string
            type: ContactType
            reference: string
        """
        return self._methods['findAndAddContactsByMid']([ctx, reqSeq, mid, type, reference])

    def _findAndAddContactsByMid(self, ctx, reqSeq, mid, type, reference):
        self._send_findAndAddContactsByMid(ctx, reqSeq, mid, type, reference)
        return self._recv_findAndAddContactsByMid(ctx)

    def _send_findAndAddContactsByMid(self, ctx, reqSeq, mid, type, reference):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('findAndAddContactsByMid', TMessageType.CALL, 0)
            args = findAndAddContactsByMid_args()
            args.reqSeq = reqSeq
            args.mid = mid
            args.type = type
            args.reference = reference
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_findAndAddContactsByMid(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = findAndAddContactsByMid_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "findAndAddContactsByMid failed: unknown result")
        raise x

    def findGroupByTicketV2(self, ctx, ticketId):
        """
        Args:
            ctx: FContext
            ticketId: string
        """
        return self._methods['findGroupByTicketV2']([ctx, ticketId])

    def _findGroupByTicketV2(self, ctx, ticketId):
        self._send_findGroupByTicketV2(ctx, ticketId)
        return self._recv_findGroupByTicketV2(ctx)

    def _send_findGroupByTicketV2(self, ctx, ticketId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('findGroupByTicketV2', TMessageType.CALL, 0)
            args = findGroupByTicketV2_args()
            args.ticketId = ticketId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_findGroupByTicketV2(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = findGroupByTicketV2_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "findGroupByTicketV2 failed: unknown result")
        raise x

    def findAndAddContactsByPhone(self, ctx, reqSeq, phones):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            phones: set of string
        """
        return self._methods['findAndAddContactsByPhone']([ctx, reqSeq, phones])

    def _findAndAddContactsByPhone(self, ctx, reqSeq, phones):
        self._send_findAndAddContactsByPhone(ctx, reqSeq, phones)
        return self._recv_findAndAddContactsByPhone(ctx)

    def _send_findAndAddContactsByPhone(self, ctx, reqSeq, phones):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('findAndAddContactsByPhone', TMessageType.CALL, 0)
            args = findAndAddContactsByPhone_args()
            args.reqSeq = reqSeq
            args.phones = phones
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_findAndAddContactsByPhone(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = findAndAddContactsByPhone_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "findAndAddContactsByPhone failed: unknown result")
        raise x

    def getFriendRequests(self, ctx, direction, lastSeenSeqId):
        """
        Args:
            ctx: FContext
            direction: FriendRequestDirection
            lastSeenSeqId: int (signed 64 bits)
        """
        return self._methods['getFriendRequests']([ctx, direction, lastSeenSeqId])

    def _getFriendRequests(self, ctx, direction, lastSeenSeqId):
        self._send_getFriendRequests(ctx, direction, lastSeenSeqId)
        return self._recv_getFriendRequests(ctx)

    def _send_getFriendRequests(self, ctx, direction, lastSeenSeqId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getFriendRequests', TMessageType.CALL, 0)
            args = getFriendRequests_args()
            args.direction = direction
            args.lastSeenSeqId = lastSeenSeqId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getFriendRequests(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getFriendRequests_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getFriendRequests failed: unknown result")
        raise x

    def removeFriendRequest(self, ctx, direction, midOrEMid):
        """
        Args:
            ctx: FContext
            direction: FriendRequestDirection
            midOrEMid: string
        """
        return self._methods['removeFriendRequest']([ctx, direction, midOrEMid])

    def _removeFriendRequest(self, ctx, direction, midOrEMid):
        self._send_removeFriendRequest(ctx, direction, midOrEMid)
        self._recv_removeFriendRequest(ctx)

    def _send_removeFriendRequest(self, ctx, direction, midOrEMid):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('removeFriendRequest', TMessageType.CALL, 0)
            args = removeFriendRequest_args()
            args.direction = direction
            args.midOrEMid = midOrEMid
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_removeFriendRequest(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = removeFriendRequest_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def findAndAddContactsByUserid(self, ctx, reqSeq, userid):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            userid: string
        """
        return self._methods['findAndAddContactsByUserid']([ctx, reqSeq, userid])

    def _findAndAddContactsByUserid(self, ctx, reqSeq, userid):
        self._send_findAndAddContactsByUserid(ctx, reqSeq, userid)
        return self._recv_findAndAddContactsByUserid(ctx)

    def _send_findAndAddContactsByUserid(self, ctx, reqSeq, userid):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('findAndAddContactsByUserid', TMessageType.CALL, 0)
            args = findAndAddContactsByUserid_args()
            args.reqSeq = reqSeq
            args.userid = userid
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_findAndAddContactsByUserid(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = findAndAddContactsByUserid_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "findAndAddContactsByUserid failed: unknown result")
        raise x

    def findContactByUserid(self, ctx, userid):
        """
        Args:
            ctx: FContext
            userid: string
        """
        return self._methods['findContactByUserid']([ctx, userid])

    def _findContactByUserid(self, ctx, userid):
        self._send_findContactByUserid(ctx, userid)
        return self._recv_findContactByUserid(ctx)

    def _send_findContactByUserid(self, ctx, userid):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('findContactByUserid', TMessageType.CALL, 0)
            args = findContactByUserid_args()
            args.userid = userid
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_findContactByUserid(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = findContactByUserid_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "findContactByUserid failed: unknown result")
        raise x

    def findContactByUserTicket(self, ctx, ticketIdWithTag):
        """
        Args:
            ctx: FContext
            ticketIdWithTag: string
        """
        return self._methods['findContactByUserTicket']([ctx, ticketIdWithTag])

    def _findContactByUserTicket(self, ctx, ticketIdWithTag):
        self._send_findContactByUserTicket(ctx, ticketIdWithTag)
        return self._recv_findContactByUserTicket(ctx)

    def _send_findContactByUserTicket(self, ctx, ticketIdWithTag):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('findContactByUserTicket', TMessageType.CALL, 0)
            args = findContactByUserTicket_args()
            args.ticketIdWithTag = ticketIdWithTag
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_findContactByUserTicket(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = findContactByUserTicket_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "findContactByUserTicket failed: unknown result")
        raise x

    def findContactsByEmail(self, ctx, emails):
        """
        Args:
            ctx: FContext
            emails: set of string
        """
        return self._methods['findContactsByEmail']([ctx, emails])

    def _findContactsByEmail(self, ctx, emails):
        self._send_findContactsByEmail(ctx, emails)
        return self._recv_findContactsByEmail(ctx)

    def _send_findContactsByEmail(self, ctx, emails):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('findContactsByEmail', TMessageType.CALL, 0)
            args = findContactsByEmail_args()
            args.emails = emails
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_findContactsByEmail(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = findContactsByEmail_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "findContactsByEmail failed: unknown result")
        raise x

    def findContactsByPhone(self, ctx, phones):
        """
        Args:
            ctx: FContext
            phones: set of string
        """
        return self._methods['findContactsByPhone']([ctx, phones])

    def _findContactsByPhone(self, ctx, phones):
        self._send_findContactsByPhone(ctx, phones)
        return self._recv_findContactsByPhone(ctx)

    def _send_findContactsByPhone(self, ctx, phones):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('findContactsByPhone', TMessageType.CALL, 0)
            args = findContactsByPhone_args()
            args.phones = phones
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_findContactsByPhone(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = findContactsByPhone_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "findContactsByPhone failed: unknown result")
        raise x

    def findSnsIdUserStatus(self, ctx, snsIdType, snsAccessToken, udidHash):
        """
        Args:
            ctx: FContext
            snsIdType: SnsIdType
            snsAccessToken: string
            udidHash: string
        """
        return self._methods['findSnsIdUserStatus']([ctx, snsIdType, snsAccessToken, udidHash])

    def _findSnsIdUserStatus(self, ctx, snsIdType, snsAccessToken, udidHash):
        self._send_findSnsIdUserStatus(ctx, snsIdType, snsAccessToken, udidHash)
        return self._recv_findSnsIdUserStatus(ctx)

    def _send_findSnsIdUserStatus(self, ctx, snsIdType, snsAccessToken, udidHash):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('findSnsIdUserStatus', TMessageType.CALL, 0)
            args = findSnsIdUserStatus_args()
            args.snsIdType = snsIdType
            args.snsAccessToken = snsAccessToken
            args.udidHash = udidHash
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_findSnsIdUserStatus(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = findSnsIdUserStatus_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "findSnsIdUserStatus failed: unknown result")
        raise x

    def finishUpdateVerification(self, ctx, sessionId):
        """
        Args:
            ctx: FContext
            sessionId: string
        """
        return self._methods['finishUpdateVerification']([ctx, sessionId])

    def _finishUpdateVerification(self, ctx, sessionId):
        self._send_finishUpdateVerification(ctx, sessionId)
        self._recv_finishUpdateVerification(ctx)

    def _send_finishUpdateVerification(self, ctx, sessionId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('finishUpdateVerification', TMessageType.CALL, 0)
            args = finishUpdateVerification_args()
            args.sessionId = sessionId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_finishUpdateVerification(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = finishUpdateVerification_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def generateUserTicket(self, ctx, expirationTime, maxUseCount):
        """
        Args:
            ctx: FContext
            expirationTime: int (signed 64 bits)
            maxUseCount: int (signed 32 bits)
        """
        return self._methods['generateUserTicket']([ctx, expirationTime, maxUseCount])

    def _generateUserTicket(self, ctx, expirationTime, maxUseCount):
        self._send_generateUserTicket(ctx, expirationTime, maxUseCount)
        return self._recv_generateUserTicket(ctx)

    def _send_generateUserTicket(self, ctx, expirationTime, maxUseCount):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('generateUserTicket', TMessageType.CALL, 0)
            args = generateUserTicket_args()
            args.expirationTime = expirationTime
            args.maxUseCount = maxUseCount
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_generateUserTicket(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = generateUserTicket_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "generateUserTicket failed: unknown result")
        raise x

    def destroyMessage(self, ctx, seq, chatId, messageId, sessionId):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            chatId: string
            messageId: string
            sessionId: int (signed 64 bits)
        """
        return self._methods['destroyMessage']([ctx, seq, chatId, messageId, sessionId])

    def _destroyMessage(self, ctx, seq, chatId, messageId, sessionId):
        self._send_destroyMessage(ctx, seq, chatId, messageId, sessionId)
        self._recv_destroyMessage(ctx)

    def _send_destroyMessage(self, ctx, seq, chatId, messageId, sessionId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('destroyMessage', TMessageType.CALL, 0)
            args = destroyMessage_args()
            args.seq = seq
            args.chatId = chatId
            args.messageId = messageId
            args.sessionId = sessionId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_destroyMessage(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = destroyMessage_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def getAcceptedProximityMatches(self, ctx, sessionId):
        """
        Args:
            ctx: FContext
            sessionId: string
        """
        return self._methods['getAcceptedProximityMatches']([ctx, sessionId])

    def _getAcceptedProximityMatches(self, ctx, sessionId):
        self._send_getAcceptedProximityMatches(ctx, sessionId)
        return self._recv_getAcceptedProximityMatches(ctx)

    def _send_getAcceptedProximityMatches(self, ctx, sessionId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getAcceptedProximityMatches', TMessageType.CALL, 0)
            args = getAcceptedProximityMatches_args()
            args.sessionId = sessionId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getAcceptedProximityMatches(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getAcceptedProximityMatches_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getAcceptedProximityMatches failed: unknown result")
        raise x

    def getActiveBuddySubscriberIds(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getActiveBuddySubscriberIds']([ctx])

    def _getActiveBuddySubscriberIds(self, ctx):
        self._send_getActiveBuddySubscriberIds(ctx)
        return self._recv_getActiveBuddySubscriberIds(ctx)

    def _send_getActiveBuddySubscriberIds(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getActiveBuddySubscriberIds', TMessageType.CALL, 0)
            args = getActiveBuddySubscriberIds_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getActiveBuddySubscriberIds(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getActiveBuddySubscriberIds_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getActiveBuddySubscriberIds failed: unknown result")
        raise x

    def getAllContactIds(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getAllContactIds']([ctx])

    def _getAllContactIds(self, ctx):
        self._send_getAllContactIds(ctx)
        return self._recv_getAllContactIds(ctx)

    def _send_getAllContactIds(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getAllContactIds', TMessageType.CALL, 0)
            args = getAllContactIds_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getAllContactIds(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getAllContactIds_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getAllContactIds failed: unknown result")
        raise x

    def getAuthQrcode(self, ctx, keepLoggedIn, systemName):
        """
        Args:
            ctx: FContext
            keepLoggedIn: boolean
            systemName: string
        """
        return self._methods['getAuthQrcode']([ctx, keepLoggedIn, systemName])

    def _getAuthQrcode(self, ctx, keepLoggedIn, systemName):
        self._send_getAuthQrcode(ctx, keepLoggedIn, systemName)
        return self._recv_getAuthQrcode(ctx)

    def _send_getAuthQrcode(self, ctx, keepLoggedIn, systemName):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getAuthQrcode', TMessageType.CALL, 0)
            args = getAuthQrcode_args()
            args.keepLoggedIn = keepLoggedIn
            args.systemName = systemName
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getAuthQrcode(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getAuthQrcode_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getAuthQrcode failed: unknown result")
        raise x

    def getBlockedContactIds(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getBlockedContactIds']([ctx])

    def _getBlockedContactIds(self, ctx):
        self._send_getBlockedContactIds(ctx)
        return self._recv_getBlockedContactIds(ctx)

    def _send_getBlockedContactIds(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getBlockedContactIds', TMessageType.CALL, 0)
            args = getBlockedContactIds_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getBlockedContactIds(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getBlockedContactIds_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getBlockedContactIds failed: unknown result")
        raise x

    def registerWithPhoneNumber(self, ctx, sessionId, migrationPincodeSessionId):
        """
        Args:
            ctx: FContext
            sessionId: string
            migrationPincodeSessionId: string
        """
        return self._methods['registerWithPhoneNumber']([ctx, sessionId, migrationPincodeSessionId])

    def _registerWithPhoneNumber(self, ctx, sessionId, migrationPincodeSessionId):
        self._send_registerWithPhoneNumber(ctx, sessionId, migrationPincodeSessionId)
        return self._recv_registerWithPhoneNumber(ctx)

    def _send_registerWithPhoneNumber(self, ctx, sessionId, migrationPincodeSessionId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('registerWithPhoneNumber', TMessageType.CALL, 0)
            args = registerWithPhoneNumber_args()
            args.sessionId = sessionId
            args.migrationPincodeSessionId = migrationPincodeSessionId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_registerWithPhoneNumber(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = registerWithPhoneNumber_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "registerWithPhoneNumber failed: unknown result")
        raise x

    def registerWithPhoneNumberAndPassword(self, ctx, sessionId, keynm, encrypted):
        """
        Args:
            ctx: FContext
            sessionId: string
            keynm: string
            encrypted: string
        """
        return self._methods['registerWithPhoneNumberAndPassword']([ctx, sessionId, keynm, encrypted])

    def _registerWithPhoneNumberAndPassword(self, ctx, sessionId, keynm, encrypted):
        self._send_registerWithPhoneNumberAndPassword(ctx, sessionId, keynm, encrypted)
        return self._recv_registerWithPhoneNumberAndPassword(ctx)

    def _send_registerWithPhoneNumberAndPassword(self, ctx, sessionId, keynm, encrypted):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('registerWithPhoneNumberAndPassword', TMessageType.CALL, 0)
            args = registerWithPhoneNumberAndPassword_args()
            args.sessionId = sessionId
            args.keynm = keynm
            args.encrypted = encrypted
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_registerWithPhoneNumberAndPassword(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = registerWithPhoneNumberAndPassword_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "registerWithPhoneNumberAndPassword failed: unknown result")
        raise x

    def getAnalyticsInfo(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getAnalyticsInfo']([ctx])

    def _getAnalyticsInfo(self, ctx):
        self._send_getAnalyticsInfo(ctx)
        return self._recv_getAnalyticsInfo(ctx)

    def _send_getAnalyticsInfo(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getAnalyticsInfo', TMessageType.CALL, 0)
            args = getAnalyticsInfo_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getAnalyticsInfo(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getAnalyticsInfo_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getAnalyticsInfo failed: unknown result")
        raise x

    def reportClientStatistics(self, ctx, reqSeq, category, count):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            category: ReportCategory
            count: int (signed 32 bits)
        """
        return self._methods['reportClientStatistics']([ctx, reqSeq, category, count])

    def _reportClientStatistics(self, ctx, reqSeq, category, count):
        self._send_reportClientStatistics(ctx, reqSeq, category, count)
        self._recv_reportClientStatistics(ctx)

    def _send_reportClientStatistics(self, ctx, reqSeq, category, count):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('reportClientStatistics', TMessageType.CALL, 0)
            args = reportClientStatistics_args()
            args.reqSeq = reqSeq
            args.category = category
            args.count = count
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_reportClientStatistics(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = reportClientStatistics_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def verifyPhoneNumberForLogin(self, ctx, verifierFromPhone, pinCodeForPhone, verifierFromLogin):
        """
        Args:
            ctx: FContext
            verifierFromPhone: string
            pinCodeForPhone: string
            verifierFromLogin: string
        """
        return self._methods['verifyPhoneNumberForLogin']([ctx, verifierFromPhone, pinCodeForPhone, verifierFromLogin])

    def _verifyPhoneNumberForLogin(self, ctx, verifierFromPhone, pinCodeForPhone, verifierFromLogin):
        self._send_verifyPhoneNumberForLogin(ctx, verifierFromPhone, pinCodeForPhone, verifierFromLogin)
        return self._recv_verifyPhoneNumberForLogin(ctx)

    def _send_verifyPhoneNumberForLogin(self, ctx, verifierFromPhone, pinCodeForPhone, verifierFromLogin):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('verifyPhoneNumberForLogin', TMessageType.CALL, 0)
            args = verifyPhoneNumberForLogin_args()
            args.verifierFromPhone = verifierFromPhone
            args.pinCodeForPhone = pinCodeForPhone
            args.verifierFromLogin = verifierFromLogin
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_verifyPhoneNumberForLogin(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = verifyPhoneNumberForLogin_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "verifyPhoneNumberForLogin failed: unknown result")
        raise x

    def verifyPhoneNumber(self, ctx, sessionId, pinCode, udidHash, migrationPincodeSessionId, oldUdidHash):
        """
        Args:
            ctx: FContext
            sessionId: string
            pinCode: string
            udidHash: string
            migrationPincodeSessionId: string
            oldUdidHash: string
        """
        return self._methods['verifyPhoneNumber']([ctx, sessionId, pinCode, udidHash, migrationPincodeSessionId, oldUdidHash])

    def _verifyPhoneNumber(self, ctx, sessionId, pinCode, udidHash, migrationPincodeSessionId, oldUdidHash):
        self._send_verifyPhoneNumber(ctx, sessionId, pinCode, udidHash, migrationPincodeSessionId, oldUdidHash)
        return self._recv_verifyPhoneNumber(ctx)

    def _send_verifyPhoneNumber(self, ctx, sessionId, pinCode, udidHash, migrationPincodeSessionId, oldUdidHash):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('verifyPhoneNumber', TMessageType.CALL, 0)
            args = verifyPhoneNumber_args()
            args.sessionId = sessionId
            args.pinCode = pinCode
            args.udidHash = udidHash
            args.migrationPincodeSessionId = migrationPincodeSessionId
            args.oldUdidHash = oldUdidHash
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_verifyPhoneNumber(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = verifyPhoneNumber_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "verifyPhoneNumber failed: unknown result")
        raise x

    def getBlockedContactIdsByRange(self, ctx, start, count):
        """
        Args:
            ctx: FContext
            start: int (signed 32 bits)
            count: int (signed 32 bits)
        """
        return self._methods['getBlockedContactIdsByRange']([ctx, start, count])

    def _getBlockedContactIdsByRange(self, ctx, start, count):
        self._send_getBlockedContactIdsByRange(ctx, start, count)
        return self._recv_getBlockedContactIdsByRange(ctx)

    def _send_getBlockedContactIdsByRange(self, ctx, start, count):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getBlockedContactIdsByRange', TMessageType.CALL, 0)
            args = getBlockedContactIdsByRange_args()
            args.start = start
            args.count = count
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getBlockedContactIdsByRange(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getBlockedContactIdsByRange_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getBlockedContactIdsByRange failed: unknown result")
        raise x

    def getBlockedRecommendationIds(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getBlockedRecommendationIds']([ctx])

    def _getBlockedRecommendationIds(self, ctx):
        self._send_getBlockedRecommendationIds(ctx)
        return self._recv_getBlockedRecommendationIds(ctx)

    def _send_getBlockedRecommendationIds(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getBlockedRecommendationIds', TMessageType.CALL, 0)
            args = getBlockedRecommendationIds_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getBlockedRecommendationIds(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getBlockedRecommendationIds_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getBlockedRecommendationIds failed: unknown result")
        raise x

    def getBuddyBlockerIds(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getBuddyBlockerIds']([ctx])

    def _getBuddyBlockerIds(self, ctx):
        self._send_getBuddyBlockerIds(ctx)
        return self._recv_getBuddyBlockerIds(ctx)

    def _send_getBuddyBlockerIds(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getBuddyBlockerIds', TMessageType.CALL, 0)
            args = getBuddyBlockerIds_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getBuddyBlockerIds(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getBuddyBlockerIds_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getBuddyBlockerIds failed: unknown result")
        raise x

    def getBuddyLocation(self, ctx, mid, index):
        """
        Args:
            ctx: FContext
            mid: string
            index: int (signed 32 bits)
        """
        return self._methods['getBuddyLocation']([ctx, mid, index])

    def _getBuddyLocation(self, ctx, mid, index):
        self._send_getBuddyLocation(ctx, mid, index)
        return self._recv_getBuddyLocation(ctx)

    def _send_getBuddyLocation(self, ctx, mid, index):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getBuddyLocation', TMessageType.CALL, 0)
            args = getBuddyLocation_args()
            args.mid = mid
            args.index = index
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getBuddyLocation(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getBuddyLocation_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getBuddyLocation failed: unknown result")
        raise x

    def getCompactContactsModifiedSince(self, ctx, timestamp):
        """
        Args:
            ctx: FContext
            timestamp: int (signed 64 bits)
        """
        return self._methods['getCompactContactsModifiedSince']([ctx, timestamp])

    def _getCompactContactsModifiedSince(self, ctx, timestamp):
        self._send_getCompactContactsModifiedSince(ctx, timestamp)
        return self._recv_getCompactContactsModifiedSince(ctx)

    def _send_getCompactContactsModifiedSince(self, ctx, timestamp):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getCompactContactsModifiedSince', TMessageType.CALL, 0)
            args = getCompactContactsModifiedSince_args()
            args.timestamp = timestamp
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getCompactContactsModifiedSince(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getCompactContactsModifiedSince_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getCompactContactsModifiedSince failed: unknown result")
        raise x

    def getCompactGroup(self, ctx, groupId):
        """
        Args:
            ctx: FContext
            groupId: string
        """
        return self._methods['getCompactGroup']([ctx, groupId])

    def _getCompactGroup(self, ctx, groupId):
        self._send_getCompactGroup(ctx, groupId)
        return self._recv_getCompactGroup(ctx)

    def _send_getCompactGroup(self, ctx, groupId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getCompactGroup', TMessageType.CALL, 0)
            args = getCompactGroup_args()
            args.groupId = groupId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getCompactGroup(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getCompactGroup_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getCompactGroup failed: unknown result")
        raise x

    def getCompactRoom(self, ctx, roomId):
        """
        Args:
            ctx: FContext
            roomId: string
        """
        return self._methods['getCompactRoom']([ctx, roomId])

    def _getCompactRoom(self, ctx, roomId):
        self._send_getCompactRoom(ctx, roomId)
        return self._recv_getCompactRoom(ctx)

    def _send_getCompactRoom(self, ctx, roomId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getCompactRoom', TMessageType.CALL, 0)
            args = getCompactRoom_args()
            args.roomId = roomId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getCompactRoom(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getCompactRoom_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getCompactRoom failed: unknown result")
        raise x

    def getContact(self, ctx, id):
        """
        Args:
            ctx: FContext
            id: string
        """
        return self._methods['getContact']([ctx, id])

    def _getContact(self, ctx, id):
        self._send_getContact(ctx, id)
        return self._recv_getContact(ctx)

    def _send_getContact(self, ctx, id):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getContact', TMessageType.CALL, 0)
            args = getContact_args()
            args.id = id
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getContact(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getContact_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getContact failed: unknown result")
        raise x

    def getContacts(self, ctx, ids):
        """
        Args:
            ctx: FContext
            ids: list of string
        """
        return self._methods['getContacts']([ctx, ids])

    def _getContacts(self, ctx, ids):
        self._send_getContacts(ctx, ids)
        return self._recv_getContacts(ctx)

    def _send_getContacts(self, ctx, ids):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getContacts', TMessageType.CALL, 0)
            args = getContacts_args()
            args.ids = ids
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getContacts(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getContacts_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getContacts failed: unknown result")
        raise x

    def getContactWithFriendRequestStatus(self, ctx, id):
        """
        Args:
            ctx: FContext
            id: string
        """
        return self._methods['getContactWithFriendRequestStatus']([ctx, id])

    def _getContactWithFriendRequestStatus(self, ctx, id):
        self._send_getContactWithFriendRequestStatus(ctx, id)
        return self._recv_getContactWithFriendRequestStatus(ctx)

    def _send_getContactWithFriendRequestStatus(self, ctx, id):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getContactWithFriendRequestStatus', TMessageType.CALL, 0)
            args = getContactWithFriendRequestStatus_args()
            args.id = id
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getContactWithFriendRequestStatus(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getContactWithFriendRequestStatus_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getContactWithFriendRequestStatus failed: unknown result")
        raise x

    def getCountryWithRequestIp(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getCountryWithRequestIp']([ctx])

    def _getCountryWithRequestIp(self, ctx):
        self._send_getCountryWithRequestIp(ctx)
        return self._recv_getCountryWithRequestIp(ctx)

    def _send_getCountryWithRequestIp(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getCountryWithRequestIp', TMessageType.CALL, 0)
            args = getCountryWithRequestIp_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getCountryWithRequestIp(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getCountryWithRequestIp_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getCountryWithRequestIp failed: unknown result")
        raise x

    def getFavoriteMids(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getFavoriteMids']([ctx])

    def _getFavoriteMids(self, ctx):
        self._send_getFavoriteMids(ctx)
        return self._recv_getFavoriteMids(ctx)

    def _send_getFavoriteMids(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getFavoriteMids', TMessageType.CALL, 0)
            args = getFavoriteMids_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getFavoriteMids(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getFavoriteMids_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getFavoriteMids failed: unknown result")
        raise x

    def getGroup(self, ctx, groupId):
        """
        Args:
            ctx: FContext
            groupId: string
        """
        return self._methods['getGroup']([ctx, groupId])

    def _getGroup(self, ctx, groupId):
        self._send_getGroup(ctx, groupId)
        return self._recv_getGroup(ctx)

    def _send_getGroup(self, ctx, groupId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getGroup', TMessageType.CALL, 0)
            args = getGroup_args()
            args.groupId = groupId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getGroup(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getGroup_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getGroup failed: unknown result")
        raise x

    def getGroupIdsInvited(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getGroupIdsInvited']([ctx])

    def _getGroupIdsInvited(self, ctx):
        self._send_getGroupIdsInvited(ctx)
        return self._recv_getGroupIdsInvited(ctx)

    def _send_getGroupIdsInvited(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getGroupIdsInvited', TMessageType.CALL, 0)
            args = getGroupIdsInvited_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getGroupIdsInvited(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getGroupIdsInvited_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getGroupIdsInvited failed: unknown result")
        raise x

    def getGroupIdsJoined(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getGroupIdsJoined']([ctx])

    def _getGroupIdsJoined(self, ctx):
        self._send_getGroupIdsJoined(ctx)
        return self._recv_getGroupIdsJoined(ctx)

    def _send_getGroupIdsJoined(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getGroupIdsJoined', TMessageType.CALL, 0)
            args = getGroupIdsJoined_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getGroupIdsJoined(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getGroupIdsJoined_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getGroupIdsJoined failed: unknown result")
        raise x

    def getGroups(self, ctx, groupIds):
        """
        Args:
            ctx: FContext
            groupIds: list of string
        """
        return self._methods['getGroups']([ctx, groupIds])

    def _getGroups(self, ctx, groupIds):
        self._send_getGroups(ctx, groupIds)
        return self._recv_getGroups(ctx)

    def _send_getGroups(self, ctx, groupIds):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getGroups', TMessageType.CALL, 0)
            args = getGroups_args()
            args.groupIds = groupIds
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getGroups(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getGroups_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getGroups failed: unknown result")
        raise x

    def getHiddenContactMids(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getHiddenContactMids']([ctx])

    def _getHiddenContactMids(self, ctx):
        self._send_getHiddenContactMids(ctx)
        return self._recv_getHiddenContactMids(ctx)

    def _send_getHiddenContactMids(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getHiddenContactMids', TMessageType.CALL, 0)
            args = getHiddenContactMids_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getHiddenContactMids(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getHiddenContactMids_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getHiddenContactMids failed: unknown result")
        raise x

    def getIdentityIdentifier(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getIdentityIdentifier']([ctx])

    def _getIdentityIdentifier(self, ctx):
        self._send_getIdentityIdentifier(ctx)
        return self._recv_getIdentityIdentifier(ctx)

    def _send_getIdentityIdentifier(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getIdentityIdentifier', TMessageType.CALL, 0)
            args = getIdentityIdentifier_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getIdentityIdentifier(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getIdentityIdentifier_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getIdentityIdentifier failed: unknown result")
        raise x

    def getLastAnnouncementIndex(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getLastAnnouncementIndex']([ctx])

    def _getLastAnnouncementIndex(self, ctx):
        self._send_getLastAnnouncementIndex(ctx)
        return self._recv_getLastAnnouncementIndex(ctx)

    def _send_getLastAnnouncementIndex(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getLastAnnouncementIndex', TMessageType.CALL, 0)
            args = getLastAnnouncementIndex_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getLastAnnouncementIndex(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getLastAnnouncementIndex_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getLastAnnouncementIndex failed: unknown result")
        raise x

    def getLastOpRevision(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getLastOpRevision']([ctx])

    def _getLastOpRevision(self, ctx):
        self._send_getLastOpRevision(ctx)
        return self._recv_getLastOpRevision(ctx)

    def _send_getLastOpRevision(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getLastOpRevision', TMessageType.CALL, 0)
            args = getLastOpRevision_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getLastOpRevision(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getLastOpRevision_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getLastOpRevision failed: unknown result")
        raise x

    def getSuggestRevisions(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getSuggestRevisions']([ctx])

    def _getSuggestRevisions(self, ctx):
        self._send_getSuggestRevisions(ctx)
        return self._recv_getSuggestRevisions(ctx)

    def _send_getSuggestRevisions(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getSuggestRevisions', TMessageType.CALL, 0)
            args = getSuggestRevisions_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getSuggestRevisions(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getSuggestRevisions_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getSuggestRevisions failed: unknown result")
        raise x

    def getPreviousMessagesV2WithReadCount(self, ctx, messageBoxId, endMessageId, messagesCount):
        """
        Args:
            ctx: FContext
            messageBoxId: string
            endMessageId: MessageBoxV2MessageId
            messagesCount: int (signed 32 bits)
        """
        return self._methods['getPreviousMessagesV2WithReadCount']([ctx, messageBoxId, endMessageId, messagesCount])

    def _getPreviousMessagesV2WithReadCount(self, ctx, messageBoxId, endMessageId, messagesCount):
        self._send_getPreviousMessagesV2WithReadCount(ctx, messageBoxId, endMessageId, messagesCount)
        return self._recv_getPreviousMessagesV2WithReadCount(ctx)

    def _send_getPreviousMessagesV2WithReadCount(self, ctx, messageBoxId, endMessageId, messagesCount):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getPreviousMessagesV2WithReadCount', TMessageType.CALL, 0)
            args = getPreviousMessagesV2WithReadCount_args()
            args.messageBoxId = messageBoxId
            args.endMessageId = endMessageId
            args.messagesCount = messagesCount
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getPreviousMessagesV2WithReadCount(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getPreviousMessagesV2WithReadCount_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getPreviousMessagesV2WithReadCount failed: unknown result")
        raise x

    def getMessageBox(self, ctx, channelId, messageBoxId, lastMessagesCount):
        """
        Args:
            ctx: FContext
            channelId: string
            messageBoxId: string
            lastMessagesCount: int (signed 32 bits)
        """
        return self._methods['getMessageBox']([ctx, channelId, messageBoxId, lastMessagesCount])

    def _getMessageBox(self, ctx, channelId, messageBoxId, lastMessagesCount):
        self._send_getMessageBox(ctx, channelId, messageBoxId, lastMessagesCount)
        return self._recv_getMessageBox(ctx)

    def _send_getMessageBox(self, ctx, channelId, messageBoxId, lastMessagesCount):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getMessageBox', TMessageType.CALL, 0)
            args = getMessageBox_args()
            args.channelId = channelId
            args.messageBoxId = messageBoxId
            args.lastMessagesCount = lastMessagesCount
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getMessageBox(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getMessageBox_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getMessageBox failed: unknown result")
        raise x

    def getMessageBoxCompactWrapUp(self, ctx, mid):
        """
        Args:
            ctx: FContext
            mid: string
        """
        return self._methods['getMessageBoxCompactWrapUp']([ctx, mid])

    def _getMessageBoxCompactWrapUp(self, ctx, mid):
        self._send_getMessageBoxCompactWrapUp(ctx, mid)
        return self._recv_getMessageBoxCompactWrapUp(ctx)

    def _send_getMessageBoxCompactWrapUp(self, ctx, mid):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getMessageBoxCompactWrapUp', TMessageType.CALL, 0)
            args = getMessageBoxCompactWrapUp_args()
            args.mid = mid
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getMessageBoxCompactWrapUp(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getMessageBoxCompactWrapUp_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getMessageBoxCompactWrapUp failed: unknown result")
        raise x

    def getMessageBoxCompactWrapUpList(self, ctx, start, messageBoxCount):
        """
        Args:
            ctx: FContext
            start: int (signed 32 bits)
            messageBoxCount: int (signed 32 bits)
        """
        return self._methods['getMessageBoxCompactWrapUpList']([ctx, start, messageBoxCount])

    def _getMessageBoxCompactWrapUpList(self, ctx, start, messageBoxCount):
        self._send_getMessageBoxCompactWrapUpList(ctx, start, messageBoxCount)
        return self._recv_getMessageBoxCompactWrapUpList(ctx)

    def _send_getMessageBoxCompactWrapUpList(self, ctx, start, messageBoxCount):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getMessageBoxCompactWrapUpList', TMessageType.CALL, 0)
            args = getMessageBoxCompactWrapUpList_args()
            args.start = start
            args.messageBoxCount = messageBoxCount
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getMessageBoxCompactWrapUpList(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getMessageBoxCompactWrapUpList_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getMessageBoxCompactWrapUpList failed: unknown result")
        raise x

    def getMessageBoxList(self, ctx, channelId, lastMessagesCount):
        """
        Args:
            ctx: FContext
            channelId: string
            lastMessagesCount: int (signed 32 bits)
        """
        return self._methods['getMessageBoxList']([ctx, channelId, lastMessagesCount])

    def _getMessageBoxList(self, ctx, channelId, lastMessagesCount):
        self._send_getMessageBoxList(ctx, channelId, lastMessagesCount)
        return self._recv_getMessageBoxList(ctx)

    def _send_getMessageBoxList(self, ctx, channelId, lastMessagesCount):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getMessageBoxList', TMessageType.CALL, 0)
            args = getMessageBoxList_args()
            args.channelId = channelId
            args.lastMessagesCount = lastMessagesCount
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getMessageBoxList(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getMessageBoxList_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getMessageBoxList failed: unknown result")
        raise x

    def getMessageBoxListByStatus(self, ctx, channelId, lastMessagesCount, status):
        """
        Args:
            ctx: FContext
            channelId: string
            lastMessagesCount: int (signed 32 bits)
            status: int (signed 32 bits)
        """
        return self._methods['getMessageBoxListByStatus']([ctx, channelId, lastMessagesCount, status])

    def _getMessageBoxListByStatus(self, ctx, channelId, lastMessagesCount, status):
        self._send_getMessageBoxListByStatus(ctx, channelId, lastMessagesCount, status)
        return self._recv_getMessageBoxListByStatus(ctx)

    def _send_getMessageBoxListByStatus(self, ctx, channelId, lastMessagesCount, status):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getMessageBoxListByStatus', TMessageType.CALL, 0)
            args = getMessageBoxListByStatus_args()
            args.channelId = channelId
            args.lastMessagesCount = lastMessagesCount
            args.status = status
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getMessageBoxListByStatus(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getMessageBoxListByStatus_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getMessageBoxListByStatus failed: unknown result")
        raise x

    def getMessageBoxWrapUp(self, ctx, mid):
        """
        Args:
            ctx: FContext
            mid: string
        """
        return self._methods['getMessageBoxWrapUp']([ctx, mid])

    def _getMessageBoxWrapUp(self, ctx, mid):
        self._send_getMessageBoxWrapUp(ctx, mid)
        return self._recv_getMessageBoxWrapUp(ctx)

    def _send_getMessageBoxWrapUp(self, ctx, mid):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getMessageBoxWrapUp', TMessageType.CALL, 0)
            args = getMessageBoxWrapUp_args()
            args.mid = mid
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getMessageBoxWrapUp(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getMessageBoxWrapUp_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getMessageBoxWrapUp failed: unknown result")
        raise x

    def getMessageBoxWrapUpList(self, ctx, start, messageBoxCount):
        """
        Args:
            ctx: FContext
            start: int (signed 32 bits)
            messageBoxCount: int (signed 32 bits)
        """
        return self._methods['getMessageBoxWrapUpList']([ctx, start, messageBoxCount])

    def _getMessageBoxWrapUpList(self, ctx, start, messageBoxCount):
        self._send_getMessageBoxWrapUpList(ctx, start, messageBoxCount)
        return self._recv_getMessageBoxWrapUpList(ctx)

    def _send_getMessageBoxWrapUpList(self, ctx, start, messageBoxCount):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getMessageBoxWrapUpList', TMessageType.CALL, 0)
            args = getMessageBoxWrapUpList_args()
            args.start = start
            args.messageBoxCount = messageBoxCount
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getMessageBoxWrapUpList(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getMessageBoxWrapUpList_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getMessageBoxWrapUpList failed: unknown result")
        raise x

    def getMessagesBySequenceNumber(self, ctx, channelId, messageBoxId, startSeq, endSeq):
        """
        Args:
            ctx: FContext
            channelId: string
            messageBoxId: string
            startSeq: int (signed 64 bits)
            endSeq: int (signed 64 bits)
        """
        return self._methods['getMessagesBySequenceNumber']([ctx, channelId, messageBoxId, startSeq, endSeq])

    def _getMessagesBySequenceNumber(self, ctx, channelId, messageBoxId, startSeq, endSeq):
        self._send_getMessagesBySequenceNumber(ctx, channelId, messageBoxId, startSeq, endSeq)
        return self._recv_getMessagesBySequenceNumber(ctx)

    def _send_getMessagesBySequenceNumber(self, ctx, channelId, messageBoxId, startSeq, endSeq):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getMessagesBySequenceNumber', TMessageType.CALL, 0)
            args = getMessagesBySequenceNumber_args()
            args.channelId = channelId
            args.messageBoxId = messageBoxId
            args.startSeq = startSeq
            args.endSeq = endSeq
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getMessagesBySequenceNumber(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getMessagesBySequenceNumber_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getMessagesBySequenceNumber failed: unknown result")
        raise x

    def getNextMessages(self, ctx, messageBoxId, startSeq, messagesCount):
        """
        Args:
            ctx: FContext
            messageBoxId: string
            startSeq: int (signed 64 bits)
            messagesCount: int (signed 32 bits)
        """
        return self._methods['getNextMessages']([ctx, messageBoxId, startSeq, messagesCount])

    def _getNextMessages(self, ctx, messageBoxId, startSeq, messagesCount):
        self._send_getNextMessages(ctx, messageBoxId, startSeq, messagesCount)
        return self._recv_getNextMessages(ctx)

    def _send_getNextMessages(self, ctx, messageBoxId, startSeq, messagesCount):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getNextMessages', TMessageType.CALL, 0)
            args = getNextMessages_args()
            args.messageBoxId = messageBoxId
            args.startSeq = startSeq
            args.messagesCount = messagesCount
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getNextMessages(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getNextMessages_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getNextMessages failed: unknown result")
        raise x

    def getNotificationPolicy(self, ctx, carrier):
        """
        Args:
            ctx: FContext
            carrier: CarrierCode
        """
        return self._methods['getNotificationPolicy']([ctx, carrier])

    def _getNotificationPolicy(self, ctx, carrier):
        self._send_getNotificationPolicy(ctx, carrier)
        return self._recv_getNotificationPolicy(ctx)

    def _send_getNotificationPolicy(self, ctx, carrier):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getNotificationPolicy', TMessageType.CALL, 0)
            args = getNotificationPolicy_args()
            args.carrier = carrier
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getNotificationPolicy(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getNotificationPolicy_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getNotificationPolicy failed: unknown result")
        raise x

    def getPreviousMessages(self, ctx, messageBoxId, endSeq, messagesCount):
        """
        Args:
            ctx: FContext
            messageBoxId: string
            endSeq: int (signed 64 bits)
            messagesCount: int (signed 32 bits)
        """
        return self._methods['getPreviousMessages']([ctx, messageBoxId, endSeq, messagesCount])

    def _getPreviousMessages(self, ctx, messageBoxId, endSeq, messagesCount):
        self._send_getPreviousMessages(ctx, messageBoxId, endSeq, messagesCount)
        return self._recv_getPreviousMessages(ctx)

    def _send_getPreviousMessages(self, ctx, messageBoxId, endSeq, messagesCount):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getPreviousMessages', TMessageType.CALL, 0)
            args = getPreviousMessages_args()
            args.messageBoxId = messageBoxId
            args.endSeq = endSeq
            args.messagesCount = messagesCount
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getPreviousMessages(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getPreviousMessages_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getPreviousMessages failed: unknown result")
        raise x

    def getProfile(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getProfile']([ctx])

    def _getProfile(self, ctx):
        self._send_getProfile(ctx)
        return self._recv_getProfile(ctx)

    def _send_getProfile(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getProfile', TMessageType.CALL, 0)
            args = getProfile_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getProfile(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getProfile_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getProfile failed: unknown result")
        raise x

    def getProximityMatchCandidateList(self, ctx, sessionId):
        """
        Args:
            ctx: FContext
            sessionId: string
        """
        return self._methods['getProximityMatchCandidateList']([ctx, sessionId])

    def _getProximityMatchCandidateList(self, ctx, sessionId):
        self._send_getProximityMatchCandidateList(ctx, sessionId)
        return self._recv_getProximityMatchCandidateList(ctx)

    def _send_getProximityMatchCandidateList(self, ctx, sessionId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getProximityMatchCandidateList', TMessageType.CALL, 0)
            args = getProximityMatchCandidateList_args()
            args.sessionId = sessionId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getProximityMatchCandidateList(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getProximityMatchCandidateList_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getProximityMatchCandidateList failed: unknown result")
        raise x

    def getProximityMatchCandidates(self, ctx, sessionId):
        """
        Args:
            ctx: FContext
            sessionId: string
        """
        return self._methods['getProximityMatchCandidates']([ctx, sessionId])

    def _getProximityMatchCandidates(self, ctx, sessionId):
        self._send_getProximityMatchCandidates(ctx, sessionId)
        return self._recv_getProximityMatchCandidates(ctx)

    def _send_getProximityMatchCandidates(self, ctx, sessionId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getProximityMatchCandidates', TMessageType.CALL, 0)
            args = getProximityMatchCandidates_args()
            args.sessionId = sessionId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getProximityMatchCandidates(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getProximityMatchCandidates_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getProximityMatchCandidates failed: unknown result")
        raise x

    def getRecentMessages(self, ctx, messageBoxId, messagesCount):
        """
        Args:
            ctx: FContext
            messageBoxId: string
            messagesCount: int (signed 32 bits)
        """
        return self._methods['getRecentMessages']([ctx, messageBoxId, messagesCount])

    def _getRecentMessages(self, ctx, messageBoxId, messagesCount):
        self._send_getRecentMessages(ctx, messageBoxId, messagesCount)
        return self._recv_getRecentMessages(ctx)

    def _send_getRecentMessages(self, ctx, messageBoxId, messagesCount):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getRecentMessages', TMessageType.CALL, 0)
            args = getRecentMessages_args()
            args.messageBoxId = messageBoxId
            args.messagesCount = messagesCount
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getRecentMessages(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getRecentMessages_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getRecentMessages failed: unknown result")
        raise x

    def getRecommendationIds(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getRecommendationIds']([ctx])

    def _getRecommendationIds(self, ctx):
        self._send_getRecommendationIds(ctx)
        return self._recv_getRecommendationIds(ctx)

    def _send_getRecommendationIds(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getRecommendationIds', TMessageType.CALL, 0)
            args = getRecommendationIds_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getRecommendationIds(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getRecommendationIds_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getRecommendationIds failed: unknown result")
        raise x

    def getRoom(self, ctx, roomId):
        """
        Args:
            ctx: FContext
            roomId: string
        """
        return self._methods['getRoom']([ctx, roomId])

    def _getRoom(self, ctx, roomId):
        self._send_getRoom(ctx, roomId)
        return self._recv_getRoom(ctx)

    def _send_getRoom(self, ctx, roomId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getRoom', TMessageType.CALL, 0)
            args = getRoom_args()
            args.roomId = roomId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getRoom(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getRoom_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getRoom failed: unknown result")
        raise x

    def getRSAKeyInfo(self, ctx, provider):
        """
        Args:
            ctx: FContext
            provider: IdentityProvider
        """
        return self._methods['getRSAKeyInfo']([ctx, provider])

    def _getRSAKeyInfo(self, ctx, provider):
        self._send_getRSAKeyInfo(ctx, provider)
        return self._recv_getRSAKeyInfo(ctx)

    def _send_getRSAKeyInfo(self, ctx, provider):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getRSAKeyInfo', TMessageType.CALL, 0)
            args = getRSAKeyInfo_args()
            args.provider = provider
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getRSAKeyInfo(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getRSAKeyInfo_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getRSAKeyInfo failed: unknown result")
        raise x

    def getServerTime(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getServerTime']([ctx])

    def _getServerTime(self, ctx):
        self._send_getServerTime(ctx)
        return self._recv_getServerTime(ctx)

    def _send_getServerTime(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getServerTime', TMessageType.CALL, 0)
            args = getServerTime_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getServerTime(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getServerTime_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getServerTime failed: unknown result")
        raise x

    def getSessions(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getSessions']([ctx])

    def _getSessions(self, ctx):
        self._send_getSessions(ctx)
        return self._recv_getSessions(ctx)

    def _send_getSessions(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getSessions', TMessageType.CALL, 0)
            args = getSessions_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getSessions(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getSessions_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getSessions failed: unknown result")
        raise x

    def getSettings(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getSettings']([ctx])

    def _getSettings(self, ctx):
        self._send_getSettings(ctx)
        return self._recv_getSettings(ctx)

    def _send_getSettings(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getSettings', TMessageType.CALL, 0)
            args = getSettings_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getSettings(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getSettings_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getSettings failed: unknown result")
        raise x

    def getGroupsV2(self, ctx, groupIds):
        """
        Args:
            ctx: FContext
            groupIds: list of string
        """
        return self._methods['getGroupsV2']([ctx, groupIds])

    def _getGroupsV2(self, ctx, groupIds):
        self._send_getGroupsV2(ctx, groupIds)
        return self._recv_getGroupsV2(ctx)

    def _send_getGroupsV2(self, ctx, groupIds):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getGroupsV2', TMessageType.CALL, 0)
            args = getGroupsV2_args()
            args.groupIds = groupIds
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getGroupsV2(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getGroupsV2_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getGroupsV2 failed: unknown result")
        raise x

    def getSettingsAttributes(self, ctx, attrBitset):
        """
        Args:
            ctx: FContext
            attrBitset: int (signed 32 bits)
        """
        return self._methods['getSettingsAttributes']([ctx, attrBitset])

    def _getSettingsAttributes(self, ctx, attrBitset):
        self._send_getSettingsAttributes(ctx, attrBitset)
        return self._recv_getSettingsAttributes(ctx)

    def _send_getSettingsAttributes(self, ctx, attrBitset):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getSettingsAttributes', TMessageType.CALL, 0)
            args = getSettingsAttributes_args()
            args.attrBitset = attrBitset
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getSettingsAttributes(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getSettingsAttributes_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getSettingsAttributes failed: unknown result")
        raise x

    def getSystemConfiguration(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getSystemConfiguration']([ctx])

    def _getSystemConfiguration(self, ctx):
        self._send_getSystemConfiguration(ctx)
        return self._recv_getSystemConfiguration(ctx)

    def _send_getSystemConfiguration(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getSystemConfiguration', TMessageType.CALL, 0)
            args = getSystemConfiguration_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getSystemConfiguration(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getSystemConfiguration_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getSystemConfiguration failed: unknown result")
        raise x

    def getUserTicket(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getUserTicket']([ctx])

    def _getUserTicket(self, ctx):
        self._send_getUserTicket(ctx)
        return self._recv_getUserTicket(ctx)

    def _send_getUserTicket(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getUserTicket', TMessageType.CALL, 0)
            args = getUserTicket_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getUserTicket(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getUserTicket_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getUserTicket failed: unknown result")
        raise x

    def getWapInvitation(self, ctx, invitationHash):
        """
        Args:
            ctx: FContext
            invitationHash: string
        """
        return self._methods['getWapInvitation']([ctx, invitationHash])

    def _getWapInvitation(self, ctx, invitationHash):
        self._send_getWapInvitation(ctx, invitationHash)
        return self._recv_getWapInvitation(ctx)

    def _send_getWapInvitation(self, ctx, invitationHash):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getWapInvitation', TMessageType.CALL, 0)
            args = getWapInvitation_args()
            args.invitationHash = invitationHash
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getWapInvitation(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getWapInvitation_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getWapInvitation failed: unknown result")
        raise x

    def invalidateUserTicket(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['invalidateUserTicket']([ctx])

    def _invalidateUserTicket(self, ctx):
        self._send_invalidateUserTicket(ctx)
        self._recv_invalidateUserTicket(ctx)

    def _send_invalidateUserTicket(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('invalidateUserTicket', TMessageType.CALL, 0)
            args = invalidateUserTicket_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_invalidateUserTicket(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = invalidateUserTicket_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def inviteFriendsBySms(self, ctx, phoneNumberList):
        """
        Args:
            ctx: FContext
            phoneNumberList: list of string
        """
        return self._methods['inviteFriendsBySms']([ctx, phoneNumberList])

    def _inviteFriendsBySms(self, ctx, phoneNumberList):
        self._send_inviteFriendsBySms(ctx, phoneNumberList)
        self._recv_inviteFriendsBySms(ctx)

    def _send_inviteFriendsBySms(self, ctx, phoneNumberList):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('inviteFriendsBySms', TMessageType.CALL, 0)
            args = inviteFriendsBySms_args()
            args.phoneNumberList = phoneNumberList
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_inviteFriendsBySms(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = inviteFriendsBySms_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def inviteIntoGroup(self, ctx, reqSeq, groupId, contactIds):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            groupId: string
            contactIds: list of string
        """
        return self._methods['inviteIntoGroup']([ctx, reqSeq, groupId, contactIds])

    def _inviteIntoGroup(self, ctx, reqSeq, groupId, contactIds):
        self._send_inviteIntoGroup(ctx, reqSeq, groupId, contactIds)
        self._recv_inviteIntoGroup(ctx)

    def _send_inviteIntoGroup(self, ctx, reqSeq, groupId, contactIds):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('inviteIntoGroup', TMessageType.CALL, 0)
            args = inviteIntoGroup_args()
            args.reqSeq = reqSeq
            args.groupId = groupId
            args.contactIds = contactIds
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_inviteIntoGroup(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = inviteIntoGroup_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def inviteIntoRoom(self, ctx, reqSeq, roomId, contactIds):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            roomId: string
            contactIds: list of string
        """
        return self._methods['inviteIntoRoom']([ctx, reqSeq, roomId, contactIds])

    def _inviteIntoRoom(self, ctx, reqSeq, roomId, contactIds):
        self._send_inviteIntoRoom(ctx, reqSeq, roomId, contactIds)
        self._recv_inviteIntoRoom(ctx)

    def _send_inviteIntoRoom(self, ctx, reqSeq, roomId, contactIds):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('inviteIntoRoom', TMessageType.CALL, 0)
            args = inviteIntoRoom_args()
            args.reqSeq = reqSeq
            args.roomId = roomId
            args.contactIds = contactIds
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_inviteIntoRoom(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = inviteIntoRoom_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def inviteViaEmail(self, ctx, reqSeq, email, name):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            email: string
            name: string
        """
        return self._methods['inviteViaEmail']([ctx, reqSeq, email, name])

    def _inviteViaEmail(self, ctx, reqSeq, email, name):
        self._send_inviteViaEmail(ctx, reqSeq, email, name)
        self._recv_inviteViaEmail(ctx)

    def _send_inviteViaEmail(self, ctx, reqSeq, email, name):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('inviteViaEmail', TMessageType.CALL, 0)
            args = inviteViaEmail_args()
            args.reqSeq = reqSeq
            args.email = email
            args.name = name
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_inviteViaEmail(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = inviteViaEmail_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def isIdentityIdentifierAvailable(self, ctx, provider, identifier):
        """
        Args:
            ctx: FContext
            provider: IdentityProvider
            identifier: string
        """
        return self._methods['isIdentityIdentifierAvailable']([ctx, provider, identifier])

    def _isIdentityIdentifierAvailable(self, ctx, provider, identifier):
        self._send_isIdentityIdentifierAvailable(ctx, provider, identifier)
        return self._recv_isIdentityIdentifierAvailable(ctx)

    def _send_isIdentityIdentifierAvailable(self, ctx, provider, identifier):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('isIdentityIdentifierAvailable', TMessageType.CALL, 0)
            args = isIdentityIdentifierAvailable_args()
            args.provider = provider
            args.identifier = identifier
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_isIdentityIdentifierAvailable(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = isIdentityIdentifierAvailable_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "isIdentityIdentifierAvailable failed: unknown result")
        raise x

    def isUseridAvailable(self, ctx, userid):
        """
        Args:
            ctx: FContext
            userid: string
        """
        return self._methods['isUseridAvailable']([ctx, userid])

    def _isUseridAvailable(self, ctx, userid):
        self._send_isUseridAvailable(ctx, userid)
        return self._recv_isUseridAvailable(ctx)

    def _send_isUseridAvailable(self, ctx, userid):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('isUseridAvailable', TMessageType.CALL, 0)
            args = isUseridAvailable_args()
            args.userid = userid
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_isUseridAvailable(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = isUseridAvailable_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "isUseridAvailable failed: unknown result")
        raise x

    def kickoutFromGroup(self, ctx, reqSeq, groupId, contactIds):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            groupId: string
            contactIds: list of string
        """
        return self._methods['kickoutFromGroup']([ctx, reqSeq, groupId, contactIds])

    def _kickoutFromGroup(self, ctx, reqSeq, groupId, contactIds):
        self._send_kickoutFromGroup(ctx, reqSeq, groupId, contactIds)
        self._recv_kickoutFromGroup(ctx)

    def _send_kickoutFromGroup(self, ctx, reqSeq, groupId, contactIds):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('kickoutFromGroup', TMessageType.CALL, 0)
            args = kickoutFromGroup_args()
            args.reqSeq = reqSeq
            args.groupId = groupId
            args.contactIds = contactIds
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_kickoutFromGroup(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = kickoutFromGroup_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def reissueGroupTicket(self, ctx, groupMid):
        """
        Args:
            ctx: FContext
            groupMid: string
        """
        return self._methods['reissueGroupTicket']([ctx, groupMid])

    def _reissueGroupTicket(self, ctx, groupMid):
        self._send_reissueGroupTicket(ctx, groupMid)
        return self._recv_reissueGroupTicket(ctx)

    def _send_reissueGroupTicket(self, ctx, groupMid):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('reissueGroupTicket', TMessageType.CALL, 0)
            args = reissueGroupTicket_args()
            args.groupMid = groupMid
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_reissueGroupTicket(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = reissueGroupTicket_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "reissueGroupTicket failed: unknown result")
        raise x

    def findGroupByTicket(self, ctx, ticketId):
        """
        Args:
            ctx: FContext
            ticketId: string
        """
        return self._methods['findGroupByTicket']([ctx, ticketId])

    def _findGroupByTicket(self, ctx, ticketId):
        self._send_findGroupByTicket(ctx, ticketId)
        return self._recv_findGroupByTicket(ctx)

    def _send_findGroupByTicket(self, ctx, ticketId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('findGroupByTicket', TMessageType.CALL, 0)
            args = findGroupByTicket_args()
            args.ticketId = ticketId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_findGroupByTicket(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = findGroupByTicket_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "findGroupByTicket failed: unknown result")
        raise x

    def leaveGroup(self, ctx, reqSeq, groupId):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            groupId: string
        """
        return self._methods['leaveGroup']([ctx, reqSeq, groupId])

    def _leaveGroup(self, ctx, reqSeq, groupId):
        self._send_leaveGroup(ctx, reqSeq, groupId)
        self._recv_leaveGroup(ctx)

    def _send_leaveGroup(self, ctx, reqSeq, groupId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('leaveGroup', TMessageType.CALL, 0)
            args = leaveGroup_args()
            args.reqSeq = reqSeq
            args.groupId = groupId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_leaveGroup(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = leaveGroup_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def leaveRoom(self, ctx, reqSeq, roomId):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            roomId: string
        """
        return self._methods['leaveRoom']([ctx, reqSeq, roomId])

    def _leaveRoom(self, ctx, reqSeq, roomId):
        self._send_leaveRoom(ctx, reqSeq, roomId)
        self._recv_leaveRoom(ctx)

    def _send_leaveRoom(self, ctx, reqSeq, roomId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('leaveRoom', TMessageType.CALL, 0)
            args = leaveRoom_args()
            args.reqSeq = reqSeq
            args.roomId = roomId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_leaveRoom(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = leaveRoom_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def loginWithIdentityCredential(self, ctx, identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate):
        """
        Args:
            ctx: FContext
            identityProvider: IdentityProvider
            identifier: string
            password: string
            keepLoggedIn: boolean
            accessLocation: string
            systemName: string
            certificate: string
        """
        return self._methods['loginWithIdentityCredential']([ctx, identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate])

    def _loginWithIdentityCredential(self, ctx, identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate):
        self._send_loginWithIdentityCredential(ctx, identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate)
        return self._recv_loginWithIdentityCredential(ctx)

    def _send_loginWithIdentityCredential(self, ctx, identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('loginWithIdentityCredential', TMessageType.CALL, 0)
            args = loginWithIdentityCredential_args()
            args.identityProvider = identityProvider
            args.identifier = identifier
            args.password = password
            args.keepLoggedIn = keepLoggedIn
            args.accessLocation = accessLocation
            args.systemName = systemName
            args.certificate = certificate
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_loginWithIdentityCredential(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = loginWithIdentityCredential_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "loginWithIdentityCredential failed: unknown result")
        raise x

    def loginWithIdentityCredentialForCertificate(self, ctx, identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate):
        """
        Args:
            ctx: FContext
            identityProvider: IdentityProvider
            identifier: string
            password: string
            keepLoggedIn: boolean
            accessLocation: string
            systemName: string
            certificate: string
        """
        return self._methods['loginWithIdentityCredentialForCertificate']([ctx, identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate])

    def _loginWithIdentityCredentialForCertificate(self, ctx, identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate):
        self._send_loginWithIdentityCredentialForCertificate(ctx, identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate)
        return self._recv_loginWithIdentityCredentialForCertificate(ctx)

    def _send_loginWithIdentityCredentialForCertificate(self, ctx, identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('loginWithIdentityCredentialForCertificate', TMessageType.CALL, 0)
            args = loginWithIdentityCredentialForCertificate_args()
            args.identityProvider = identityProvider
            args.identifier = identifier
            args.password = password
            args.keepLoggedIn = keepLoggedIn
            args.accessLocation = accessLocation
            args.systemName = systemName
            args.certificate = certificate
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_loginWithIdentityCredentialForCertificate(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = loginWithIdentityCredentialForCertificate_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "loginWithIdentityCredentialForCertificate failed: unknown result")
        raise x

    def loginWithVerifier(self, ctx, verifier):
        """
        Args:
            ctx: FContext
            verifier: string
        """
        return self._methods['loginWithVerifier']([ctx, verifier])

    def _loginWithVerifier(self, ctx, verifier):
        self._send_loginWithVerifier(ctx, verifier)
        return self._recv_loginWithVerifier(ctx)

    def _send_loginWithVerifier(self, ctx, verifier):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('loginWithVerifier', TMessageType.CALL, 0)
            args = loginWithVerifier_args()
            args.verifier = verifier
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_loginWithVerifier(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = loginWithVerifier_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "loginWithVerifier failed: unknown result")
        raise x

    def loginWithVerifierForCerificate(self, ctx, verifier):
        """
        Args:
            ctx: FContext
            verifier: string
        """
        return self._methods['loginWithVerifierForCerificate']([ctx, verifier])

    def _loginWithVerifierForCerificate(self, ctx, verifier):
        self._send_loginWithVerifierForCerificate(ctx, verifier)
        return self._recv_loginWithVerifierForCerificate(ctx)

    def _send_loginWithVerifierForCerificate(self, ctx, verifier):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('loginWithVerifierForCerificate', TMessageType.CALL, 0)
            args = loginWithVerifierForCerificate_args()
            args.verifier = verifier
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_loginWithVerifierForCerificate(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = loginWithVerifierForCerificate_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "loginWithVerifierForCerificate failed: unknown result")
        raise x

    def loginWithVerifierForCertificate(self, ctx, verifier):
        """
        Args:
            ctx: FContext
            verifier: string
        """
        return self._methods['loginWithVerifierForCertificate']([ctx, verifier])

    def _loginWithVerifierForCertificate(self, ctx, verifier):
        self._send_loginWithVerifierForCertificate(ctx, verifier)
        return self._recv_loginWithVerifierForCertificate(ctx)

    def _send_loginWithVerifierForCertificate(self, ctx, verifier):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('loginWithVerifierForCertificate', TMessageType.CALL, 0)
            args = loginWithVerifierForCertificate_args()
            args.verifier = verifier
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_loginWithVerifierForCertificate(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = loginWithVerifierForCertificate_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "loginWithVerifierForCertificate failed: unknown result")
        raise x

    def logout(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['logout']([ctx])

    def _logout(self, ctx):
        self._send_logout(ctx)
        self._recv_logout(ctx)

    def _send_logout(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('logout', TMessageType.CALL, 0)
            args = logout_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_logout(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = logout_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def logoutSession(self, ctx, tokenKey):
        """
        Args:
            ctx: FContext
            tokenKey: string
        """
        return self._methods['logoutSession']([ctx, tokenKey])

    def _logoutSession(self, ctx, tokenKey):
        self._send_logoutSession(ctx, tokenKey)
        self._recv_logoutSession(ctx)

    def _send_logoutSession(self, ctx, tokenKey):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('logoutSession', TMessageType.CALL, 0)
            args = logoutSession_args()
            args.tokenKey = tokenKey
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_logoutSession(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = logoutSession_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def noop(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['noop']([ctx])

    def _noop(self, ctx):
        self._send_noop(ctx)
        self._recv_noop(ctx)

    def _send_noop(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('noop', TMessageType.CALL, 0)
            args = noop_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_noop(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = noop_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def notifiedRedirect(self, ctx, paramMap):
        """
        Args:
            ctx: FContext
            paramMap: dict of <string, string>
        """
        return self._methods['notifiedRedirect']([ctx, paramMap])

    def _notifiedRedirect(self, ctx, paramMap):
        self._send_notifiedRedirect(ctx, paramMap)
        self._recv_notifiedRedirect(ctx)

    def _send_notifiedRedirect(self, ctx, paramMap):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('notifiedRedirect', TMessageType.CALL, 0)
            args = notifiedRedirect_args()
            args.paramMap = paramMap
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_notifiedRedirect(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = notifiedRedirect_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def notifyBuddyOnAir(self, ctx, seq, receiverMids):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            receiverMids: list of string
        """
        return self._methods['notifyBuddyOnAir']([ctx, seq, receiverMids])

    def _notifyBuddyOnAir(self, ctx, seq, receiverMids):
        self._send_notifyBuddyOnAir(ctx, seq, receiverMids)
        return self._recv_notifyBuddyOnAir(ctx)

    def _send_notifyBuddyOnAir(self, ctx, seq, receiverMids):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('notifyBuddyOnAir', TMessageType.CALL, 0)
            args = notifyBuddyOnAir_args()
            args.seq = seq
            args.receiverMids = receiverMids
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_notifyBuddyOnAir(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = notifyBuddyOnAir_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "notifyBuddyOnAir failed: unknown result")
        raise x

    def notifyIndividualEvent(self, ctx, notificationStatus, receiverMids):
        """
        Args:
            ctx: FContext
            notificationStatus: NotificationStatus
            receiverMids: list of string
        """
        return self._methods['notifyIndividualEvent']([ctx, notificationStatus, receiverMids])

    def _notifyIndividualEvent(self, ctx, notificationStatus, receiverMids):
        self._send_notifyIndividualEvent(ctx, notificationStatus, receiverMids)
        self._recv_notifyIndividualEvent(ctx)

    def _send_notifyIndividualEvent(self, ctx, notificationStatus, receiverMids):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('notifyIndividualEvent', TMessageType.CALL, 0)
            args = notifyIndividualEvent_args()
            args.notificationStatus = notificationStatus
            args.receiverMids = receiverMids
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_notifyIndividualEvent(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = notifyIndividualEvent_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def notifyInstalled(self, ctx, udidHash, applicationTypeWithExtensions):
        """
        Args:
            ctx: FContext
            udidHash: string
            applicationTypeWithExtensions: string
        """
        return self._methods['notifyInstalled']([ctx, udidHash, applicationTypeWithExtensions])

    def _notifyInstalled(self, ctx, udidHash, applicationTypeWithExtensions):
        self._send_notifyInstalled(ctx, udidHash, applicationTypeWithExtensions)
        self._recv_notifyInstalled(ctx)

    def _send_notifyInstalled(self, ctx, udidHash, applicationTypeWithExtensions):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('notifyInstalled', TMessageType.CALL, 0)
            args = notifyInstalled_args()
            args.udidHash = udidHash
            args.applicationTypeWithExtensions = applicationTypeWithExtensions
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_notifyInstalled(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = notifyInstalled_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def notifyRegistrationComplete(self, ctx, udidHash, applicationTypeWithExtensions):
        """
        Args:
            ctx: FContext
            udidHash: string
            applicationTypeWithExtensions: string
        """
        return self._methods['notifyRegistrationComplete']([ctx, udidHash, applicationTypeWithExtensions])

    def _notifyRegistrationComplete(self, ctx, udidHash, applicationTypeWithExtensions):
        self._send_notifyRegistrationComplete(ctx, udidHash, applicationTypeWithExtensions)
        self._recv_notifyRegistrationComplete(ctx)

    def _send_notifyRegistrationComplete(self, ctx, udidHash, applicationTypeWithExtensions):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('notifyRegistrationComplete', TMessageType.CALL, 0)
            args = notifyRegistrationComplete_args()
            args.udidHash = udidHash
            args.applicationTypeWithExtensions = applicationTypeWithExtensions
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_notifyRegistrationComplete(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = notifyRegistrationComplete_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def notifySleep(self, ctx, lastRev, badge):
        """
        Args:
            ctx: FContext
            lastRev: int (signed 64 bits)
            badge: int (signed 32 bits)
        """
        return self._methods['notifySleep']([ctx, lastRev, badge])

    def _notifySleep(self, ctx, lastRev, badge):
        self._send_notifySleep(ctx, lastRev, badge)
        self._recv_notifySleep(ctx)

    def _send_notifySleep(self, ctx, lastRev, badge):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('notifySleep', TMessageType.CALL, 0)
            args = notifySleep_args()
            args.lastRev = lastRev
            args.badge = badge
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_notifySleep(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = notifySleep_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def notifyUpdated(self, ctx, lastRev, deviceInfo):
        """
        Args:
            ctx: FContext
            lastRev: int (signed 64 bits)
            deviceInfo: DeviceInfo
        """
        return self._methods['notifyUpdated']([ctx, lastRev, deviceInfo])

    def _notifyUpdated(self, ctx, lastRev, deviceInfo):
        self._send_notifyUpdated(ctx, lastRev, deviceInfo)
        self._recv_notifyUpdated(ctx)

    def _send_notifyUpdated(self, ctx, lastRev, deviceInfo):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('notifyUpdated', TMessageType.CALL, 0)
            args = notifyUpdated_args()
            args.lastRev = lastRev
            args.deviceInfo = deviceInfo
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_notifyUpdated(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = notifyUpdated_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def openProximityMatch(self, ctx, location):
        """
        Args:
            ctx: FContext
            location: Location
        """
        return self._methods['openProximityMatch']([ctx, location])

    def _openProximityMatch(self, ctx, location):
        self._send_openProximityMatch(ctx, location)
        return self._recv_openProximityMatch(ctx)

    def _send_openProximityMatch(self, ctx, location):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('openProximityMatch', TMessageType.CALL, 0)
            args = openProximityMatch_args()
            args.location = location
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_openProximityMatch(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = openProximityMatch_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "openProximityMatch failed: unknown result")
        raise x

    def registerBuddyUser(self, ctx, buddyId, registrarPassword):
        """
        Args:
            ctx: FContext
            buddyId: string
            registrarPassword: string
        """
        return self._methods['registerBuddyUser']([ctx, buddyId, registrarPassword])

    def _registerBuddyUser(self, ctx, buddyId, registrarPassword):
        self._send_registerBuddyUser(ctx, buddyId, registrarPassword)
        return self._recv_registerBuddyUser(ctx)

    def _send_registerBuddyUser(self, ctx, buddyId, registrarPassword):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('registerBuddyUser', TMessageType.CALL, 0)
            args = registerBuddyUser_args()
            args.buddyId = buddyId
            args.registrarPassword = registrarPassword
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_registerBuddyUser(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = registerBuddyUser_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "registerBuddyUser failed: unknown result")
        raise x

    def registerBuddyUserid(self, ctx, seq, userid):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            userid: string
        """
        return self._methods['registerBuddyUserid']([ctx, seq, userid])

    def _registerBuddyUserid(self, ctx, seq, userid):
        self._send_registerBuddyUserid(ctx, seq, userid)
        self._recv_registerBuddyUserid(ctx)

    def _send_registerBuddyUserid(self, ctx, seq, userid):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('registerBuddyUserid', TMessageType.CALL, 0)
            args = registerBuddyUserid_args()
            args.seq = seq
            args.userid = userid
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_registerBuddyUserid(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = registerBuddyUserid_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def registerDevice(self, ctx, sessionId):
        """
        Args:
            ctx: FContext
            sessionId: string
        """
        return self._methods['registerDevice']([ctx, sessionId])

    def _registerDevice(self, ctx, sessionId):
        self._send_registerDevice(ctx, sessionId)
        return self._recv_registerDevice(ctx)

    def _send_registerDevice(self, ctx, sessionId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('registerDevice', TMessageType.CALL, 0)
            args = registerDevice_args()
            args.sessionId = sessionId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_registerDevice(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = registerDevice_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "registerDevice failed: unknown result")
        raise x

    def registerDeviceWithIdentityCredential(self, ctx, sessionId, provider, identifier, verifier):
        """
        Args:
            ctx: FContext
            sessionId: string
            provider: IdentityProvider
            identifier: string
            verifier: string
        """
        return self._methods['registerDeviceWithIdentityCredential']([ctx, sessionId, provider, identifier, verifier])

    def _registerDeviceWithIdentityCredential(self, ctx, sessionId, provider, identifier, verifier):
        self._send_registerDeviceWithIdentityCredential(ctx, sessionId, provider, identifier, verifier)
        return self._recv_registerDeviceWithIdentityCredential(ctx)

    def _send_registerDeviceWithIdentityCredential(self, ctx, sessionId, provider, identifier, verifier):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('registerDeviceWithIdentityCredential', TMessageType.CALL, 0)
            args = registerDeviceWithIdentityCredential_args()
            args.sessionId = sessionId
            args.provider = provider
            args.identifier = identifier
            args.verifier = verifier
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_registerDeviceWithIdentityCredential(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = registerDeviceWithIdentityCredential_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "registerDeviceWithIdentityCredential failed: unknown result")
        raise x

    def registerDeviceWithoutPhoneNumber(self, ctx, region, udidHash, deviceInfo):
        """
        Args:
            ctx: FContext
            region: string
            udidHash: string
            deviceInfo: DeviceInfo
        """
        return self._methods['registerDeviceWithoutPhoneNumber']([ctx, region, udidHash, deviceInfo])

    def _registerDeviceWithoutPhoneNumber(self, ctx, region, udidHash, deviceInfo):
        self._send_registerDeviceWithoutPhoneNumber(ctx, region, udidHash, deviceInfo)
        return self._recv_registerDeviceWithoutPhoneNumber(ctx)

    def _send_registerDeviceWithoutPhoneNumber(self, ctx, region, udidHash, deviceInfo):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('registerDeviceWithoutPhoneNumber', TMessageType.CALL, 0)
            args = registerDeviceWithoutPhoneNumber_args()
            args.region = region
            args.udidHash = udidHash
            args.deviceInfo = deviceInfo
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_registerDeviceWithoutPhoneNumber(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = registerDeviceWithoutPhoneNumber_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "registerDeviceWithoutPhoneNumber failed: unknown result")
        raise x

    def registerDeviceWithoutPhoneNumberWithIdentityCredential(self, ctx, region, udidHash, deviceInfo, provider, identifier, verifier, mid, migrationPincodeSessionId):
        """
        Args:
            ctx: FContext
            region: string
            udidHash: string
            deviceInfo: DeviceInfo
            provider: IdentityProvider
            identifier: string
            verifier: string
            mid: string
            migrationPincodeSessionId: string
        """
        return self._methods['registerDeviceWithoutPhoneNumberWithIdentityCredential']([ctx, region, udidHash, deviceInfo, provider, identifier, verifier, mid, migrationPincodeSessionId])

    def _registerDeviceWithoutPhoneNumberWithIdentityCredential(self, ctx, region, udidHash, deviceInfo, provider, identifier, verifier, mid, migrationPincodeSessionId):
        self._send_registerDeviceWithoutPhoneNumberWithIdentityCredential(ctx, region, udidHash, deviceInfo, provider, identifier, verifier, mid, migrationPincodeSessionId)
        return self._recv_registerDeviceWithoutPhoneNumberWithIdentityCredential(ctx)

    def _send_registerDeviceWithoutPhoneNumberWithIdentityCredential(self, ctx, region, udidHash, deviceInfo, provider, identifier, verifier, mid, migrationPincodeSessionId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('registerDeviceWithoutPhoneNumberWithIdentityCredential', TMessageType.CALL, 0)
            args = registerDeviceWithoutPhoneNumberWithIdentityCredential_args()
            args.region = region
            args.udidHash = udidHash
            args.deviceInfo = deviceInfo
            args.provider = provider
            args.identifier = identifier
            args.verifier = verifier
            args.mid = mid
            args.migrationPincodeSessionId = migrationPincodeSessionId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_registerDeviceWithoutPhoneNumberWithIdentityCredential(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = registerDeviceWithoutPhoneNumberWithIdentityCredential_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "registerDeviceWithoutPhoneNumberWithIdentityCredential failed: unknown result")
        raise x

    def registerUserid(self, ctx, reqSeq, userid):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            userid: string
        """
        return self._methods['registerUserid']([ctx, reqSeq, userid])

    def _registerUserid(self, ctx, reqSeq, userid):
        self._send_registerUserid(ctx, reqSeq, userid)
        return self._recv_registerUserid(ctx)

    def _send_registerUserid(self, ctx, reqSeq, userid):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('registerUserid', TMessageType.CALL, 0)
            args = registerUserid_args()
            args.reqSeq = reqSeq
            args.userid = userid
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_registerUserid(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = registerUserid_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "registerUserid failed: unknown result")
        raise x

    def registerWapDevice(self, ctx, invitationHash, guidHash, email, deviceInfo):
        """
        Args:
            ctx: FContext
            invitationHash: string
            guidHash: string
            email: string
            deviceInfo: DeviceInfo
        """
        return self._methods['registerWapDevice']([ctx, invitationHash, guidHash, email, deviceInfo])

    def _registerWapDevice(self, ctx, invitationHash, guidHash, email, deviceInfo):
        self._send_registerWapDevice(ctx, invitationHash, guidHash, email, deviceInfo)
        return self._recv_registerWapDevice(ctx)

    def _send_registerWapDevice(self, ctx, invitationHash, guidHash, email, deviceInfo):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('registerWapDevice', TMessageType.CALL, 0)
            args = registerWapDevice_args()
            args.invitationHash = invitationHash
            args.guidHash = guidHash
            args.email = email
            args.deviceInfo = deviceInfo
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_registerWapDevice(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = registerWapDevice_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "registerWapDevice failed: unknown result")
        raise x

    def registerWithExistingSnsIdAndIdentityCredential(self, ctx, identityCredential, region, udidHash, deviceInfo):
        """
        Args:
            ctx: FContext
            identityCredential: IdentityCredential
            region: string
            udidHash: string
            deviceInfo: DeviceInfo
        """
        return self._methods['registerWithExistingSnsIdAndIdentityCredential']([ctx, identityCredential, region, udidHash, deviceInfo])

    def _registerWithExistingSnsIdAndIdentityCredential(self, ctx, identityCredential, region, udidHash, deviceInfo):
        self._send_registerWithExistingSnsIdAndIdentityCredential(ctx, identityCredential, region, udidHash, deviceInfo)
        return self._recv_registerWithExistingSnsIdAndIdentityCredential(ctx)

    def _send_registerWithExistingSnsIdAndIdentityCredential(self, ctx, identityCredential, region, udidHash, deviceInfo):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('registerWithExistingSnsIdAndIdentityCredential', TMessageType.CALL, 0)
            args = registerWithExistingSnsIdAndIdentityCredential_args()
            args.identityCredential = identityCredential
            args.region = region
            args.udidHash = udidHash
            args.deviceInfo = deviceInfo
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_registerWithExistingSnsIdAndIdentityCredential(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = registerWithExistingSnsIdAndIdentityCredential_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "registerWithExistingSnsIdAndIdentityCredential failed: unknown result")
        raise x

    def registerWithSnsId(self, ctx, snsIdType, snsAccessToken, region, udidHash, deviceInfo, mid):
        """
        Args:
            ctx: FContext
            snsIdType: SnsIdType
            snsAccessToken: string
            region: string
            udidHash: string
            deviceInfo: DeviceInfo
            mid: string
        """
        return self._methods['registerWithSnsId']([ctx, snsIdType, snsAccessToken, region, udidHash, deviceInfo, mid])

    def _registerWithSnsId(self, ctx, snsIdType, snsAccessToken, region, udidHash, deviceInfo, mid):
        self._send_registerWithSnsId(ctx, snsIdType, snsAccessToken, region, udidHash, deviceInfo, mid)
        return self._recv_registerWithSnsId(ctx)

    def _send_registerWithSnsId(self, ctx, snsIdType, snsAccessToken, region, udidHash, deviceInfo, mid):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('registerWithSnsId', TMessageType.CALL, 0)
            args = registerWithSnsId_args()
            args.snsIdType = snsIdType
            args.snsAccessToken = snsAccessToken
            args.region = region
            args.udidHash = udidHash
            args.deviceInfo = deviceInfo
            args.mid = mid
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_registerWithSnsId(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = registerWithSnsId_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "registerWithSnsId failed: unknown result")
        raise x

    def registerWithSnsIdAndIdentityCredential(self, ctx, snsIdType, snsAccessToken, identityCredential, region, udidHash, deviceInfo):
        """
        Args:
            ctx: FContext
            snsIdType: SnsIdType
            snsAccessToken: string
            identityCredential: IdentityCredential
            region: string
            udidHash: string
            deviceInfo: DeviceInfo
        """
        return self._methods['registerWithSnsIdAndIdentityCredential']([ctx, snsIdType, snsAccessToken, identityCredential, region, udidHash, deviceInfo])

    def _registerWithSnsIdAndIdentityCredential(self, ctx, snsIdType, snsAccessToken, identityCredential, region, udidHash, deviceInfo):
        self._send_registerWithSnsIdAndIdentityCredential(ctx, snsIdType, snsAccessToken, identityCredential, region, udidHash, deviceInfo)
        return self._recv_registerWithSnsIdAndIdentityCredential(ctx)

    def _send_registerWithSnsIdAndIdentityCredential(self, ctx, snsIdType, snsAccessToken, identityCredential, region, udidHash, deviceInfo):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('registerWithSnsIdAndIdentityCredential', TMessageType.CALL, 0)
            args = registerWithSnsIdAndIdentityCredential_args()
            args.snsIdType = snsIdType
            args.snsAccessToken = snsAccessToken
            args.identityCredential = identityCredential
            args.region = region
            args.udidHash = udidHash
            args.deviceInfo = deviceInfo
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_registerWithSnsIdAndIdentityCredential(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = registerWithSnsIdAndIdentityCredential_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "registerWithSnsIdAndIdentityCredential failed: unknown result")
        raise x

    def reissueDeviceCredential(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['reissueDeviceCredential']([ctx])

    def _reissueDeviceCredential(self, ctx):
        self._send_reissueDeviceCredential(ctx)
        return self._recv_reissueDeviceCredential(ctx)

    def _send_reissueDeviceCredential(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('reissueDeviceCredential', TMessageType.CALL, 0)
            args = reissueDeviceCredential_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_reissueDeviceCredential(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = reissueDeviceCredential_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "reissueDeviceCredential failed: unknown result")
        raise x

    def reissueUserTicket(self, ctx, expirationTime, maxUseCount):
        """
        Args:
            ctx: FContext
            expirationTime: int (signed 64 bits)
            maxUseCount: int (signed 32 bits)
        """
        return self._methods['reissueUserTicket']([ctx, expirationTime, maxUseCount])

    def _reissueUserTicket(self, ctx, expirationTime, maxUseCount):
        self._send_reissueUserTicket(ctx, expirationTime, maxUseCount)
        return self._recv_reissueUserTicket(ctx)

    def _send_reissueUserTicket(self, ctx, expirationTime, maxUseCount):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('reissueUserTicket', TMessageType.CALL, 0)
            args = reissueUserTicket_args()
            args.expirationTime = expirationTime
            args.maxUseCount = maxUseCount
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_reissueUserTicket(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = reissueUserTicket_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "reissueUserTicket failed: unknown result")
        raise x

    def getMessageReadRange(self, ctx, chatIds):
        """
        Args:
            ctx: FContext
            chatIds: list of string
        """
        return self._methods['getMessageReadRange']([ctx, chatIds])

    def _getMessageReadRange(self, ctx, chatIds):
        self._send_getMessageReadRange(ctx, chatIds)
        return self._recv_getMessageReadRange(ctx)

    def _send_getMessageReadRange(self, ctx, chatIds):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getMessageReadRange', TMessageType.CALL, 0)
            args = getMessageReadRange_args()
            args.chatIds = chatIds
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getMessageReadRange(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getMessageReadRange_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getMessageReadRange failed: unknown result")
        raise x

    def rejectGroupInvitation(self, ctx, reqSeq, groupId):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            groupId: string
        """
        return self._methods['rejectGroupInvitation']([ctx, reqSeq, groupId])

    def _rejectGroupInvitation(self, ctx, reqSeq, groupId):
        self._send_rejectGroupInvitation(ctx, reqSeq, groupId)
        self._recv_rejectGroupInvitation(ctx)

    def _send_rejectGroupInvitation(self, ctx, reqSeq, groupId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('rejectGroupInvitation', TMessageType.CALL, 0)
            args = rejectGroupInvitation_args()
            args.reqSeq = reqSeq
            args.groupId = groupId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_rejectGroupInvitation(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = rejectGroupInvitation_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def releaseSession(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['releaseSession']([ctx])

    def _releaseSession(self, ctx):
        self._send_releaseSession(ctx)
        self._recv_releaseSession(ctx)

    def _send_releaseSession(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('releaseSession', TMessageType.CALL, 0)
            args = releaseSession_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_releaseSession(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = releaseSession_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def removeAllMessages(self, ctx, seq, lastMessageId):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            lastMessageId: string
        """
        return self._methods['removeAllMessages']([ctx, seq, lastMessageId])

    def _removeAllMessages(self, ctx, seq, lastMessageId):
        self._send_removeAllMessages(ctx, seq, lastMessageId)
        self._recv_removeAllMessages(ctx)

    def _send_removeAllMessages(self, ctx, seq, lastMessageId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('removeAllMessages', TMessageType.CALL, 0)
            args = removeAllMessages_args()
            args.seq = seq
            args.lastMessageId = lastMessageId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_removeAllMessages(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = removeAllMessages_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def removeBuddyLocation(self, ctx, mid, index):
        """
        Args:
            ctx: FContext
            mid: string
            index: int (signed 32 bits)
        """
        return self._methods['removeBuddyLocation']([ctx, mid, index])

    def _removeBuddyLocation(self, ctx, mid, index):
        self._send_removeBuddyLocation(ctx, mid, index)
        self._recv_removeBuddyLocation(ctx)

    def _send_removeBuddyLocation(self, ctx, mid, index):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('removeBuddyLocation', TMessageType.CALL, 0)
            args = removeBuddyLocation_args()
            args.mid = mid
            args.index = index
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_removeBuddyLocation(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = removeBuddyLocation_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def removeMessage(self, ctx, messageId):
        """
        Args:
            ctx: FContext
            messageId: string
        """
        return self._methods['removeMessage']([ctx, messageId])

    def _removeMessage(self, ctx, messageId):
        self._send_removeMessage(ctx, messageId)
        return self._recv_removeMessage(ctx)

    def _send_removeMessage(self, ctx, messageId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('removeMessage', TMessageType.CALL, 0)
            args = removeMessage_args()
            args.messageId = messageId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_removeMessage(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = removeMessage_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "removeMessage failed: unknown result")
        raise x

    def makeUserAddMyselfAsContact(self, ctx, contactOwnerMid):
        """
        Args:
            ctx: FContext
            contactOwnerMid: string
        """
        return self._methods['makeUserAddMyselfAsContact']([ctx, contactOwnerMid])

    def _makeUserAddMyselfAsContact(self, ctx, contactOwnerMid):
        self._send_makeUserAddMyselfAsContact(ctx, contactOwnerMid)
        return self._recv_makeUserAddMyselfAsContact(ctx)

    def _send_makeUserAddMyselfAsContact(self, ctx, contactOwnerMid):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('makeUserAddMyselfAsContact', TMessageType.CALL, 0)
            args = makeUserAddMyselfAsContact_args()
            args.contactOwnerMid = contactOwnerMid
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_makeUserAddMyselfAsContact(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = makeUserAddMyselfAsContact_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "makeUserAddMyselfAsContact failed: unknown result")
        raise x

    def removeMessageFromMyHome(self, ctx, messageId):
        """
        Args:
            ctx: FContext
            messageId: string
        """
        return self._methods['removeMessageFromMyHome']([ctx, messageId])

    def _removeMessageFromMyHome(self, ctx, messageId):
        self._send_removeMessageFromMyHome(ctx, messageId)
        return self._recv_removeMessageFromMyHome(ctx)

    def _send_removeMessageFromMyHome(self, ctx, messageId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('removeMessageFromMyHome', TMessageType.CALL, 0)
            args = removeMessageFromMyHome_args()
            args.messageId = messageId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_removeMessageFromMyHome(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = removeMessageFromMyHome_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "removeMessageFromMyHome failed: unknown result")
        raise x

    def removeSnsId(self, ctx, snsIdType):
        """
        Args:
            ctx: FContext
            snsIdType: SnsIdType
        """
        return self._methods['removeSnsId']([ctx, snsIdType])

    def _removeSnsId(self, ctx, snsIdType):
        self._send_removeSnsId(ctx, snsIdType)
        return self._recv_removeSnsId(ctx)

    def _send_removeSnsId(self, ctx, snsIdType):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('removeSnsId', TMessageType.CALL, 0)
            args = removeSnsId_args()
            args.snsIdType = snsIdType
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_removeSnsId(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = removeSnsId_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "removeSnsId failed: unknown result")
        raise x

    def report(self, ctx, syncOpRevision, category, report):
        """
        Args:
            ctx: FContext
            syncOpRevision: int (signed 64 bits)
            category: SyncCategory
            report: string
        """
        return self._methods['report']([ctx, syncOpRevision, category, report])

    def _report(self, ctx, syncOpRevision, category, report):
        self._send_report(ctx, syncOpRevision, category, report)
        self._recv_report(ctx)

    def _send_report(self, ctx, syncOpRevision, category, report):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('report', TMessageType.CALL, 0)
            args = report_args()
            args.syncOpRevision = syncOpRevision
            args.category = category
            args.report = report
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_report(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = report_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def reportContacts(self, ctx, syncOpRevision, category, contactReports, actionType):
        """
        Args:
            ctx: FContext
            syncOpRevision: int (signed 64 bits)
            category: SyncCategory
            contactReports: list of ContactReport
            actionType: SyncActionType
        """
        return self._methods['reportContacts']([ctx, syncOpRevision, category, contactReports, actionType])

    def _reportContacts(self, ctx, syncOpRevision, category, contactReports, actionType):
        self._send_reportContacts(ctx, syncOpRevision, category, contactReports, actionType)
        return self._recv_reportContacts(ctx)

    def _send_reportContacts(self, ctx, syncOpRevision, category, contactReports, actionType):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('reportContacts', TMessageType.CALL, 0)
            args = reportContacts_args()
            args.syncOpRevision = syncOpRevision
            args.category = category
            args.contactReports = contactReports
            args.actionType = actionType
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_reportContacts(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = reportContacts_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "reportContacts failed: unknown result")
        raise x

    def reportGroups(self, ctx, syncOpRevision, groups):
        """
        Args:
            ctx: FContext
            syncOpRevision: int (signed 64 bits)
            groups: list of Group
        """
        return self._methods['reportGroups']([ctx, syncOpRevision, groups])

    def _reportGroups(self, ctx, syncOpRevision, groups):
        self._send_reportGroups(ctx, syncOpRevision, groups)
        self._recv_reportGroups(ctx)

    def _send_reportGroups(self, ctx, syncOpRevision, groups):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('reportGroups', TMessageType.CALL, 0)
            args = reportGroups_args()
            args.syncOpRevision = syncOpRevision
            args.groups = groups
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_reportGroups(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = reportGroups_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def reportProfile(self, ctx, syncOpRevision, profile):
        """
        Args:
            ctx: FContext
            syncOpRevision: int (signed 64 bits)
            profile: Profile
        """
        return self._methods['reportProfile']([ctx, syncOpRevision, profile])

    def _reportProfile(self, ctx, syncOpRevision, profile):
        self._send_reportProfile(ctx, syncOpRevision, profile)
        self._recv_reportProfile(ctx)

    def _send_reportProfile(self, ctx, syncOpRevision, profile):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('reportProfile', TMessageType.CALL, 0)
            args = reportProfile_args()
            args.syncOpRevision = syncOpRevision
            args.profile = profile
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_reportProfile(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = reportProfile_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def reportRooms(self, ctx, syncOpRevision, rooms):
        """
        Args:
            ctx: FContext
            syncOpRevision: int (signed 64 bits)
            rooms: list of Room
        """
        return self._methods['reportRooms']([ctx, syncOpRevision, rooms])

    def _reportRooms(self, ctx, syncOpRevision, rooms):
        self._send_reportRooms(ctx, syncOpRevision, rooms)
        self._recv_reportRooms(ctx)

    def _send_reportRooms(self, ctx, syncOpRevision, rooms):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('reportRooms', TMessageType.CALL, 0)
            args = reportRooms_args()
            args.syncOpRevision = syncOpRevision
            args.rooms = rooms
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_reportRooms(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = reportRooms_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def findAndAddContactByMetaTag(self, ctx, reqSeq, userid, reference):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            userid: string
            reference: string
        """
        return self._methods['findAndAddContactByMetaTag']([ctx, reqSeq, userid, reference])

    def _findAndAddContactByMetaTag(self, ctx, reqSeq, userid, reference):
        self._send_findAndAddContactByMetaTag(ctx, reqSeq, userid, reference)
        return self._recv_findAndAddContactByMetaTag(ctx)

    def _send_findAndAddContactByMetaTag(self, ctx, reqSeq, userid, reference):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('findAndAddContactByMetaTag', TMessageType.CALL, 0)
            args = findAndAddContactByMetaTag_args()
            args.reqSeq = reqSeq
            args.userid = userid
            args.reference = reference
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_findAndAddContactByMetaTag(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = findAndAddContactByMetaTag_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "findAndAddContactByMetaTag failed: unknown result")
        raise x

    def reportSettings(self, ctx, syncOpRevision, settings):
        """
        Args:
            ctx: FContext
            syncOpRevision: int (signed 64 bits)
            settings: Settings
        """
        return self._methods['reportSettings']([ctx, syncOpRevision, settings])

    def _reportSettings(self, ctx, syncOpRevision, settings):
        self._send_reportSettings(ctx, syncOpRevision, settings)
        self._recv_reportSettings(ctx)

    def _send_reportSettings(self, ctx, syncOpRevision, settings):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('reportSettings', TMessageType.CALL, 0)
            args = reportSettings_args()
            args.syncOpRevision = syncOpRevision
            args.settings = settings
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_reportSettings(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = reportSettings_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def reportSpam(self, ctx, chatMid, memberMids, spammerReasons, senderMids, spamMessageIds, spamMessages):
        """
        Args:
            ctx: FContext
            chatMid: string
            memberMids: list of string
            spammerReasons: list of SpammerReason
            senderMids: list of string
            spamMessageIds: list of string
            spamMessages: list of string
        """
        return self._methods['reportSpam']([ctx, chatMid, memberMids, spammerReasons, senderMids, spamMessageIds, spamMessages])

    def _reportSpam(self, ctx, chatMid, memberMids, spammerReasons, senderMids, spamMessageIds, spamMessages):
        self._send_reportSpam(ctx, chatMid, memberMids, spammerReasons, senderMids, spamMessageIds, spamMessages)
        self._recv_reportSpam(ctx)

    def _send_reportSpam(self, ctx, chatMid, memberMids, spammerReasons, senderMids, spamMessageIds, spamMessages):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('reportSpam', TMessageType.CALL, 0)
            args = reportSpam_args()
            args.chatMid = chatMid
            args.memberMids = memberMids
            args.spammerReasons = spammerReasons
            args.senderMids = senderMids
            args.spamMessageIds = spamMessageIds
            args.spamMessages = spamMessages
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_reportSpam(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = reportSpam_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def reportSpammer(self, ctx, spammerMid, spammerReasons, spamMessageIds):
        """
        Args:
            ctx: FContext
            spammerMid: string
            spammerReasons: list of SpammerReason
            spamMessageIds: list of string
        """
        return self._methods['reportSpammer']([ctx, spammerMid, spammerReasons, spamMessageIds])

    def _reportSpammer(self, ctx, spammerMid, spammerReasons, spamMessageIds):
        self._send_reportSpammer(ctx, spammerMid, spammerReasons, spamMessageIds)
        self._recv_reportSpammer(ctx)

    def _send_reportSpammer(self, ctx, spammerMid, spammerReasons, spamMessageIds):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('reportSpammer', TMessageType.CALL, 0)
            args = reportSpammer_args()
            args.spammerMid = spammerMid
            args.spammerReasons = spammerReasons
            args.spamMessageIds = spamMessageIds
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_reportSpammer(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = reportSpammer_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def requestAccountPasswordReset(self, ctx, provider, identifier, locale):
        """
        Args:
            ctx: FContext
            provider: IdentityProvider
            identifier: string
            locale: string
        """
        return self._methods['requestAccountPasswordReset']([ctx, provider, identifier, locale])

    def _requestAccountPasswordReset(self, ctx, provider, identifier, locale):
        self._send_requestAccountPasswordReset(ctx, provider, identifier, locale)
        self._recv_requestAccountPasswordReset(ctx)

    def _send_requestAccountPasswordReset(self, ctx, provider, identifier, locale):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('requestAccountPasswordReset', TMessageType.CALL, 0)
            args = requestAccountPasswordReset_args()
            args.provider = provider
            args.identifier = identifier
            args.locale = locale
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_requestAccountPasswordReset(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = requestAccountPasswordReset_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def requestEmailConfirmation(self, ctx, emailConfirmation):
        """
        Args:
            ctx: FContext
            emailConfirmation: EmailConfirmation
        """
        return self._methods['requestEmailConfirmation']([ctx, emailConfirmation])

    def _requestEmailConfirmation(self, ctx, emailConfirmation):
        self._send_requestEmailConfirmation(ctx, emailConfirmation)
        return self._recv_requestEmailConfirmation(ctx)

    def _send_requestEmailConfirmation(self, ctx, emailConfirmation):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('requestEmailConfirmation', TMessageType.CALL, 0)
            args = requestEmailConfirmation_args()
            args.emailConfirmation = emailConfirmation
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_requestEmailConfirmation(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = requestEmailConfirmation_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "requestEmailConfirmation failed: unknown result")
        raise x

    def requestIdentityUnbind(self, ctx, provider, identifier):
        """
        Args:
            ctx: FContext
            provider: IdentityProvider
            identifier: string
        """
        return self._methods['requestIdentityUnbind']([ctx, provider, identifier])

    def _requestIdentityUnbind(self, ctx, provider, identifier):
        self._send_requestIdentityUnbind(ctx, provider, identifier)
        self._recv_requestIdentityUnbind(ctx)

    def _send_requestIdentityUnbind(self, ctx, provider, identifier):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('requestIdentityUnbind', TMessageType.CALL, 0)
            args = requestIdentityUnbind_args()
            args.provider = provider
            args.identifier = identifier
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_requestIdentityUnbind(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = requestIdentityUnbind_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def resendEmailConfirmation(self, ctx, verifier):
        """
        Args:
            ctx: FContext
            verifier: string
        """
        return self._methods['resendEmailConfirmation']([ctx, verifier])

    def _resendEmailConfirmation(self, ctx, verifier):
        self._send_resendEmailConfirmation(ctx, verifier)
        return self._recv_resendEmailConfirmation(ctx)

    def _send_resendEmailConfirmation(self, ctx, verifier):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('resendEmailConfirmation', TMessageType.CALL, 0)
            args = resendEmailConfirmation_args()
            args.verifier = verifier
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_resendEmailConfirmation(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = resendEmailConfirmation_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "resendEmailConfirmation failed: unknown result")
        raise x

    def resendPinCode(self, ctx, sessionId):
        """
        Args:
            ctx: FContext
            sessionId: string
        """
        return self._methods['resendPinCode']([ctx, sessionId])

    def _resendPinCode(self, ctx, sessionId):
        self._send_resendPinCode(ctx, sessionId)
        self._recv_resendPinCode(ctx)

    def _send_resendPinCode(self, ctx, sessionId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('resendPinCode', TMessageType.CALL, 0)
            args = resendPinCode_args()
            args.sessionId = sessionId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_resendPinCode(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = resendPinCode_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def resendPinCodeBySMS(self, ctx, sessionId):
        """
        Args:
            ctx: FContext
            sessionId: string
        """
        return self._methods['resendPinCodeBySMS']([ctx, sessionId])

    def _resendPinCodeBySMS(self, ctx, sessionId):
        self._send_resendPinCodeBySMS(ctx, sessionId)
        self._recv_resendPinCodeBySMS(ctx)

    def _send_resendPinCodeBySMS(self, ctx, sessionId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('resendPinCodeBySMS', TMessageType.CALL, 0)
            args = resendPinCodeBySMS_args()
            args.sessionId = sessionId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_resendPinCodeBySMS(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = resendPinCodeBySMS_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def sendChatChecked(self, ctx, seq, consumer, lastMessageId):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            consumer: string
            lastMessageId: string
        """
        return self._methods['sendChatChecked']([ctx, seq, consumer, lastMessageId])

    def _sendChatChecked(self, ctx, seq, consumer, lastMessageId):
        self._send_sendChatChecked(ctx, seq, consumer, lastMessageId)
        self._recv_sendChatChecked(ctx)

    def _send_sendChatChecked(self, ctx, seq, consumer, lastMessageId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('sendChatChecked', TMessageType.CALL, 0)
            args = sendChatChecked_args()
            args.seq = seq
            args.consumer = consumer
            args.lastMessageId = lastMessageId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_sendChatChecked(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = sendChatChecked_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def sendMessageAwaitCommit(self, ctx, seq, message):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            message: Message
        """
        return self._methods['sendMessageAwaitCommit']([ctx, seq, message])

    def _sendMessageAwaitCommit(self, ctx, seq, message):
        self._send_sendMessageAwaitCommit(ctx, seq, message)
        return self._recv_sendMessageAwaitCommit(ctx)

    def _send_sendMessageAwaitCommit(self, ctx, seq, message):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('sendMessageAwaitCommit', TMessageType.CALL, 0)
            args = sendMessageAwaitCommit_args()
            args.seq = seq
            args.message = message
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_sendMessageAwaitCommit(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = sendMessageAwaitCommit_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "sendMessageAwaitCommit failed: unknown result")
        raise x

    def sendChatRemoved(self, ctx, seq, consumer, lastMessageId):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            consumer: string
            lastMessageId: string
        """
        return self._methods['sendChatRemoved']([ctx, seq, consumer, lastMessageId])

    def _sendChatRemoved(self, ctx, seq, consumer, lastMessageId):
        self._send_sendChatRemoved(ctx, seq, consumer, lastMessageId)
        self._recv_sendChatRemoved(ctx)

    def _send_sendChatRemoved(self, ctx, seq, consumer, lastMessageId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('sendChatRemoved', TMessageType.CALL, 0)
            args = sendChatRemoved_args()
            args.seq = seq
            args.consumer = consumer
            args.lastMessageId = lastMessageId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_sendChatRemoved(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = sendChatRemoved_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def sendContentPreviewUpdated(self, ctx, esq, messageId, receiverMids):
        """
        Args:
            ctx: FContext
            esq: int (signed 32 bits)
            messageId: string
            receiverMids: list of string
        """
        return self._methods['sendContentPreviewUpdated']([ctx, esq, messageId, receiverMids])

    def _sendContentPreviewUpdated(self, ctx, esq, messageId, receiverMids):
        self._send_sendContentPreviewUpdated(ctx, esq, messageId, receiverMids)
        return self._recv_sendContentPreviewUpdated(ctx)

    def _send_sendContentPreviewUpdated(self, ctx, esq, messageId, receiverMids):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('sendContentPreviewUpdated', TMessageType.CALL, 0)
            args = sendContentPreviewUpdated_args()
            args.esq = esq
            args.messageId = messageId
            args.receiverMids = receiverMids
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_sendContentPreviewUpdated(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = sendContentPreviewUpdated_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "sendContentPreviewUpdated failed: unknown result")
        raise x

    def sendContentReceipt(self, ctx, seq, consumer, messageId):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            consumer: string
            messageId: string
        """
        return self._methods['sendContentReceipt']([ctx, seq, consumer, messageId])

    def _sendContentReceipt(self, ctx, seq, consumer, messageId):
        self._send_sendContentReceipt(ctx, seq, consumer, messageId)
        self._recv_sendContentReceipt(ctx)

    def _send_sendContentReceipt(self, ctx, seq, consumer, messageId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('sendContentReceipt', TMessageType.CALL, 0)
            args = sendContentReceipt_args()
            args.seq = seq
            args.consumer = consumer
            args.messageId = messageId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_sendContentReceipt(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = sendContentReceipt_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def sendDummyPush(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['sendDummyPush']([ctx])

    def _sendDummyPush(self, ctx):
        self._send_sendDummyPush(ctx)
        self._recv_sendDummyPush(ctx)

    def _send_sendDummyPush(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('sendDummyPush', TMessageType.CALL, 0)
            args = sendDummyPush_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_sendDummyPush(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = sendDummyPush_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def removeE2EEPublicKey(self, ctx, publicKey):
        """
        Args:
            ctx: FContext
            publicKey: E2EEPublicKey
        """
        return self._methods['removeE2EEPublicKey']([ctx, publicKey])

    def _removeE2EEPublicKey(self, ctx, publicKey):
        self._send_removeE2EEPublicKey(ctx, publicKey)
        self._recv_removeE2EEPublicKey(ctx)

    def _send_removeE2EEPublicKey(self, ctx, publicKey):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('removeE2EEPublicKey', TMessageType.CALL, 0)
            args = removeE2EEPublicKey_args()
            args.publicKey = publicKey
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_removeE2EEPublicKey(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = removeE2EEPublicKey_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def negotiateE2EEPublicKey(self, ctx, mid):
        """
        Args:
            ctx: FContext
            mid: string
        """
        return self._methods['negotiateE2EEPublicKey']([ctx, mid])

    def _negotiateE2EEPublicKey(self, ctx, mid):
        self._send_negotiateE2EEPublicKey(ctx, mid)
        return self._recv_negotiateE2EEPublicKey(ctx)

    def _send_negotiateE2EEPublicKey(self, ctx, mid):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('negotiateE2EEPublicKey', TMessageType.CALL, 0)
            args = negotiateE2EEPublicKey_args()
            args.mid = mid
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_negotiateE2EEPublicKey(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = negotiateE2EEPublicKey_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "negotiateE2EEPublicKey failed: unknown result")
        raise x

    def getE2EEPublicKey(self, ctx, mid, version, keyId):
        """
        Args:
            ctx: FContext
            mid: string
            version: int (signed 32 bits)
            keyId: int (signed 32 bits)
        """
        return self._methods['getE2EEPublicKey']([ctx, mid, version, keyId])

    def _getE2EEPublicKey(self, ctx, mid, version, keyId):
        self._send_getE2EEPublicKey(ctx, mid, version, keyId)
        return self._recv_getE2EEPublicKey(ctx)

    def _send_getE2EEPublicKey(self, ctx, mid, version, keyId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getE2EEPublicKey', TMessageType.CALL, 0)
            args = getE2EEPublicKey_args()
            args.mid = mid
            args.version = version
            args.keyId = keyId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getE2EEPublicKey(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getE2EEPublicKey_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getE2EEPublicKey failed: unknown result")
        raise x

    def requestE2EEKeyExchange(self, ctx, reqSeq, temporalPublicKey, publicKey, verifier):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            temporalPublicKey: binary string
            publicKey: E2EEPublicKey
            verifier: binary string
        """
        return self._methods['requestE2EEKeyExchange']([ctx, reqSeq, temporalPublicKey, publicKey, verifier])

    def _requestE2EEKeyExchange(self, ctx, reqSeq, temporalPublicKey, publicKey, verifier):
        self._send_requestE2EEKeyExchange(ctx, reqSeq, temporalPublicKey, publicKey, verifier)
        self._recv_requestE2EEKeyExchange(ctx)

    def _send_requestE2EEKeyExchange(self, ctx, reqSeq, temporalPublicKey, publicKey, verifier):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('requestE2EEKeyExchange', TMessageType.CALL, 0)
            args = requestE2EEKeyExchange_args()
            args.reqSeq = reqSeq
            args.temporalPublicKey = temporalPublicKey
            args.publicKey = publicKey
            args.verifier = verifier
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_requestE2EEKeyExchange(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = requestE2EEKeyExchange_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def getLastE2EEPublicKeys(self, ctx, chatMid):
        """
        Args:
            ctx: FContext
            chatMid: string
        """
        return self._methods['getLastE2EEPublicKeys']([ctx, chatMid])

    def _getLastE2EEPublicKeys(self, ctx, chatMid):
        self._send_getLastE2EEPublicKeys(ctx, chatMid)
        return self._recv_getLastE2EEPublicKeys(ctx)

    def _send_getLastE2EEPublicKeys(self, ctx, chatMid):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getLastE2EEPublicKeys', TMessageType.CALL, 0)
            args = getLastE2EEPublicKeys_args()
            args.chatMid = chatMid
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getLastE2EEPublicKeys(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getLastE2EEPublicKeys_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getLastE2EEPublicKeys failed: unknown result")
        raise x

    def registerE2EEPublicKey(self, ctx, reqSeq, publicKey):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            publicKey: E2EEPublicKey
        """
        return self._methods['registerE2EEPublicKey']([ctx, reqSeq, publicKey])

    def _registerE2EEPublicKey(self, ctx, reqSeq, publicKey):
        self._send_registerE2EEPublicKey(ctx, reqSeq, publicKey)
        return self._recv_registerE2EEPublicKey(ctx)

    def _send_registerE2EEPublicKey(self, ctx, reqSeq, publicKey):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('registerE2EEPublicKey', TMessageType.CALL, 0)
            args = registerE2EEPublicKey_args()
            args.reqSeq = reqSeq
            args.publicKey = publicKey
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_registerE2EEPublicKey(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = registerE2EEPublicKey_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "registerE2EEPublicKey failed: unknown result")
        raise x

    def getE2EEPublicKeys(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getE2EEPublicKeys']([ctx])

    def _getE2EEPublicKeys(self, ctx):
        self._send_getE2EEPublicKeys(ctx)
        return self._recv_getE2EEPublicKeys(ctx)

    def _send_getE2EEPublicKeys(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getE2EEPublicKeys', TMessageType.CALL, 0)
            args = getE2EEPublicKeys_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getE2EEPublicKeys(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getE2EEPublicKeys_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getE2EEPublicKeys failed: unknown result")
        raise x

    def getE2EEPublicKeysEx(self, ctx, ignoreE2EEStatus):
        """
        Args:
            ctx: FContext
            ignoreE2EEStatus: boolean
        """
        return self._methods['getE2EEPublicKeysEx']([ctx, ignoreE2EEStatus])

    def _getE2EEPublicKeysEx(self, ctx, ignoreE2EEStatus):
        self._send_getE2EEPublicKeysEx(ctx, ignoreE2EEStatus)
        return self._recv_getE2EEPublicKeysEx(ctx)

    def _send_getE2EEPublicKeysEx(self, ctx, ignoreE2EEStatus):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getE2EEPublicKeysEx', TMessageType.CALL, 0)
            args = getE2EEPublicKeysEx_args()
            args.ignoreE2EEStatus = ignoreE2EEStatus
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getE2EEPublicKeysEx(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getE2EEPublicKeysEx_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getE2EEPublicKeysEx failed: unknown result")
        raise x

    def getReadMessageOpsInBulk(self, ctx, chatIds):
        """
        Args:
            ctx: FContext
            chatIds: list of string
        """
        return self._methods['getReadMessageOpsInBulk']([ctx, chatIds])

    def _getReadMessageOpsInBulk(self, ctx, chatIds):
        self._send_getReadMessageOpsInBulk(ctx, chatIds)
        return self._recv_getReadMessageOpsInBulk(ctx)

    def _send_getReadMessageOpsInBulk(self, ctx, chatIds):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getReadMessageOpsInBulk', TMessageType.CALL, 0)
            args = getReadMessageOpsInBulk_args()
            args.chatIds = chatIds
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getReadMessageOpsInBulk(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getReadMessageOpsInBulk_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getReadMessageOpsInBulk failed: unknown result")
        raise x

    def sendEvent(self, ctx, seq, message):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            message: Message
        """
        return self._methods['sendEvent']([ctx, seq, message])

    def _sendEvent(self, ctx, seq, message):
        self._send_sendEvent(ctx, seq, message)
        return self._recv_sendEvent(ctx)

    def _send_sendEvent(self, ctx, seq, message):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('sendEvent', TMessageType.CALL, 0)
            args = sendEvent_args()
            args.seq = seq
            args.message = message
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_sendEvent(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = sendEvent_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "sendEvent failed: unknown result")
        raise x

    def sendMessage(self, ctx, seq, message):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            message: Message
        """
        return self._methods['sendMessage']([ctx, seq, message])

    def _sendMessage(self, ctx, seq, message):
        self._send_sendMessage(ctx, seq, message)
        return self._recv_sendMessage(ctx)

    def _send_sendMessage(self, ctx, seq, message):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('sendMessage', TMessageType.CALL, 0)
            args = sendMessage_args()
            args.seq = seq
            args.message = message
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_sendMessage(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = sendMessage_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "sendMessage failed: unknown result")
        raise x

    def sendMessageIgnored(self, ctx, seq, consumer, messageIds):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            consumer: string
            messageIds: list of string
        """
        return self._methods['sendMessageIgnored']([ctx, seq, consumer, messageIds])

    def _sendMessageIgnored(self, ctx, seq, consumer, messageIds):
        self._send_sendMessageIgnored(ctx, seq, consumer, messageIds)
        self._recv_sendMessageIgnored(ctx)

    def _send_sendMessageIgnored(self, ctx, seq, consumer, messageIds):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('sendMessageIgnored', TMessageType.CALL, 0)
            args = sendMessageIgnored_args()
            args.seq = seq
            args.consumer = consumer
            args.messageIds = messageIds
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_sendMessageIgnored(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = sendMessageIgnored_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def sendMessageReceipt(self, ctx, seq, consumer, messageIds):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            consumer: string
            messageIds: list of string
        """
        return self._methods['sendMessageReceipt']([ctx, seq, consumer, messageIds])

    def _sendMessageReceipt(self, ctx, seq, consumer, messageIds):
        self._send_sendMessageReceipt(ctx, seq, consumer, messageIds)
        self._recv_sendMessageReceipt(ctx)

    def _send_sendMessageReceipt(self, ctx, seq, consumer, messageIds):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('sendMessageReceipt', TMessageType.CALL, 0)
            args = sendMessageReceipt_args()
            args.seq = seq
            args.consumer = consumer
            args.messageIds = messageIds
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_sendMessageReceipt(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = sendMessageReceipt_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def findContactByMetaTag(self, ctx, userid, reference):
        """
        Args:
            ctx: FContext
            userid: string
            reference: string
        """
        return self._methods['findContactByMetaTag']([ctx, userid, reference])

    def _findContactByMetaTag(self, ctx, userid, reference):
        self._send_findContactByMetaTag(ctx, userid, reference)
        return self._recv_findContactByMetaTag(ctx)

    def _send_findContactByMetaTag(self, ctx, userid, reference):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('findContactByMetaTag', TMessageType.CALL, 0)
            args = findContactByMetaTag_args()
            args.userid = userid
            args.reference = reference
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_findContactByMetaTag(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = findContactByMetaTag_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "findContactByMetaTag failed: unknown result")
        raise x

    def sendMessageToMyHome(self, ctx, seq, message):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            message: Message
        """
        return self._methods['sendMessageToMyHome']([ctx, seq, message])

    def _sendMessageToMyHome(self, ctx, seq, message):
        self._send_sendMessageToMyHome(ctx, seq, message)
        return self._recv_sendMessageToMyHome(ctx)

    def _send_sendMessageToMyHome(self, ctx, seq, message):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('sendMessageToMyHome', TMessageType.CALL, 0)
            args = sendMessageToMyHome_args()
            args.seq = seq
            args.message = message
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_sendMessageToMyHome(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = sendMessageToMyHome_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "sendMessageToMyHome failed: unknown result")
        raise x

    def setBuddyLocation(self, ctx, mid, index, location):
        """
        Args:
            ctx: FContext
            mid: string
            index: int (signed 32 bits)
            location: Geolocation
        """
        return self._methods['setBuddyLocation']([ctx, mid, index, location])

    def _setBuddyLocation(self, ctx, mid, index, location):
        self._send_setBuddyLocation(ctx, mid, index, location)
        self._recv_setBuddyLocation(ctx)

    def _send_setBuddyLocation(self, ctx, mid, index, location):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('setBuddyLocation', TMessageType.CALL, 0)
            args = setBuddyLocation_args()
            args.mid = mid
            args.index = index
            args.location = location
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_setBuddyLocation(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = setBuddyLocation_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def setIdentityCredential(self, ctx, identifier, verifier, provider):
        """
        Args:
            ctx: FContext
            identifier: string
            verifier: string
            provider: IdentityProvider
        """
        return self._methods['setIdentityCredential']([ctx, identifier, verifier, provider])

    def _setIdentityCredential(self, ctx, identifier, verifier, provider):
        self._send_setIdentityCredential(ctx, identifier, verifier, provider)
        self._recv_setIdentityCredential(ctx)

    def _send_setIdentityCredential(self, ctx, identifier, verifier, provider):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('setIdentityCredential', TMessageType.CALL, 0)
            args = setIdentityCredential_args()
            args.identifier = identifier
            args.verifier = verifier
            args.provider = provider
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_setIdentityCredential(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = setIdentityCredential_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def setNotificationsEnabled(self, ctx, reqSeq, type, target, enablement):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            type: MIDType
            target: string
            enablement: boolean
        """
        return self._methods['setNotificationsEnabled']([ctx, reqSeq, type, target, enablement])

    def _setNotificationsEnabled(self, ctx, reqSeq, type, target, enablement):
        self._send_setNotificationsEnabled(ctx, reqSeq, type, target, enablement)
        self._recv_setNotificationsEnabled(ctx)

    def _send_setNotificationsEnabled(self, ctx, reqSeq, type, target, enablement):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('setNotificationsEnabled', TMessageType.CALL, 0)
            args = setNotificationsEnabled_args()
            args.reqSeq = reqSeq
            args.type = type
            args.target = target
            args.enablement = enablement
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_setNotificationsEnabled(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = setNotificationsEnabled_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def startUpdateVerification(self, ctx, region, carrier, phone, udidHash, deviceInfo, networkCode, locale):
        """
        Args:
            ctx: FContext
            region: string
            carrier: CarrierCode
            phone: string
            udidHash: string
            deviceInfo: DeviceInfo
            networkCode: string
            locale: string
        """
        return self._methods['startUpdateVerification']([ctx, region, carrier, phone, udidHash, deviceInfo, networkCode, locale])

    def _startUpdateVerification(self, ctx, region, carrier, phone, udidHash, deviceInfo, networkCode, locale):
        self._send_startUpdateVerification(ctx, region, carrier, phone, udidHash, deviceInfo, networkCode, locale)
        return self._recv_startUpdateVerification(ctx)

    def _send_startUpdateVerification(self, ctx, region, carrier, phone, udidHash, deviceInfo, networkCode, locale):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('startUpdateVerification', TMessageType.CALL, 0)
            args = startUpdateVerification_args()
            args.region = region
            args.carrier = carrier
            args.phone = phone
            args.udidHash = udidHash
            args.deviceInfo = deviceInfo
            args.networkCode = networkCode
            args.locale = locale
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_startUpdateVerification(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = startUpdateVerification_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "startUpdateVerification failed: unknown result")
        raise x

    def startVerification(self, ctx, region, carrier, phone, udidHash, deviceInfo, networkCode, mid, locale, simInfo, oldUdidHash):
        """
        Args:
            ctx: FContext
            region: string
            carrier: CarrierCode
            phone: string
            udidHash: string
            deviceInfo: DeviceInfo
            networkCode: string
            mid: string
            locale: string
            simInfo: SIMInfo
            oldUdidHash: string
        """
        return self._methods['startVerification']([ctx, region, carrier, phone, udidHash, deviceInfo, networkCode, mid, locale, simInfo, oldUdidHash])

    def _startVerification(self, ctx, region, carrier, phone, udidHash, deviceInfo, networkCode, mid, locale, simInfo, oldUdidHash):
        self._send_startVerification(ctx, region, carrier, phone, udidHash, deviceInfo, networkCode, mid, locale, simInfo, oldUdidHash)
        return self._recv_startVerification(ctx)

    def _send_startVerification(self, ctx, region, carrier, phone, udidHash, deviceInfo, networkCode, mid, locale, simInfo, oldUdidHash):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('startVerification', TMessageType.CALL, 0)
            args = startVerification_args()
            args.region = region
            args.carrier = carrier
            args.phone = phone
            args.udidHash = udidHash
            args.deviceInfo = deviceInfo
            args.networkCode = networkCode
            args.mid = mid
            args.locale = locale
            args.simInfo = simInfo
            args.oldUdidHash = oldUdidHash
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_startVerification(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = startVerification_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "startVerification failed: unknown result")
        raise x

    def updateGroupPreferenceAttribute(self, ctx, reqSeq, groupMid, updatedAttrs):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            groupMid: string
            updatedAttrs: dict of <GroupPreferenceAttribute, string>
        """
        return self._methods['updateGroupPreferenceAttribute']([ctx, reqSeq, groupMid, updatedAttrs])

    def _updateGroupPreferenceAttribute(self, ctx, reqSeq, groupMid, updatedAttrs):
        self._send_updateGroupPreferenceAttribute(ctx, reqSeq, groupMid, updatedAttrs)
        self._recv_updateGroupPreferenceAttribute(ctx)

    def _send_updateGroupPreferenceAttribute(self, ctx, reqSeq, groupMid, updatedAttrs):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('updateGroupPreferenceAttribute', TMessageType.CALL, 0)
            args = updateGroupPreferenceAttribute_args()
            args.reqSeq = reqSeq
            args.groupMid = groupMid
            args.updatedAttrs = updatedAttrs
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_updateGroupPreferenceAttribute(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = updateGroupPreferenceAttribute_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def createRoomV2(self, ctx, reqSeq, contactIds):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            contactIds: list of string
        """
        return self._methods['createRoomV2']([ctx, reqSeq, contactIds])

    def _createRoomV2(self, ctx, reqSeq, contactIds):
        self._send_createRoomV2(ctx, reqSeq, contactIds)
        return self._recv_createRoomV2(ctx)

    def _send_createRoomV2(self, ctx, reqSeq, contactIds):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('createRoomV2', TMessageType.CALL, 0)
            args = createRoomV2_args()
            args.reqSeq = reqSeq
            args.contactIds = contactIds
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_createRoomV2(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = createRoomV2_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "createRoomV2 failed: unknown result")
        raise x

    def storeUpdateProfileAttribute(self, ctx, seq, profileAttribute, value):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            profileAttribute: ProfileAttribute
            value: string
        """
        return self._methods['storeUpdateProfileAttribute']([ctx, seq, profileAttribute, value])

    def _storeUpdateProfileAttribute(self, ctx, seq, profileAttribute, value):
        self._send_storeUpdateProfileAttribute(ctx, seq, profileAttribute, value)
        self._recv_storeUpdateProfileAttribute(ctx)

    def _send_storeUpdateProfileAttribute(self, ctx, seq, profileAttribute, value):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('storeUpdateProfileAttribute', TMessageType.CALL, 0)
            args = storeUpdateProfileAttribute_args()
            args.seq = seq
            args.profileAttribute = profileAttribute
            args.value = value
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_storeUpdateProfileAttribute(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = storeUpdateProfileAttribute_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def syncContactBySnsIds(self, ctx, reqSeq, modifications):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            modifications: list of SnsFriendModification
        """
        return self._methods['syncContactBySnsIds']([ctx, reqSeq, modifications])

    def _syncContactBySnsIds(self, ctx, reqSeq, modifications):
        self._send_syncContactBySnsIds(ctx, reqSeq, modifications)
        return self._recv_syncContactBySnsIds(ctx)

    def _send_syncContactBySnsIds(self, ctx, reqSeq, modifications):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('syncContactBySnsIds', TMessageType.CALL, 0)
            args = syncContactBySnsIds_args()
            args.reqSeq = reqSeq
            args.modifications = modifications
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_syncContactBySnsIds(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = syncContactBySnsIds_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "syncContactBySnsIds failed: unknown result")
        raise x

    def syncContacts(self, ctx, reqSeq, localContacts):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            localContacts: list of ContactModification
        """
        return self._methods['syncContacts']([ctx, reqSeq, localContacts])

    def _syncContacts(self, ctx, reqSeq, localContacts):
        self._send_syncContacts(ctx, reqSeq, localContacts)
        return self._recv_syncContacts(ctx)

    def _send_syncContacts(self, ctx, reqSeq, localContacts):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('syncContacts', TMessageType.CALL, 0)
            args = syncContacts_args()
            args.reqSeq = reqSeq
            args.localContacts = localContacts
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_syncContacts(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = syncContacts_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "syncContacts failed: unknown result")
        raise x

    def trySendMessage(self, ctx, seq, message):
        """
        Args:
            ctx: FContext
            seq: int (signed 32 bits)
            message: Message
        """
        return self._methods['trySendMessage']([ctx, seq, message])

    def _trySendMessage(self, ctx, seq, message):
        self._send_trySendMessage(ctx, seq, message)
        return self._recv_trySendMessage(ctx)

    def _send_trySendMessage(self, ctx, seq, message):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('trySendMessage', TMessageType.CALL, 0)
            args = trySendMessage_args()
            args.seq = seq
            args.message = message
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_trySendMessage(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = trySendMessage_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "trySendMessage failed: unknown result")
        raise x

    def getNextMessagesV2(self, ctx, messageBoxId, startMessageId, messagesCount):
        """
        Args:
            ctx: FContext
            messageBoxId: string
            startMessageId: MessageBoxV2MessageId
            messagesCount: int (signed 32 bits)
        """
        return self._methods['getNextMessagesV2']([ctx, messageBoxId, startMessageId, messagesCount])

    def _getNextMessagesV2(self, ctx, messageBoxId, startMessageId, messagesCount):
        self._send_getNextMessagesV2(ctx, messageBoxId, startMessageId, messagesCount)
        return self._recv_getNextMessagesV2(ctx)

    def _send_getNextMessagesV2(self, ctx, messageBoxId, startMessageId, messagesCount):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getNextMessagesV2', TMessageType.CALL, 0)
            args = getNextMessagesV2_args()
            args.messageBoxId = messageBoxId
            args.startMessageId = startMessageId
            args.messagesCount = messagesCount
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getNextMessagesV2(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getNextMessagesV2_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getNextMessagesV2 failed: unknown result")
        raise x

    def getMessageBoxCompactWrapUpV2(self, ctx, messageBoxId):
        """
        Args:
            ctx: FContext
            messageBoxId: string
        """
        return self._methods['getMessageBoxCompactWrapUpV2']([ctx, messageBoxId])

    def _getMessageBoxCompactWrapUpV2(self, ctx, messageBoxId):
        self._send_getMessageBoxCompactWrapUpV2(ctx, messageBoxId)
        return self._recv_getMessageBoxCompactWrapUpV2(ctx)

    def _send_getMessageBoxCompactWrapUpV2(self, ctx, messageBoxId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getMessageBoxCompactWrapUpV2', TMessageType.CALL, 0)
            args = getMessageBoxCompactWrapUpV2_args()
            args.messageBoxId = messageBoxId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getMessageBoxCompactWrapUpV2(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getMessageBoxCompactWrapUpV2_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getMessageBoxCompactWrapUpV2 failed: unknown result")
        raise x

    def getRecentMessagesV2(self, ctx, messageBoxId, messagesCount):
        """
        Args:
            ctx: FContext
            messageBoxId: string
            messagesCount: int (signed 32 bits)
        """
        return self._methods['getRecentMessagesV2']([ctx, messageBoxId, messagesCount])

    def _getRecentMessagesV2(self, ctx, messageBoxId, messagesCount):
        self._send_getRecentMessagesV2(ctx, messageBoxId, messagesCount)
        return self._recv_getRecentMessagesV2(ctx)

    def _send_getRecentMessagesV2(self, ctx, messageBoxId, messagesCount):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getRecentMessagesV2', TMessageType.CALL, 0)
            args = getRecentMessagesV2_args()
            args.messageBoxId = messageBoxId
            args.messagesCount = messagesCount
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getRecentMessagesV2(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getRecentMessagesV2_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getRecentMessagesV2 failed: unknown result")
        raise x

    def validateContactsOnBot(self, ctx, contacts):
        """
        Args:
            ctx: FContext
            contacts: list of string
        """
        return self._methods['validateContactsOnBot']([ctx, contacts])

    def _validateContactsOnBot(self, ctx, contacts):
        self._send_validateContactsOnBot(ctx, contacts)
        return self._recv_validateContactsOnBot(ctx)

    def _send_validateContactsOnBot(self, ctx, contacts):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('validateContactsOnBot', TMessageType.CALL, 0)
            args = validateContactsOnBot_args()
            args.contacts = contacts
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_validateContactsOnBot(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = validateContactsOnBot_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "validateContactsOnBot failed: unknown result")
        raise x

    def tryFriendRequest(self, ctx, midOrEMid, method, friendRequestParams):
        """
        Args:
            ctx: FContext
            midOrEMid: string
            method: FriendRequestMethod
            friendRequestParams: string
        """
        return self._methods['tryFriendRequest']([ctx, midOrEMid, method, friendRequestParams])

    def _tryFriendRequest(self, ctx, midOrEMid, method, friendRequestParams):
        self._send_tryFriendRequest(ctx, midOrEMid, method, friendRequestParams)
        self._recv_tryFriendRequest(ctx)

    def _send_tryFriendRequest(self, ctx, midOrEMid, method, friendRequestParams):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('tryFriendRequest', TMessageType.CALL, 0)
            args = tryFriendRequest_args()
            args.midOrEMid = midOrEMid
            args.method = method
            args.friendRequestParams = friendRequestParams
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_tryFriendRequest(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = tryFriendRequest_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def unblockContact(self, ctx, reqSeq, id):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            id: string
        """
        return self._methods['unblockContact']([ctx, reqSeq, id])

    def _unblockContact(self, ctx, reqSeq, id):
        self._send_unblockContact(ctx, reqSeq, id)
        self._recv_unblockContact(ctx)

    def _send_unblockContact(self, ctx, reqSeq, id):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('unblockContact', TMessageType.CALL, 0)
            args = unblockContact_args()
            args.reqSeq = reqSeq
            args.id = id
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_unblockContact(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = unblockContact_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def unblockRecommendation(self, ctx, reqSeq, id):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            id: string
        """
        return self._methods['unblockRecommendation']([ctx, reqSeq, id])

    def _unblockRecommendation(self, ctx, reqSeq, id):
        self._send_unblockRecommendation(ctx, reqSeq, id)
        self._recv_unblockRecommendation(ctx)

    def _send_unblockRecommendation(self, ctx, reqSeq, id):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('unblockRecommendation', TMessageType.CALL, 0)
            args = unblockRecommendation_args()
            args.reqSeq = reqSeq
            args.id = id
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_unblockRecommendation(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = unblockRecommendation_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def unregisterUserAndDevice(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['unregisterUserAndDevice']([ctx])

    def _unregisterUserAndDevice(self, ctx):
        self._send_unregisterUserAndDevice(ctx)
        return self._recv_unregisterUserAndDevice(ctx)

    def _send_unregisterUserAndDevice(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('unregisterUserAndDevice', TMessageType.CALL, 0)
            args = unregisterUserAndDevice_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_unregisterUserAndDevice(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = unregisterUserAndDevice_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "unregisterUserAndDevice failed: unknown result")
        raise x

    def updateApnsDeviceToken(self, ctx, apnsDeviceToken):
        """
        Args:
            ctx: FContext
            apnsDeviceToken: binary string
        """
        return self._methods['updateApnsDeviceToken']([ctx, apnsDeviceToken])

    def _updateApnsDeviceToken(self, ctx, apnsDeviceToken):
        self._send_updateApnsDeviceToken(ctx, apnsDeviceToken)
        self._recv_updateApnsDeviceToken(ctx)

    def _send_updateApnsDeviceToken(self, ctx, apnsDeviceToken):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('updateApnsDeviceToken', TMessageType.CALL, 0)
            args = updateApnsDeviceToken_args()
            args.apnsDeviceToken = apnsDeviceToken
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_updateApnsDeviceToken(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = updateApnsDeviceToken_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def updateBuddySetting(self, ctx, key, value):
        """
        Args:
            ctx: FContext
            key: string
            value: string
        """
        return self._methods['updateBuddySetting']([ctx, key, value])

    def _updateBuddySetting(self, ctx, key, value):
        self._send_updateBuddySetting(ctx, key, value)
        self._recv_updateBuddySetting(ctx)

    def _send_updateBuddySetting(self, ctx, key, value):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('updateBuddySetting', TMessageType.CALL, 0)
            args = updateBuddySetting_args()
            args.key = key
            args.value = value
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_updateBuddySetting(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = updateBuddySetting_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def updateC2DMRegistrationId(self, ctx, registrationId):
        """
        Args:
            ctx: FContext
            registrationId: string
        """
        return self._methods['updateC2DMRegistrationId']([ctx, registrationId])

    def _updateC2DMRegistrationId(self, ctx, registrationId):
        self._send_updateC2DMRegistrationId(ctx, registrationId)
        self._recv_updateC2DMRegistrationId(ctx)

    def _send_updateC2DMRegistrationId(self, ctx, registrationId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('updateC2DMRegistrationId', TMessageType.CALL, 0)
            args = updateC2DMRegistrationId_args()
            args.registrationId = registrationId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_updateC2DMRegistrationId(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = updateC2DMRegistrationId_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def updateContactSetting(self, ctx, reqSeq, mid, flag, value):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            mid: string
            flag: ContactSetting
            value: string
        """
        return self._methods['updateContactSetting']([ctx, reqSeq, mid, flag, value])

    def _updateContactSetting(self, ctx, reqSeq, mid, flag, value):
        self._send_updateContactSetting(ctx, reqSeq, mid, flag, value)
        self._recv_updateContactSetting(ctx)

    def _send_updateContactSetting(self, ctx, reqSeq, mid, flag, value):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('updateContactSetting', TMessageType.CALL, 0)
            args = updateContactSetting_args()
            args.reqSeq = reqSeq
            args.mid = mid
            args.flag = flag
            args.value = value
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_updateContactSetting(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = updateContactSetting_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def updateCustomModeSettings(self, ctx, customMode, paramMap):
        """
        Args:
            ctx: FContext
            customMode: CustomMode
            paramMap: dict of <string, string>
        """
        return self._methods['updateCustomModeSettings']([ctx, customMode, paramMap])

    def _updateCustomModeSettings(self, ctx, customMode, paramMap):
        self._send_updateCustomModeSettings(ctx, customMode, paramMap)
        self._recv_updateCustomModeSettings(ctx)

    def _send_updateCustomModeSettings(self, ctx, customMode, paramMap):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('updateCustomModeSettings', TMessageType.CALL, 0)
            args = updateCustomModeSettings_args()
            args.customMode = customMode
            args.paramMap = paramMap
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_updateCustomModeSettings(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = updateCustomModeSettings_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def updateDeviceInfo(self, ctx, deviceUid, deviceInfo):
        """
        Args:
            ctx: FContext
            deviceUid: string
            deviceInfo: DeviceInfo
        """
        return self._methods['updateDeviceInfo']([ctx, deviceUid, deviceInfo])

    def _updateDeviceInfo(self, ctx, deviceUid, deviceInfo):
        self._send_updateDeviceInfo(ctx, deviceUid, deviceInfo)
        self._recv_updateDeviceInfo(ctx)

    def _send_updateDeviceInfo(self, ctx, deviceUid, deviceInfo):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('updateDeviceInfo', TMessageType.CALL, 0)
            args = updateDeviceInfo_args()
            args.deviceUid = deviceUid
            args.deviceInfo = deviceInfo
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_updateDeviceInfo(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = updateDeviceInfo_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def updateGroup(self, ctx, reqSeq, group):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            group: Group
        """
        return self._methods['updateGroup']([ctx, reqSeq, group])

    def _updateGroup(self, ctx, reqSeq, group):
        self._send_updateGroup(ctx, reqSeq, group)
        self._recv_updateGroup(ctx)

    def _send_updateGroup(self, ctx, reqSeq, group):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('updateGroup', TMessageType.CALL, 0)
            args = updateGroup_args()
            args.reqSeq = reqSeq
            args.group = group
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_updateGroup(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = updateGroup_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def updateNotificationToken(self, ctx, type, token):
        """
        Args:
            ctx: FContext
            type: NotificationType
            token: string
        """
        return self._methods['updateNotificationToken']([ctx, type, token])

    def _updateNotificationToken(self, ctx, type, token):
        self._send_updateNotificationToken(ctx, type, token)
        self._recv_updateNotificationToken(ctx)

    def _send_updateNotificationToken(self, ctx, type, token):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('updateNotificationToken', TMessageType.CALL, 0)
            args = updateNotificationToken_args()
            args.type = type
            args.token = token
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_updateNotificationToken(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = updateNotificationToken_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def updateNotificationTokenWithBytes(self, ctx, type, token):
        """
        Args:
            ctx: FContext
            type: NotificationType
            token: binary string
        """
        return self._methods['updateNotificationTokenWithBytes']([ctx, type, token])

    def _updateNotificationTokenWithBytes(self, ctx, type, token):
        self._send_updateNotificationTokenWithBytes(ctx, type, token)
        self._recv_updateNotificationTokenWithBytes(ctx)

    def _send_updateNotificationTokenWithBytes(self, ctx, type, token):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('updateNotificationTokenWithBytes', TMessageType.CALL, 0)
            args = updateNotificationTokenWithBytes_args()
            args.type = type
            args.token = token
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_updateNotificationTokenWithBytes(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = updateNotificationTokenWithBytes_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def updateProfile(self, ctx, reqSeq, profile):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            profile: Profile
        """
        return self._methods['updateProfile']([ctx, reqSeq, profile])

    def _updateProfile(self, ctx, reqSeq, profile):
        self._send_updateProfile(ctx, reqSeq, profile)
        self._recv_updateProfile(ctx)

    def _send_updateProfile(self, ctx, reqSeq, profile):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('updateProfile', TMessageType.CALL, 0)
            args = updateProfile_args()
            args.reqSeq = reqSeq
            args.profile = profile
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_updateProfile(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = updateProfile_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def updateProfileAttribute(self, ctx, reqSeq, attr, value):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            attr: ProfileAttribute
            value: string
        """
        return self._methods['updateProfileAttribute']([ctx, reqSeq, attr, value])

    def _updateProfileAttribute(self, ctx, reqSeq, attr, value):
        self._send_updateProfileAttribute(ctx, reqSeq, attr, value)
        self._recv_updateProfileAttribute(ctx)

    def _send_updateProfileAttribute(self, ctx, reqSeq, attr, value):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('updateProfileAttribute', TMessageType.CALL, 0)
            args = updateProfileAttribute_args()
            args.reqSeq = reqSeq
            args.attr = attr
            args.value = value
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_updateProfileAttribute(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = updateProfileAttribute_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def updateRegion(self, ctx, region):
        """
        Args:
            ctx: FContext
            region: string
        """
        return self._methods['updateRegion']([ctx, region])

    def _updateRegion(self, ctx, region):
        self._send_updateRegion(ctx, region)
        self._recv_updateRegion(ctx)

    def _send_updateRegion(self, ctx, region):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('updateRegion', TMessageType.CALL, 0)
            args = updateRegion_args()
            args.region = region
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_updateRegion(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = updateRegion_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def updateSettings(self, ctx, reqSeq, settings):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            settings: Settings
        """
        return self._methods['updateSettings']([ctx, reqSeq, settings])

    def _updateSettings(self, ctx, reqSeq, settings):
        self._send_updateSettings(ctx, reqSeq, settings)
        self._recv_updateSettings(ctx)

    def _send_updateSettings(self, ctx, reqSeq, settings):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('updateSettings', TMessageType.CALL, 0)
            args = updateSettings_args()
            args.reqSeq = reqSeq
            args.settings = settings
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_updateSettings(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = updateSettings_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def updateSettings2(self, ctx, reqSeq, settings):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            settings: Settings
        """
        return self._methods['updateSettings2']([ctx, reqSeq, settings])

    def _updateSettings2(self, ctx, reqSeq, settings):
        self._send_updateSettings2(ctx, reqSeq, settings)
        return self._recv_updateSettings2(ctx)

    def _send_updateSettings2(self, ctx, reqSeq, settings):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('updateSettings2', TMessageType.CALL, 0)
            args = updateSettings2_args()
            args.reqSeq = reqSeq
            args.settings = settings
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_updateSettings2(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = updateSettings2_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "updateSettings2 failed: unknown result")
        raise x

    def updateSettingsAttribute(self, ctx, reqSeq, attr, value):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            attr: SettingsAttribute
            value: string
        """
        return self._methods['updateSettingsAttribute']([ctx, reqSeq, attr, value])

    def _updateSettingsAttribute(self, ctx, reqSeq, attr, value):
        self._send_updateSettingsAttribute(ctx, reqSeq, attr, value)
        self._recv_updateSettingsAttribute(ctx)

    def _send_updateSettingsAttribute(self, ctx, reqSeq, attr, value):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('updateSettingsAttribute', TMessageType.CALL, 0)
            args = updateSettingsAttribute_args()
            args.reqSeq = reqSeq
            args.attr = attr
            args.value = value
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_updateSettingsAttribute(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = updateSettingsAttribute_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def updateSettingsAttributes(self, ctx, reqSeq, attrBitset, settings):
        """
        Args:
            ctx: FContext
            reqSeq: int (signed 32 bits)
            attrBitset: int (signed 32 bits)
            settings: Settings
        """
        return self._methods['updateSettingsAttributes']([ctx, reqSeq, attrBitset, settings])

    def _updateSettingsAttributes(self, ctx, reqSeq, attrBitset, settings):
        self._send_updateSettingsAttributes(ctx, reqSeq, attrBitset, settings)
        return self._recv_updateSettingsAttributes(ctx)

    def _send_updateSettingsAttributes(self, ctx, reqSeq, attrBitset, settings):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('updateSettingsAttributes', TMessageType.CALL, 0)
            args = updateSettingsAttributes_args()
            args.reqSeq = reqSeq
            args.attrBitset = attrBitset
            args.settings = settings
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_updateSettingsAttributes(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = updateSettingsAttributes_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "updateSettingsAttributes failed: unknown result")
        raise x

    def verifyIdentityCredential(self, ctx, identityProvider, identifier, password):
        """
        Args:
            ctx: FContext
            identityProvider: IdentityProvider
            identifier: string
            password: string
        """
        return self._methods['verifyIdentityCredential']([ctx, identityProvider, identifier, password])

    def _verifyIdentityCredential(self, ctx, identityProvider, identifier, password):
        self._send_verifyIdentityCredential(ctx, identityProvider, identifier, password)
        self._recv_verifyIdentityCredential(ctx)

    def _send_verifyIdentityCredential(self, ctx, identityProvider, identifier, password):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('verifyIdentityCredential', TMessageType.CALL, 0)
            args = verifyIdentityCredential_args()
            args.identityProvider = identityProvider
            args.identifier = identifier
            args.password = password
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_verifyIdentityCredential(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = verifyIdentityCredential_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def verifyIdentityCredentialWithResult(self, ctx, identityCredential):
        """
        Args:
            ctx: FContext
            identityCredential: IdentityCredential
        """
        return self._methods['verifyIdentityCredentialWithResult']([ctx, identityCredential])

    def _verifyIdentityCredentialWithResult(self, ctx, identityCredential):
        self._send_verifyIdentityCredentialWithResult(ctx, identityCredential)
        return self._recv_verifyIdentityCredentialWithResult(ctx)

    def _send_verifyIdentityCredentialWithResult(self, ctx, identityCredential):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('verifyIdentityCredentialWithResult', TMessageType.CALL, 0)
            args = verifyIdentityCredentialWithResult_args()
            args.identityCredential = identityCredential
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_verifyIdentityCredentialWithResult(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = verifyIdentityCredentialWithResult_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "verifyIdentityCredentialWithResult failed: unknown result")
        raise x

    def verifyPhone(self, ctx, sessionId, pinCode, udidHash):
        """
        Args:
            ctx: FContext
            sessionId: string
            pinCode: string
            udidHash: string
        """
        return self._methods['verifyPhone']([ctx, sessionId, pinCode, udidHash])

    def _verifyPhone(self, ctx, sessionId, pinCode, udidHash):
        self._send_verifyPhone(ctx, sessionId, pinCode, udidHash)
        return self._recv_verifyPhone(ctx)

    def _send_verifyPhone(self, ctx, sessionId, pinCode, udidHash):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('verifyPhone', TMessageType.CALL, 0)
            args = verifyPhone_args()
            args.sessionId = sessionId
            args.pinCode = pinCode
            args.udidHash = udidHash
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_verifyPhone(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = verifyPhone_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "verifyPhone failed: unknown result")
        raise x

    def verifyQrcode(self, ctx, verifier, pinCode):
        """
        Args:
            ctx: FContext
            verifier: string
            pinCode: string
        """
        return self._methods['verifyQrcode']([ctx, verifier, pinCode])

    def _verifyQrcode(self, ctx, verifier, pinCode):
        self._send_verifyQrcode(ctx, verifier, pinCode)
        return self._recv_verifyQrcode(ctx)

    def _send_verifyQrcode(self, ctx, verifier, pinCode):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('verifyQrcode', TMessageType.CALL, 0)
            args = verifyQrcode_args()
            args.verifier = verifier
            args.pinCode = pinCode
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_verifyQrcode(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = verifyQrcode_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "verifyQrcode failed: unknown result")
        raise x

class Processor(FBaseProcessor):

    def __init__(self, handler, middleware=None):
        """
        Create a new Processor.

        Args:
            handler: Iface
        """
        if middleware and not isinstance(middleware, list):
            middleware = [middleware]

        super(Processor, self).__init__()
        self.add_to_processor_map('getChatRoomAnnouncementsBulk', _getChatRoomAnnouncementsBulk(Method(handler.getChatRoomAnnouncementsBulk, middleware), self.get_write_lock()))
        self.add_to_processor_map('getChatRoomAnnouncements', _getChatRoomAnnouncements(Method(handler.getChatRoomAnnouncements, middleware), self.get_write_lock()))
        self.add_to_processor_map('createChatRoomAnnouncement', _createChatRoomAnnouncement(Method(handler.createChatRoomAnnouncement, middleware), self.get_write_lock()))
        self.add_to_processor_map('removeChatRoomAnnouncement', _removeChatRoomAnnouncement(Method(handler.removeChatRoomAnnouncement, middleware), self.get_write_lock()))
        self.add_to_processor_map('unsendMessage', _unsendMessage(Method(handler.unsendMessage, middleware), self.get_write_lock()))
        self.add_to_processor_map('getGroupWithoutMembers', _getGroupWithoutMembers(Method(handler.getGroupWithoutMembers, middleware), self.get_write_lock()))
        self.add_to_processor_map('requestResendMessage', _requestResendMessage(Method(handler.requestResendMessage, middleware), self.get_write_lock()))
        self.add_to_processor_map('respondResendMessage', _respondResendMessage(Method(handler.respondResendMessage, middleware), self.get_write_lock()))
        self.add_to_processor_map('acceptGroupInvitation', _acceptGroupInvitation(Method(handler.acceptGroupInvitation, middleware), self.get_write_lock()))
        self.add_to_processor_map('acceptGroupInvitationByTicket', _acceptGroupInvitationByTicket(Method(handler.acceptGroupInvitationByTicket, middleware), self.get_write_lock()))
        self.add_to_processor_map('acceptProximityMatches', _acceptProximityMatches(Method(handler.acceptProximityMatches, middleware), self.get_write_lock()))
        self.add_to_processor_map('acquireCallRoute', _acquireCallRoute(Method(handler.acquireCallRoute, middleware), self.get_write_lock()))
        self.add_to_processor_map('acquireCallTicket', _acquireCallTicket(Method(handler.acquireCallTicket, middleware), self.get_write_lock()))
        self.add_to_processor_map('acquireEncryptedAccessToken', _acquireEncryptedAccessToken(Method(handler.acquireEncryptedAccessToken, middleware), self.get_write_lock()))
        self.add_to_processor_map('addSnsId', _addSnsId(Method(handler.addSnsId, middleware), self.get_write_lock()))
        self.add_to_processor_map('blockContact', _blockContact(Method(handler.blockContact, middleware), self.get_write_lock()))
        self.add_to_processor_map('blockRecommendation', _blockRecommendation(Method(handler.blockRecommendation, middleware), self.get_write_lock()))
        self.add_to_processor_map('cancelGroupInvitation', _cancelGroupInvitation(Method(handler.cancelGroupInvitation, middleware), self.get_write_lock()))
        self.add_to_processor_map('changeVerificationMethod', _changeVerificationMethod(Method(handler.changeVerificationMethod, middleware), self.get_write_lock()))
        self.add_to_processor_map('clearIdentityCredential', _clearIdentityCredential(Method(handler.clearIdentityCredential, middleware), self.get_write_lock()))
        self.add_to_processor_map('clearMessageBox', _clearMessageBox(Method(handler.clearMessageBox, middleware), self.get_write_lock()))
        self.add_to_processor_map('closeProximityMatch', _closeProximityMatch(Method(handler.closeProximityMatch, middleware), self.get_write_lock()))
        self.add_to_processor_map('commitSendMessage', _commitSendMessage(Method(handler.commitSendMessage, middleware), self.get_write_lock()))
        self.add_to_processor_map('commitSendMessages', _commitSendMessages(Method(handler.commitSendMessages, middleware), self.get_write_lock()))
        self.add_to_processor_map('commitUpdateProfile', _commitUpdateProfile(Method(handler.commitUpdateProfile, middleware), self.get_write_lock()))
        self.add_to_processor_map('confirmEmail', _confirmEmail(Method(handler.confirmEmail, middleware), self.get_write_lock()))
        self.add_to_processor_map('createGroup', _createGroup(Method(handler.createGroup, middleware), self.get_write_lock()))
        self.add_to_processor_map('createQrcodeBase64Image', _createQrcodeBase64Image(Method(handler.createQrcodeBase64Image, middleware), self.get_write_lock()))
        self.add_to_processor_map('createRoom', _createRoom(Method(handler.createRoom, middleware), self.get_write_lock()))
        self.add_to_processor_map('createSession', _createSession(Method(handler.createSession, middleware), self.get_write_lock()))
        self.add_to_processor_map('fetchAnnouncements', _fetchAnnouncements(Method(handler.fetchAnnouncements, middleware), self.get_write_lock()))
        self.add_to_processor_map('fetchMessages', _fetchMessages(Method(handler.fetchMessages, middleware), self.get_write_lock()))
        self.add_to_processor_map('fetchOperations', _fetchOperations(Method(handler.fetchOperations, middleware), self.get_write_lock()))
        self.add_to_processor_map('fetchOps', _fetchOps(Method(handler.fetchOps, middleware), self.get_write_lock()))
        self.add_to_processor_map('findAndAddContactsByEmail', _findAndAddContactsByEmail(Method(handler.findAndAddContactsByEmail, middleware), self.get_write_lock()))
        self.add_to_processor_map('findAndAddContactsByMid', _findAndAddContactsByMid(Method(handler.findAndAddContactsByMid, middleware), self.get_write_lock()))
        self.add_to_processor_map('findGroupByTicketV2', _findGroupByTicketV2(Method(handler.findGroupByTicketV2, middleware), self.get_write_lock()))
        self.add_to_processor_map('findAndAddContactsByPhone', _findAndAddContactsByPhone(Method(handler.findAndAddContactsByPhone, middleware), self.get_write_lock()))
        self.add_to_processor_map('getFriendRequests', _getFriendRequests(Method(handler.getFriendRequests, middleware), self.get_write_lock()))
        self.add_to_processor_map('removeFriendRequest', _removeFriendRequest(Method(handler.removeFriendRequest, middleware), self.get_write_lock()))
        self.add_to_processor_map('findAndAddContactsByUserid', _findAndAddContactsByUserid(Method(handler.findAndAddContactsByUserid, middleware), self.get_write_lock()))
        self.add_to_processor_map('findContactByUserid', _findContactByUserid(Method(handler.findContactByUserid, middleware), self.get_write_lock()))
        self.add_to_processor_map('findContactByUserTicket', _findContactByUserTicket(Method(handler.findContactByUserTicket, middleware), self.get_write_lock()))
        self.add_to_processor_map('findContactsByEmail', _findContactsByEmail(Method(handler.findContactsByEmail, middleware), self.get_write_lock()))
        self.add_to_processor_map('findContactsByPhone', _findContactsByPhone(Method(handler.findContactsByPhone, middleware), self.get_write_lock()))
        self.add_to_processor_map('findSnsIdUserStatus', _findSnsIdUserStatus(Method(handler.findSnsIdUserStatus, middleware), self.get_write_lock()))
        self.add_to_processor_map('finishUpdateVerification', _finishUpdateVerification(Method(handler.finishUpdateVerification, middleware), self.get_write_lock()))
        self.add_to_processor_map('generateUserTicket', _generateUserTicket(Method(handler.generateUserTicket, middleware), self.get_write_lock()))
        self.add_to_processor_map('destroyMessage', _destroyMessage(Method(handler.destroyMessage, middleware), self.get_write_lock()))
        self.add_to_processor_map('getAcceptedProximityMatches', _getAcceptedProximityMatches(Method(handler.getAcceptedProximityMatches, middleware), self.get_write_lock()))
        self.add_to_processor_map('getActiveBuddySubscriberIds', _getActiveBuddySubscriberIds(Method(handler.getActiveBuddySubscriberIds, middleware), self.get_write_lock()))
        self.add_to_processor_map('getAllContactIds', _getAllContactIds(Method(handler.getAllContactIds, middleware), self.get_write_lock()))
        self.add_to_processor_map('getAuthQrcode', _getAuthQrcode(Method(handler.getAuthQrcode, middleware), self.get_write_lock()))
        self.add_to_processor_map('getBlockedContactIds', _getBlockedContactIds(Method(handler.getBlockedContactIds, middleware), self.get_write_lock()))
        self.add_to_processor_map('registerWithPhoneNumber', _registerWithPhoneNumber(Method(handler.registerWithPhoneNumber, middleware), self.get_write_lock()))
        self.add_to_processor_map('registerWithPhoneNumberAndPassword', _registerWithPhoneNumberAndPassword(Method(handler.registerWithPhoneNumberAndPassword, middleware), self.get_write_lock()))
        self.add_to_processor_map('getAnalyticsInfo', _getAnalyticsInfo(Method(handler.getAnalyticsInfo, middleware), self.get_write_lock()))
        self.add_to_processor_map('reportClientStatistics', _reportClientStatistics(Method(handler.reportClientStatistics, middleware), self.get_write_lock()))
        self.add_to_processor_map('verifyPhoneNumberForLogin', _verifyPhoneNumberForLogin(Method(handler.verifyPhoneNumberForLogin, middleware), self.get_write_lock()))
        self.add_to_processor_map('verifyPhoneNumber', _verifyPhoneNumber(Method(handler.verifyPhoneNumber, middleware), self.get_write_lock()))
        self.add_to_processor_map('getBlockedContactIdsByRange', _getBlockedContactIdsByRange(Method(handler.getBlockedContactIdsByRange, middleware), self.get_write_lock()))
        self.add_to_processor_map('getBlockedRecommendationIds', _getBlockedRecommendationIds(Method(handler.getBlockedRecommendationIds, middleware), self.get_write_lock()))
        self.add_to_processor_map('getBuddyBlockerIds', _getBuddyBlockerIds(Method(handler.getBuddyBlockerIds, middleware), self.get_write_lock()))
        self.add_to_processor_map('getBuddyLocation', _getBuddyLocation(Method(handler.getBuddyLocation, middleware), self.get_write_lock()))
        self.add_to_processor_map('getCompactContactsModifiedSince', _getCompactContactsModifiedSince(Method(handler.getCompactContactsModifiedSince, middleware), self.get_write_lock()))
        self.add_to_processor_map('getCompactGroup', _getCompactGroup(Method(handler.getCompactGroup, middleware), self.get_write_lock()))
        self.add_to_processor_map('getCompactRoom', _getCompactRoom(Method(handler.getCompactRoom, middleware), self.get_write_lock()))
        self.add_to_processor_map('getContact', _getContact(Method(handler.getContact, middleware), self.get_write_lock()))
        self.add_to_processor_map('getContacts', _getContacts(Method(handler.getContacts, middleware), self.get_write_lock()))
        self.add_to_processor_map('getContactWithFriendRequestStatus', _getContactWithFriendRequestStatus(Method(handler.getContactWithFriendRequestStatus, middleware), self.get_write_lock()))
        self.add_to_processor_map('getCountryWithRequestIp', _getCountryWithRequestIp(Method(handler.getCountryWithRequestIp, middleware), self.get_write_lock()))
        self.add_to_processor_map('getFavoriteMids', _getFavoriteMids(Method(handler.getFavoriteMids, middleware), self.get_write_lock()))
        self.add_to_processor_map('getGroup', _getGroup(Method(handler.getGroup, middleware), self.get_write_lock()))
        self.add_to_processor_map('getGroupIdsInvited', _getGroupIdsInvited(Method(handler.getGroupIdsInvited, middleware), self.get_write_lock()))
        self.add_to_processor_map('getGroupIdsJoined', _getGroupIdsJoined(Method(handler.getGroupIdsJoined, middleware), self.get_write_lock()))
        self.add_to_processor_map('getGroups', _getGroups(Method(handler.getGroups, middleware), self.get_write_lock()))
        self.add_to_processor_map('getHiddenContactMids', _getHiddenContactMids(Method(handler.getHiddenContactMids, middleware), self.get_write_lock()))
        self.add_to_processor_map('getIdentityIdentifier', _getIdentityIdentifier(Method(handler.getIdentityIdentifier, middleware), self.get_write_lock()))
        self.add_to_processor_map('getLastAnnouncementIndex', _getLastAnnouncementIndex(Method(handler.getLastAnnouncementIndex, middleware), self.get_write_lock()))
        self.add_to_processor_map('getLastOpRevision', _getLastOpRevision(Method(handler.getLastOpRevision, middleware), self.get_write_lock()))
        self.add_to_processor_map('getSuggestRevisions', _getSuggestRevisions(Method(handler.getSuggestRevisions, middleware), self.get_write_lock()))
        self.add_to_processor_map('getPreviousMessagesV2WithReadCount', _getPreviousMessagesV2WithReadCount(Method(handler.getPreviousMessagesV2WithReadCount, middleware), self.get_write_lock()))
        self.add_to_processor_map('getMessageBox', _getMessageBox(Method(handler.getMessageBox, middleware), self.get_write_lock()))
        self.add_to_processor_map('getMessageBoxCompactWrapUp', _getMessageBoxCompactWrapUp(Method(handler.getMessageBoxCompactWrapUp, middleware), self.get_write_lock()))
        self.add_to_processor_map('getMessageBoxCompactWrapUpList', _getMessageBoxCompactWrapUpList(Method(handler.getMessageBoxCompactWrapUpList, middleware), self.get_write_lock()))
        self.add_to_processor_map('getMessageBoxList', _getMessageBoxList(Method(handler.getMessageBoxList, middleware), self.get_write_lock()))
        self.add_to_processor_map('getMessageBoxListByStatus', _getMessageBoxListByStatus(Method(handler.getMessageBoxListByStatus, middleware), self.get_write_lock()))
        self.add_to_processor_map('getMessageBoxWrapUp', _getMessageBoxWrapUp(Method(handler.getMessageBoxWrapUp, middleware), self.get_write_lock()))
        self.add_to_processor_map('getMessageBoxWrapUpList', _getMessageBoxWrapUpList(Method(handler.getMessageBoxWrapUpList, middleware), self.get_write_lock()))
        self.add_to_processor_map('getMessagesBySequenceNumber', _getMessagesBySequenceNumber(Method(handler.getMessagesBySequenceNumber, middleware), self.get_write_lock()))
        self.add_to_processor_map('getNextMessages', _getNextMessages(Method(handler.getNextMessages, middleware), self.get_write_lock()))
        self.add_to_processor_map('getNotificationPolicy', _getNotificationPolicy(Method(handler.getNotificationPolicy, middleware), self.get_write_lock()))
        self.add_to_processor_map('getPreviousMessages', _getPreviousMessages(Method(handler.getPreviousMessages, middleware), self.get_write_lock()))
        self.add_to_processor_map('getProfile', _getProfile(Method(handler.getProfile, middleware), self.get_write_lock()))
        self.add_to_processor_map('getProximityMatchCandidateList', _getProximityMatchCandidateList(Method(handler.getProximityMatchCandidateList, middleware), self.get_write_lock()))
        self.add_to_processor_map('getProximityMatchCandidates', _getProximityMatchCandidates(Method(handler.getProximityMatchCandidates, middleware), self.get_write_lock()))
        self.add_to_processor_map('getRecentMessages', _getRecentMessages(Method(handler.getRecentMessages, middleware), self.get_write_lock()))
        self.add_to_processor_map('getRecommendationIds', _getRecommendationIds(Method(handler.getRecommendationIds, middleware), self.get_write_lock()))
        self.add_to_processor_map('getRoom', _getRoom(Method(handler.getRoom, middleware), self.get_write_lock()))
        self.add_to_processor_map('getRSAKeyInfo', _getRSAKeyInfo(Method(handler.getRSAKeyInfo, middleware), self.get_write_lock()))
        self.add_to_processor_map('getServerTime', _getServerTime(Method(handler.getServerTime, middleware), self.get_write_lock()))
        self.add_to_processor_map('getSessions', _getSessions(Method(handler.getSessions, middleware), self.get_write_lock()))
        self.add_to_processor_map('getSettings', _getSettings(Method(handler.getSettings, middleware), self.get_write_lock()))
        self.add_to_processor_map('getGroupsV2', _getGroupsV2(Method(handler.getGroupsV2, middleware), self.get_write_lock()))
        self.add_to_processor_map('getSettingsAttributes', _getSettingsAttributes(Method(handler.getSettingsAttributes, middleware), self.get_write_lock()))
        self.add_to_processor_map('getSystemConfiguration', _getSystemConfiguration(Method(handler.getSystemConfiguration, middleware), self.get_write_lock()))
        self.add_to_processor_map('getUserTicket', _getUserTicket(Method(handler.getUserTicket, middleware), self.get_write_lock()))
        self.add_to_processor_map('getWapInvitation', _getWapInvitation(Method(handler.getWapInvitation, middleware), self.get_write_lock()))
        self.add_to_processor_map('invalidateUserTicket', _invalidateUserTicket(Method(handler.invalidateUserTicket, middleware), self.get_write_lock()))
        self.add_to_processor_map('inviteFriendsBySms', _inviteFriendsBySms(Method(handler.inviteFriendsBySms, middleware), self.get_write_lock()))
        self.add_to_processor_map('inviteIntoGroup', _inviteIntoGroup(Method(handler.inviteIntoGroup, middleware), self.get_write_lock()))
        self.add_to_processor_map('inviteIntoRoom', _inviteIntoRoom(Method(handler.inviteIntoRoom, middleware), self.get_write_lock()))
        self.add_to_processor_map('inviteViaEmail', _inviteViaEmail(Method(handler.inviteViaEmail, middleware), self.get_write_lock()))
        self.add_to_processor_map('isIdentityIdentifierAvailable', _isIdentityIdentifierAvailable(Method(handler.isIdentityIdentifierAvailable, middleware), self.get_write_lock()))
        self.add_to_processor_map('isUseridAvailable', _isUseridAvailable(Method(handler.isUseridAvailable, middleware), self.get_write_lock()))
        self.add_to_processor_map('kickoutFromGroup', _kickoutFromGroup(Method(handler.kickoutFromGroup, middleware), self.get_write_lock()))
        self.add_to_processor_map('reissueGroupTicket', _reissueGroupTicket(Method(handler.reissueGroupTicket, middleware), self.get_write_lock()))
        self.add_to_processor_map('findGroupByTicket', _findGroupByTicket(Method(handler.findGroupByTicket, middleware), self.get_write_lock()))
        self.add_to_processor_map('leaveGroup', _leaveGroup(Method(handler.leaveGroup, middleware), self.get_write_lock()))
        self.add_to_processor_map('leaveRoom', _leaveRoom(Method(handler.leaveRoom, middleware), self.get_write_lock()))
        self.add_to_processor_map('loginWithIdentityCredential', _loginWithIdentityCredential(Method(handler.loginWithIdentityCredential, middleware), self.get_write_lock()))
        self.add_to_processor_map('loginWithIdentityCredentialForCertificate', _loginWithIdentityCredentialForCertificate(Method(handler.loginWithIdentityCredentialForCertificate, middleware), self.get_write_lock()))
        self.add_to_processor_map('loginWithVerifier', _loginWithVerifier(Method(handler.loginWithVerifier, middleware), self.get_write_lock()))
        self.add_to_processor_map('loginWithVerifierForCerificate', _loginWithVerifierForCerificate(Method(handler.loginWithVerifierForCerificate, middleware), self.get_write_lock()))
        self.add_to_processor_map('loginWithVerifierForCertificate', _loginWithVerifierForCertificate(Method(handler.loginWithVerifierForCertificate, middleware), self.get_write_lock()))
        self.add_to_processor_map('logout', _logout(Method(handler.logout, middleware), self.get_write_lock()))
        self.add_to_processor_map('logoutSession', _logoutSession(Method(handler.logoutSession, middleware), self.get_write_lock()))
        self.add_to_processor_map('noop', _noop(Method(handler.noop, middleware), self.get_write_lock()))
        self.add_to_processor_map('notifiedRedirect', _notifiedRedirect(Method(handler.notifiedRedirect, middleware), self.get_write_lock()))
        self.add_to_processor_map('notifyBuddyOnAir', _notifyBuddyOnAir(Method(handler.notifyBuddyOnAir, middleware), self.get_write_lock()))
        self.add_to_processor_map('notifyIndividualEvent', _notifyIndividualEvent(Method(handler.notifyIndividualEvent, middleware), self.get_write_lock()))
        self.add_to_processor_map('notifyInstalled', _notifyInstalled(Method(handler.notifyInstalled, middleware), self.get_write_lock()))
        self.add_to_processor_map('notifyRegistrationComplete', _notifyRegistrationComplete(Method(handler.notifyRegistrationComplete, middleware), self.get_write_lock()))
        self.add_to_processor_map('notifySleep', _notifySleep(Method(handler.notifySleep, middleware), self.get_write_lock()))
        self.add_to_processor_map('notifyUpdated', _notifyUpdated(Method(handler.notifyUpdated, middleware), self.get_write_lock()))
        self.add_to_processor_map('openProximityMatch', _openProximityMatch(Method(handler.openProximityMatch, middleware), self.get_write_lock()))
        self.add_to_processor_map('registerBuddyUser', _registerBuddyUser(Method(handler.registerBuddyUser, middleware), self.get_write_lock()))
        self.add_to_processor_map('registerBuddyUserid', _registerBuddyUserid(Method(handler.registerBuddyUserid, middleware), self.get_write_lock()))
        self.add_to_processor_map('registerDevice', _registerDevice(Method(handler.registerDevice, middleware), self.get_write_lock()))
        self.add_to_processor_map('registerDeviceWithIdentityCredential', _registerDeviceWithIdentityCredential(Method(handler.registerDeviceWithIdentityCredential, middleware), self.get_write_lock()))
        self.add_to_processor_map('registerDeviceWithoutPhoneNumber', _registerDeviceWithoutPhoneNumber(Method(handler.registerDeviceWithoutPhoneNumber, middleware), self.get_write_lock()))
        self.add_to_processor_map('registerDeviceWithoutPhoneNumberWithIdentityCredential', _registerDeviceWithoutPhoneNumberWithIdentityCredential(Method(handler.registerDeviceWithoutPhoneNumberWithIdentityCredential, middleware), self.get_write_lock()))
        self.add_to_processor_map('registerUserid', _registerUserid(Method(handler.registerUserid, middleware), self.get_write_lock()))
        self.add_to_processor_map('registerWapDevice', _registerWapDevice(Method(handler.registerWapDevice, middleware), self.get_write_lock()))
        self.add_to_processor_map('registerWithExistingSnsIdAndIdentityCredential', _registerWithExistingSnsIdAndIdentityCredential(Method(handler.registerWithExistingSnsIdAndIdentityCredential, middleware), self.get_write_lock()))
        self.add_to_processor_map('registerWithSnsId', _registerWithSnsId(Method(handler.registerWithSnsId, middleware), self.get_write_lock()))
        self.add_to_processor_map('registerWithSnsIdAndIdentityCredential', _registerWithSnsIdAndIdentityCredential(Method(handler.registerWithSnsIdAndIdentityCredential, middleware), self.get_write_lock()))
        self.add_to_processor_map('reissueDeviceCredential', _reissueDeviceCredential(Method(handler.reissueDeviceCredential, middleware), self.get_write_lock()))
        self.add_to_processor_map('reissueUserTicket', _reissueUserTicket(Method(handler.reissueUserTicket, middleware), self.get_write_lock()))
        self.add_to_processor_map('getMessageReadRange', _getMessageReadRange(Method(handler.getMessageReadRange, middleware), self.get_write_lock()))
        self.add_to_processor_map('rejectGroupInvitation', _rejectGroupInvitation(Method(handler.rejectGroupInvitation, middleware), self.get_write_lock()))
        self.add_to_processor_map('releaseSession', _releaseSession(Method(handler.releaseSession, middleware), self.get_write_lock()))
        self.add_to_processor_map('removeAllMessages', _removeAllMessages(Method(handler.removeAllMessages, middleware), self.get_write_lock()))
        self.add_to_processor_map('removeBuddyLocation', _removeBuddyLocation(Method(handler.removeBuddyLocation, middleware), self.get_write_lock()))
        self.add_to_processor_map('removeMessage', _removeMessage(Method(handler.removeMessage, middleware), self.get_write_lock()))
        self.add_to_processor_map('makeUserAddMyselfAsContact', _makeUserAddMyselfAsContact(Method(handler.makeUserAddMyselfAsContact, middleware), self.get_write_lock()))
        self.add_to_processor_map('removeMessageFromMyHome', _removeMessageFromMyHome(Method(handler.removeMessageFromMyHome, middleware), self.get_write_lock()))
        self.add_to_processor_map('removeSnsId', _removeSnsId(Method(handler.removeSnsId, middleware), self.get_write_lock()))
        self.add_to_processor_map('report', _report(Method(handler.report, middleware), self.get_write_lock()))
        self.add_to_processor_map('reportContacts', _reportContacts(Method(handler.reportContacts, middleware), self.get_write_lock()))
        self.add_to_processor_map('reportGroups', _reportGroups(Method(handler.reportGroups, middleware), self.get_write_lock()))
        self.add_to_processor_map('reportProfile', _reportProfile(Method(handler.reportProfile, middleware), self.get_write_lock()))
        self.add_to_processor_map('reportRooms', _reportRooms(Method(handler.reportRooms, middleware), self.get_write_lock()))
        self.add_to_processor_map('findAndAddContactByMetaTag', _findAndAddContactByMetaTag(Method(handler.findAndAddContactByMetaTag, middleware), self.get_write_lock()))
        self.add_to_processor_map('reportSettings', _reportSettings(Method(handler.reportSettings, middleware), self.get_write_lock()))
        self.add_to_processor_map('reportSpam', _reportSpam(Method(handler.reportSpam, middleware), self.get_write_lock()))
        self.add_to_processor_map('reportSpammer', _reportSpammer(Method(handler.reportSpammer, middleware), self.get_write_lock()))
        self.add_to_processor_map('requestAccountPasswordReset', _requestAccountPasswordReset(Method(handler.requestAccountPasswordReset, middleware), self.get_write_lock()))
        self.add_to_processor_map('requestEmailConfirmation', _requestEmailConfirmation(Method(handler.requestEmailConfirmation, middleware), self.get_write_lock()))
        self.add_to_processor_map('requestIdentityUnbind', _requestIdentityUnbind(Method(handler.requestIdentityUnbind, middleware), self.get_write_lock()))
        self.add_to_processor_map('resendEmailConfirmation', _resendEmailConfirmation(Method(handler.resendEmailConfirmation, middleware), self.get_write_lock()))
        self.add_to_processor_map('resendPinCode', _resendPinCode(Method(handler.resendPinCode, middleware), self.get_write_lock()))
        self.add_to_processor_map('resendPinCodeBySMS', _resendPinCodeBySMS(Method(handler.resendPinCodeBySMS, middleware), self.get_write_lock()))
        self.add_to_processor_map('sendChatChecked', _sendChatChecked(Method(handler.sendChatChecked, middleware), self.get_write_lock()))
        self.add_to_processor_map('sendMessageAwaitCommit', _sendMessageAwaitCommit(Method(handler.sendMessageAwaitCommit, middleware), self.get_write_lock()))
        self.add_to_processor_map('sendChatRemoved', _sendChatRemoved(Method(handler.sendChatRemoved, middleware), self.get_write_lock()))
        self.add_to_processor_map('sendContentPreviewUpdated', _sendContentPreviewUpdated(Method(handler.sendContentPreviewUpdated, middleware), self.get_write_lock()))
        self.add_to_processor_map('sendContentReceipt', _sendContentReceipt(Method(handler.sendContentReceipt, middleware), self.get_write_lock()))
        self.add_to_processor_map('sendDummyPush', _sendDummyPush(Method(handler.sendDummyPush, middleware), self.get_write_lock()))
        self.add_to_processor_map('removeE2EEPublicKey', _removeE2EEPublicKey(Method(handler.removeE2EEPublicKey, middleware), self.get_write_lock()))
        self.add_to_processor_map('negotiateE2EEPublicKey', _negotiateE2EEPublicKey(Method(handler.negotiateE2EEPublicKey, middleware), self.get_write_lock()))
        self.add_to_processor_map('getE2EEPublicKey', _getE2EEPublicKey(Method(handler.getE2EEPublicKey, middleware), self.get_write_lock()))
        self.add_to_processor_map('requestE2EEKeyExchange', _requestE2EEKeyExchange(Method(handler.requestE2EEKeyExchange, middleware), self.get_write_lock()))
        self.add_to_processor_map('getLastE2EEPublicKeys', _getLastE2EEPublicKeys(Method(handler.getLastE2EEPublicKeys, middleware), self.get_write_lock()))
        self.add_to_processor_map('registerE2EEPublicKey', _registerE2EEPublicKey(Method(handler.registerE2EEPublicKey, middleware), self.get_write_lock()))
        self.add_to_processor_map('getE2EEPublicKeys', _getE2EEPublicKeys(Method(handler.getE2EEPublicKeys, middleware), self.get_write_lock()))
        self.add_to_processor_map('getE2EEPublicKeysEx', _getE2EEPublicKeysEx(Method(handler.getE2EEPublicKeysEx, middleware), self.get_write_lock()))
        self.add_to_processor_map('getReadMessageOpsInBulk', _getReadMessageOpsInBulk(Method(handler.getReadMessageOpsInBulk, middleware), self.get_write_lock()))
        self.add_to_processor_map('sendEvent', _sendEvent(Method(handler.sendEvent, middleware), self.get_write_lock()))
        self.add_to_processor_map('sendMessage', _sendMessage(Method(handler.sendMessage, middleware), self.get_write_lock()))
        self.add_to_processor_map('sendMessageIgnored', _sendMessageIgnored(Method(handler.sendMessageIgnored, middleware), self.get_write_lock()))
        self.add_to_processor_map('sendMessageReceipt', _sendMessageReceipt(Method(handler.sendMessageReceipt, middleware), self.get_write_lock()))
        self.add_to_processor_map('findContactByMetaTag', _findContactByMetaTag(Method(handler.findContactByMetaTag, middleware), self.get_write_lock()))
        self.add_to_processor_map('sendMessageToMyHome', _sendMessageToMyHome(Method(handler.sendMessageToMyHome, middleware), self.get_write_lock()))
        self.add_to_processor_map('setBuddyLocation', _setBuddyLocation(Method(handler.setBuddyLocation, middleware), self.get_write_lock()))
        self.add_to_processor_map('setIdentityCredential', _setIdentityCredential(Method(handler.setIdentityCredential, middleware), self.get_write_lock()))
        self.add_to_processor_map('setNotificationsEnabled', _setNotificationsEnabled(Method(handler.setNotificationsEnabled, middleware), self.get_write_lock()))
        self.add_to_processor_map('startUpdateVerification', _startUpdateVerification(Method(handler.startUpdateVerification, middleware), self.get_write_lock()))
        self.add_to_processor_map('startVerification', _startVerification(Method(handler.startVerification, middleware), self.get_write_lock()))
        self.add_to_processor_map('updateGroupPreferenceAttribute', _updateGroupPreferenceAttribute(Method(handler.updateGroupPreferenceAttribute, middleware), self.get_write_lock()))
        self.add_to_processor_map('createRoomV2', _createRoomV2(Method(handler.createRoomV2, middleware), self.get_write_lock()))
        self.add_to_processor_map('storeUpdateProfileAttribute', _storeUpdateProfileAttribute(Method(handler.storeUpdateProfileAttribute, middleware), self.get_write_lock()))
        self.add_to_processor_map('syncContactBySnsIds', _syncContactBySnsIds(Method(handler.syncContactBySnsIds, middleware), self.get_write_lock()))
        self.add_to_processor_map('syncContacts', _syncContacts(Method(handler.syncContacts, middleware), self.get_write_lock()))
        self.add_to_processor_map('trySendMessage', _trySendMessage(Method(handler.trySendMessage, middleware), self.get_write_lock()))
        self.add_to_processor_map('getNextMessagesV2', _getNextMessagesV2(Method(handler.getNextMessagesV2, middleware), self.get_write_lock()))
        self.add_to_processor_map('getMessageBoxCompactWrapUpV2', _getMessageBoxCompactWrapUpV2(Method(handler.getMessageBoxCompactWrapUpV2, middleware), self.get_write_lock()))
        self.add_to_processor_map('getRecentMessagesV2', _getRecentMessagesV2(Method(handler.getRecentMessagesV2, middleware), self.get_write_lock()))
        self.add_to_processor_map('validateContactsOnBot', _validateContactsOnBot(Method(handler.validateContactsOnBot, middleware), self.get_write_lock()))
        self.add_to_processor_map('tryFriendRequest', _tryFriendRequest(Method(handler.tryFriendRequest, middleware), self.get_write_lock()))
        self.add_to_processor_map('unblockContact', _unblockContact(Method(handler.unblockContact, middleware), self.get_write_lock()))
        self.add_to_processor_map('unblockRecommendation', _unblockRecommendation(Method(handler.unblockRecommendation, middleware), self.get_write_lock()))
        self.add_to_processor_map('unregisterUserAndDevice', _unregisterUserAndDevice(Method(handler.unregisterUserAndDevice, middleware), self.get_write_lock()))
        self.add_to_processor_map('updateApnsDeviceToken', _updateApnsDeviceToken(Method(handler.updateApnsDeviceToken, middleware), self.get_write_lock()))
        self.add_to_processor_map('updateBuddySetting', _updateBuddySetting(Method(handler.updateBuddySetting, middleware), self.get_write_lock()))
        self.add_to_processor_map('updateC2DMRegistrationId', _updateC2DMRegistrationId(Method(handler.updateC2DMRegistrationId, middleware), self.get_write_lock()))
        self.add_to_processor_map('updateContactSetting', _updateContactSetting(Method(handler.updateContactSetting, middleware), self.get_write_lock()))
        self.add_to_processor_map('updateCustomModeSettings', _updateCustomModeSettings(Method(handler.updateCustomModeSettings, middleware), self.get_write_lock()))
        self.add_to_processor_map('updateDeviceInfo', _updateDeviceInfo(Method(handler.updateDeviceInfo, middleware), self.get_write_lock()))
        self.add_to_processor_map('updateGroup', _updateGroup(Method(handler.updateGroup, middleware), self.get_write_lock()))
        self.add_to_processor_map('updateNotificationToken', _updateNotificationToken(Method(handler.updateNotificationToken, middleware), self.get_write_lock()))
        self.add_to_processor_map('updateNotificationTokenWithBytes', _updateNotificationTokenWithBytes(Method(handler.updateNotificationTokenWithBytes, middleware), self.get_write_lock()))
        self.add_to_processor_map('updateProfile', _updateProfile(Method(handler.updateProfile, middleware), self.get_write_lock()))
        self.add_to_processor_map('updateProfileAttribute', _updateProfileAttribute(Method(handler.updateProfileAttribute, middleware), self.get_write_lock()))
        self.add_to_processor_map('updateRegion', _updateRegion(Method(handler.updateRegion, middleware), self.get_write_lock()))
        self.add_to_processor_map('updateSettings', _updateSettings(Method(handler.updateSettings, middleware), self.get_write_lock()))
        self.add_to_processor_map('updateSettings2', _updateSettings2(Method(handler.updateSettings2, middleware), self.get_write_lock()))
        self.add_to_processor_map('updateSettingsAttribute', _updateSettingsAttribute(Method(handler.updateSettingsAttribute, middleware), self.get_write_lock()))
        self.add_to_processor_map('updateSettingsAttributes', _updateSettingsAttributes(Method(handler.updateSettingsAttributes, middleware), self.get_write_lock()))
        self.add_to_processor_map('verifyIdentityCredential', _verifyIdentityCredential(Method(handler.verifyIdentityCredential, middleware), self.get_write_lock()))
        self.add_to_processor_map('verifyIdentityCredentialWithResult', _verifyIdentityCredentialWithResult(Method(handler.verifyIdentityCredentialWithResult, middleware), self.get_write_lock()))
        self.add_to_processor_map('verifyPhone', _verifyPhone(Method(handler.verifyPhone, middleware), self.get_write_lock()))
        self.add_to_processor_map('verifyQrcode', _verifyQrcode(Method(handler.verifyQrcode, middleware), self.get_write_lock()))


class _getChatRoomAnnouncementsBulk(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getChatRoomAnnouncementsBulk, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getChatRoomAnnouncementsBulk_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getChatRoomAnnouncementsBulk_result()
        try:
            result.success = self._handler([ctx, args.chatRoomMids])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getChatRoomAnnouncementsBulk", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getChatRoomAnnouncementsBulk", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getChatRoomAnnouncementsBulk', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getChatRoomAnnouncementsBulk", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getChatRoomAnnouncements(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getChatRoomAnnouncements, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getChatRoomAnnouncements_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getChatRoomAnnouncements_result()
        try:
            result.success = self._handler([ctx, args.chatRoomMid])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getChatRoomAnnouncements", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getChatRoomAnnouncements", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getChatRoomAnnouncements', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getChatRoomAnnouncements", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _createChatRoomAnnouncement(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_createChatRoomAnnouncement, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = createChatRoomAnnouncement_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createChatRoomAnnouncement_result()
        try:
            result.success = self._handler([ctx, args.reqSeq, args.chatRoomMid, args.type, args.contents])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "createChatRoomAnnouncement", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "createChatRoomAnnouncement", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('createChatRoomAnnouncement', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "createChatRoomAnnouncement", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _removeChatRoomAnnouncement(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_removeChatRoomAnnouncement, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = removeChatRoomAnnouncement_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeChatRoomAnnouncement_result()
        try:
            self._handler([ctx, args.reqSeq, args.chatRoomMid, args.announcementSeq])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "removeChatRoomAnnouncement", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "removeChatRoomAnnouncement", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('removeChatRoomAnnouncement', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "removeChatRoomAnnouncement", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _unsendMessage(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_unsendMessage, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = unsendMessage_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = unsendMessage_result()
        try:
            self._handler([ctx, args.seq, args.messageId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "unsendMessage", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "unsendMessage", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('unsendMessage', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "unsendMessage", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getGroupWithoutMembers(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getGroupWithoutMembers, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getGroupWithoutMembers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getGroupWithoutMembers_result()
        try:
            result.success = self._handler([ctx, args.groupId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getGroupWithoutMembers", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getGroupWithoutMembers", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getGroupWithoutMembers', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getGroupWithoutMembers", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _requestResendMessage(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_requestResendMessage, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = requestResendMessage_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = requestResendMessage_result()
        try:
            self._handler([ctx, args.reqSeq, args.senderMid, args.messageId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "requestResendMessage", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "requestResendMessage", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('requestResendMessage', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "requestResendMessage", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _respondResendMessage(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_respondResendMessage, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = respondResendMessage_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = respondResendMessage_result()
        try:
            self._handler([ctx, args.reqSeq, args.receiverMid, args.originalMessageId, args.resendMessage, args.errorCode])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "respondResendMessage", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "respondResendMessage", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('respondResendMessage', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "respondResendMessage", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _acceptGroupInvitation(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_acceptGroupInvitation, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = acceptGroupInvitation_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = acceptGroupInvitation_result()
        try:
            self._handler([ctx, args.reqSeq, args.groupId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "acceptGroupInvitation", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "acceptGroupInvitation", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('acceptGroupInvitation', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "acceptGroupInvitation", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _acceptGroupInvitationByTicket(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_acceptGroupInvitationByTicket, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = acceptGroupInvitationByTicket_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = acceptGroupInvitationByTicket_result()
        try:
            self._handler([ctx, args.reqSeq, args.GroupMid, args.ticketId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "acceptGroupInvitationByTicket", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "acceptGroupInvitationByTicket", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('acceptGroupInvitationByTicket', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "acceptGroupInvitationByTicket", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _acceptProximityMatches(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_acceptProximityMatches, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = acceptProximityMatches_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = acceptProximityMatches_result()
        try:
            self._handler([ctx, args.sessionId, args.ids])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "acceptProximityMatches", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "acceptProximityMatches", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('acceptProximityMatches', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "acceptProximityMatches", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _acquireCallRoute(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_acquireCallRoute, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = acquireCallRoute_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = acquireCallRoute_result()
        try:
            result.success = self._handler([ctx, args.to])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "acquireCallRoute", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "acquireCallRoute", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('acquireCallRoute', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "acquireCallRoute", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _acquireCallTicket(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_acquireCallTicket, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = acquireCallTicket_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = acquireCallTicket_result()
        try:
            result.success = self._handler([ctx, args.to])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "acquireCallTicket", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "acquireCallTicket", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('acquireCallTicket', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "acquireCallTicket", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _acquireEncryptedAccessToken(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_acquireEncryptedAccessToken, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = acquireEncryptedAccessToken_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = acquireEncryptedAccessToken_result()
        try:
            result.success = self._handler([ctx, args.featureType])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "acquireEncryptedAccessToken", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "acquireEncryptedAccessToken", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('acquireEncryptedAccessToken', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "acquireEncryptedAccessToken", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _addSnsId(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_addSnsId, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = addSnsId_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = addSnsId_result()
        try:
            result.success = self._handler([ctx, args.snsIdType, args.snsAccessToken])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "addSnsId", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "addSnsId", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('addSnsId', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "addSnsId", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _blockContact(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_blockContact, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = blockContact_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = blockContact_result()
        try:
            self._handler([ctx, args.reqSeq, args.id])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "blockContact", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "blockContact", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('blockContact', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "blockContact", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _blockRecommendation(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_blockRecommendation, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = blockRecommendation_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = blockRecommendation_result()
        try:
            self._handler([ctx, args.reqSeq, args.id])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "blockRecommendation", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "blockRecommendation", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('blockRecommendation', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "blockRecommendation", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _cancelGroupInvitation(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_cancelGroupInvitation, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = cancelGroupInvitation_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = cancelGroupInvitation_result()
        try:
            self._handler([ctx, args.reqSeq, args.groupId, args.contactIds])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "cancelGroupInvitation", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "cancelGroupInvitation", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('cancelGroupInvitation', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "cancelGroupInvitation", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _changeVerificationMethod(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_changeVerificationMethod, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = changeVerificationMethod_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = changeVerificationMethod_result()
        try:
            result.success = self._handler([ctx, args.sessionId, args.method])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "changeVerificationMethod", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "changeVerificationMethod", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('changeVerificationMethod', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "changeVerificationMethod", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _clearIdentityCredential(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_clearIdentityCredential, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = clearIdentityCredential_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = clearIdentityCredential_result()
        try:
            self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "clearIdentityCredential", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "clearIdentityCredential", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('clearIdentityCredential', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "clearIdentityCredential", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _clearMessageBox(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_clearMessageBox, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = clearMessageBox_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = clearMessageBox_result()
        try:
            self._handler([ctx, args.channelId, args.messageBoxId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "clearMessageBox", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "clearMessageBox", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('clearMessageBox', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "clearMessageBox", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _closeProximityMatch(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_closeProximityMatch, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = closeProximityMatch_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = closeProximityMatch_result()
        try:
            self._handler([ctx, args.sessionId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "closeProximityMatch", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "closeProximityMatch", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('closeProximityMatch', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "closeProximityMatch", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _commitSendMessage(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_commitSendMessage, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = commitSendMessage_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = commitSendMessage_result()
        try:
            result.success = self._handler([ctx, args.seq, args.messageId, args.receiverMids])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "commitSendMessage", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "commitSendMessage", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('commitSendMessage', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "commitSendMessage", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _commitSendMessages(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_commitSendMessages, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = commitSendMessages_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = commitSendMessages_result()
        try:
            result.success = self._handler([ctx, args.seq, args.messageIds, args.receiverMids])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "commitSendMessages", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "commitSendMessages", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('commitSendMessages', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "commitSendMessages", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _commitUpdateProfile(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_commitUpdateProfile, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = commitUpdateProfile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = commitUpdateProfile_result()
        try:
            result.success = self._handler([ctx, args.seq, args.attrs, args.receiverMids])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "commitUpdateProfile", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "commitUpdateProfile", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('commitUpdateProfile', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "commitUpdateProfile", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _confirmEmail(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_confirmEmail, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = confirmEmail_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = confirmEmail_result()
        try:
            self._handler([ctx, args.verifier, args.pinCode])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "confirmEmail", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "confirmEmail", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('confirmEmail', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "confirmEmail", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _createGroup(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_createGroup, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = createGroup_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createGroup_result()
        try:
            result.success = self._handler([ctx, args.seq, args.name, args.contactIds])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "createGroup", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "createGroup", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('createGroup', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "createGroup", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _createQrcodeBase64Image(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_createQrcodeBase64Image, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = createQrcodeBase64Image_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createQrcodeBase64Image_result()
        try:
            result.success = self._handler([ctx, args.url, args.characterSet, args.imageSize, args.x, args.y, args.width, args.height])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "createQrcodeBase64Image", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "createQrcodeBase64Image", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('createQrcodeBase64Image', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "createQrcodeBase64Image", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _createRoom(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_createRoom, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = createRoom_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createRoom_result()
        try:
            result.success = self._handler([ctx, args.reqSeq, args.contactIds])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "createRoom", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "createRoom", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('createRoom', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "createRoom", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _createSession(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_createSession, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = createSession_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createSession_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "createSession", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "createSession", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('createSession', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "createSession", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _fetchAnnouncements(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_fetchAnnouncements, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = fetchAnnouncements_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fetchAnnouncements_result()
        try:
            result.success = self._handler([ctx, args.lastFetchedIndex])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "fetchAnnouncements", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "fetchAnnouncements", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('fetchAnnouncements', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "fetchAnnouncements", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _fetchMessages(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_fetchMessages, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = fetchMessages_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fetchMessages_result()
        try:
            result.success = self._handler([ctx, args.localTs, args.count])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "fetchMessages", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "fetchMessages", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('fetchMessages', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "fetchMessages", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _fetchOperations(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_fetchOperations, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = fetchOperations_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fetchOperations_result()
        try:
            result.success = self._handler([ctx, args.localRev, args.count])
        except ShouldSyncException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "fetchOperations", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "fetchOperations", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('fetchOperations', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "fetchOperations", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _fetchOps(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_fetchOps, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = fetchOps_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fetchOps_result()
        try:
            result.success = self._handler([ctx, args.localRev, args.count, args.globalRev, args.individualRev])
        except ShouldSyncException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "fetchOps", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "fetchOps", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('fetchOps', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "fetchOps", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _findAndAddContactsByEmail(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_findAndAddContactsByEmail, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = findAndAddContactsByEmail_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findAndAddContactsByEmail_result()
        try:
            result.success = self._handler([ctx, args.reqSeq, args.emails])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "findAndAddContactsByEmail", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "findAndAddContactsByEmail", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('findAndAddContactsByEmail', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "findAndAddContactsByEmail", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _findAndAddContactsByMid(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_findAndAddContactsByMid, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = findAndAddContactsByMid_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findAndAddContactsByMid_result()
        try:
            result.success = self._handler([ctx, args.reqSeq, args.mid, args.type, args.reference])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "findAndAddContactsByMid", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "findAndAddContactsByMid", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('findAndAddContactsByMid', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "findAndAddContactsByMid", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _findGroupByTicketV2(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_findGroupByTicketV2, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = findGroupByTicketV2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findGroupByTicketV2_result()
        try:
            result.success = self._handler([ctx, args.ticketId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "findGroupByTicketV2", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "findGroupByTicketV2", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('findGroupByTicketV2', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "findGroupByTicketV2", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _findAndAddContactsByPhone(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_findAndAddContactsByPhone, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = findAndAddContactsByPhone_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findAndAddContactsByPhone_result()
        try:
            result.success = self._handler([ctx, args.reqSeq, args.phones])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "findAndAddContactsByPhone", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "findAndAddContactsByPhone", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('findAndAddContactsByPhone', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "findAndAddContactsByPhone", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getFriendRequests(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getFriendRequests, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getFriendRequests_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getFriendRequests_result()
        try:
            result.success = self._handler([ctx, args.direction, args.lastSeenSeqId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getFriendRequests", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getFriendRequests", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getFriendRequests', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getFriendRequests", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _removeFriendRequest(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_removeFriendRequest, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = removeFriendRequest_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeFriendRequest_result()
        try:
            self._handler([ctx, args.direction, args.midOrEMid])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "removeFriendRequest", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "removeFriendRequest", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('removeFriendRequest', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "removeFriendRequest", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _findAndAddContactsByUserid(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_findAndAddContactsByUserid, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = findAndAddContactsByUserid_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findAndAddContactsByUserid_result()
        try:
            result.success = self._handler([ctx, args.reqSeq, args.userid])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "findAndAddContactsByUserid", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "findAndAddContactsByUserid", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('findAndAddContactsByUserid', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "findAndAddContactsByUserid", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _findContactByUserid(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_findContactByUserid, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = findContactByUserid_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findContactByUserid_result()
        try:
            result.success = self._handler([ctx, args.userid])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "findContactByUserid", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "findContactByUserid", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('findContactByUserid', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "findContactByUserid", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _findContactByUserTicket(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_findContactByUserTicket, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = findContactByUserTicket_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findContactByUserTicket_result()
        try:
            result.success = self._handler([ctx, args.ticketIdWithTag])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "findContactByUserTicket", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "findContactByUserTicket", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('findContactByUserTicket', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "findContactByUserTicket", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _findContactsByEmail(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_findContactsByEmail, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = findContactsByEmail_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findContactsByEmail_result()
        try:
            result.success = self._handler([ctx, args.emails])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "findContactsByEmail", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "findContactsByEmail", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('findContactsByEmail', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "findContactsByEmail", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _findContactsByPhone(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_findContactsByPhone, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = findContactsByPhone_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findContactsByPhone_result()
        try:
            result.success = self._handler([ctx, args.phones])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "findContactsByPhone", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "findContactsByPhone", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('findContactsByPhone', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "findContactsByPhone", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _findSnsIdUserStatus(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_findSnsIdUserStatus, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = findSnsIdUserStatus_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findSnsIdUserStatus_result()
        try:
            result.success = self._handler([ctx, args.snsIdType, args.snsAccessToken, args.udidHash])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "findSnsIdUserStatus", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "findSnsIdUserStatus", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('findSnsIdUserStatus', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "findSnsIdUserStatus", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _finishUpdateVerification(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_finishUpdateVerification, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = finishUpdateVerification_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = finishUpdateVerification_result()
        try:
            self._handler([ctx, args.sessionId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "finishUpdateVerification", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "finishUpdateVerification", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('finishUpdateVerification', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "finishUpdateVerification", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _generateUserTicket(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_generateUserTicket, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = generateUserTicket_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = generateUserTicket_result()
        try:
            result.success = self._handler([ctx, args.expirationTime, args.maxUseCount])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "generateUserTicket", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "generateUserTicket", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('generateUserTicket', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "generateUserTicket", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _destroyMessage(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_destroyMessage, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = destroyMessage_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = destroyMessage_result()
        try:
            self._handler([ctx, args.seq, args.chatId, args.messageId, args.sessionId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "destroyMessage", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "destroyMessage", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('destroyMessage', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "destroyMessage", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getAcceptedProximityMatches(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getAcceptedProximityMatches, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getAcceptedProximityMatches_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAcceptedProximityMatches_result()
        try:
            result.success = self._handler([ctx, args.sessionId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getAcceptedProximityMatches", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getAcceptedProximityMatches", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getAcceptedProximityMatches', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getAcceptedProximityMatches", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getActiveBuddySubscriberIds(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getActiveBuddySubscriberIds, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getActiveBuddySubscriberIds_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getActiveBuddySubscriberIds_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getActiveBuddySubscriberIds", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getActiveBuddySubscriberIds", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getActiveBuddySubscriberIds', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getActiveBuddySubscriberIds", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getAllContactIds(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getAllContactIds, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getAllContactIds_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAllContactIds_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getAllContactIds", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getAllContactIds", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getAllContactIds', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getAllContactIds", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getAuthQrcode(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getAuthQrcode, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getAuthQrcode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAuthQrcode_result()
        try:
            result.success = self._handler([ctx, args.keepLoggedIn, args.systemName])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getAuthQrcode", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getAuthQrcode", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getAuthQrcode', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getAuthQrcode", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getBlockedContactIds(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getBlockedContactIds, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getBlockedContactIds_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getBlockedContactIds_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getBlockedContactIds", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getBlockedContactIds", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getBlockedContactIds', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getBlockedContactIds", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _registerWithPhoneNumber(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_registerWithPhoneNumber, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = registerWithPhoneNumber_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = registerWithPhoneNumber_result()
        try:
            result.success = self._handler([ctx, args.sessionId, args.migrationPincodeSessionId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerWithPhoneNumber", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerWithPhoneNumber", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('registerWithPhoneNumber', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "registerWithPhoneNumber", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _registerWithPhoneNumberAndPassword(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_registerWithPhoneNumberAndPassword, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = registerWithPhoneNumberAndPassword_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = registerWithPhoneNumberAndPassword_result()
        try:
            result.success = self._handler([ctx, args.sessionId, args.keynm, args.encrypted])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerWithPhoneNumberAndPassword", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerWithPhoneNumberAndPassword", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('registerWithPhoneNumberAndPassword', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "registerWithPhoneNumberAndPassword", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getAnalyticsInfo(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getAnalyticsInfo, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getAnalyticsInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAnalyticsInfo_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getAnalyticsInfo", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getAnalyticsInfo", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getAnalyticsInfo', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getAnalyticsInfo", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _reportClientStatistics(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_reportClientStatistics, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = reportClientStatistics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = reportClientStatistics_result()
        try:
            self._handler([ctx, args.reqSeq, args.category, args.count])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "reportClientStatistics", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "reportClientStatistics", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('reportClientStatistics', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "reportClientStatistics", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _verifyPhoneNumberForLogin(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_verifyPhoneNumberForLogin, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = verifyPhoneNumberForLogin_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = verifyPhoneNumberForLogin_result()
        try:
            result.success = self._handler([ctx, args.verifierFromPhone, args.pinCodeForPhone, args.verifierFromLogin])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "verifyPhoneNumberForLogin", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "verifyPhoneNumberForLogin", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('verifyPhoneNumberForLogin', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "verifyPhoneNumberForLogin", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _verifyPhoneNumber(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_verifyPhoneNumber, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = verifyPhoneNumber_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = verifyPhoneNumber_result()
        try:
            result.success = self._handler([ctx, args.sessionId, args.pinCode, args.udidHash, args.migrationPincodeSessionId, args.oldUdidHash])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "verifyPhoneNumber", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "verifyPhoneNumber", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('verifyPhoneNumber', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "verifyPhoneNumber", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getBlockedContactIdsByRange(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getBlockedContactIdsByRange, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getBlockedContactIdsByRange_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getBlockedContactIdsByRange_result()
        try:
            result.success = self._handler([ctx, args.start, args.count])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getBlockedContactIdsByRange", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getBlockedContactIdsByRange", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getBlockedContactIdsByRange', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getBlockedContactIdsByRange", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getBlockedRecommendationIds(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getBlockedRecommendationIds, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getBlockedRecommendationIds_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getBlockedRecommendationIds_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getBlockedRecommendationIds", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getBlockedRecommendationIds", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getBlockedRecommendationIds', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getBlockedRecommendationIds", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getBuddyBlockerIds(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getBuddyBlockerIds, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getBuddyBlockerIds_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getBuddyBlockerIds_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getBuddyBlockerIds", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getBuddyBlockerIds", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getBuddyBlockerIds', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getBuddyBlockerIds", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getBuddyLocation(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getBuddyLocation, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getBuddyLocation_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getBuddyLocation_result()
        try:
            result.success = self._handler([ctx, args.mid, args.index])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getBuddyLocation", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getBuddyLocation", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getBuddyLocation', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getBuddyLocation", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getCompactContactsModifiedSince(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getCompactContactsModifiedSince, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getCompactContactsModifiedSince_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCompactContactsModifiedSince_result()
        try:
            result.success = self._handler([ctx, args.timestamp])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getCompactContactsModifiedSince", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getCompactContactsModifiedSince", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getCompactContactsModifiedSince', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getCompactContactsModifiedSince", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getCompactGroup(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getCompactGroup, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getCompactGroup_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCompactGroup_result()
        try:
            result.success = self._handler([ctx, args.groupId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getCompactGroup", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getCompactGroup", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getCompactGroup', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getCompactGroup", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getCompactRoom(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getCompactRoom, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getCompactRoom_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCompactRoom_result()
        try:
            result.success = self._handler([ctx, args.roomId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getCompactRoom", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getCompactRoom", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getCompactRoom', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getCompactRoom", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getContact(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getContact, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getContact_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getContact_result()
        try:
            result.success = self._handler([ctx, args.id])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getContact", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getContact", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getContact', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getContact", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getContacts(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getContacts, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getContacts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getContacts_result()
        try:
            result.success = self._handler([ctx, args.ids])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getContacts", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getContacts", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getContacts', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getContacts", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getContactWithFriendRequestStatus(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getContactWithFriendRequestStatus, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getContactWithFriendRequestStatus_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getContactWithFriendRequestStatus_result()
        try:
            result.success = self._handler([ctx, args.id])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getContactWithFriendRequestStatus", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getContactWithFriendRequestStatus", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getContactWithFriendRequestStatus', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getContactWithFriendRequestStatus", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getCountryWithRequestIp(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getCountryWithRequestIp, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getCountryWithRequestIp_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCountryWithRequestIp_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getCountryWithRequestIp", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getCountryWithRequestIp", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getCountryWithRequestIp', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getCountryWithRequestIp", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getFavoriteMids(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getFavoriteMids, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getFavoriteMids_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getFavoriteMids_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getFavoriteMids", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getFavoriteMids", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getFavoriteMids', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getFavoriteMids", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getGroup(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getGroup, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getGroup_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getGroup_result()
        try:
            result.success = self._handler([ctx, args.groupId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getGroup", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getGroup", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getGroup', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getGroup", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getGroupIdsInvited(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getGroupIdsInvited, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getGroupIdsInvited_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getGroupIdsInvited_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getGroupIdsInvited", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getGroupIdsInvited", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getGroupIdsInvited', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getGroupIdsInvited", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getGroupIdsJoined(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getGroupIdsJoined, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getGroupIdsJoined_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getGroupIdsJoined_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getGroupIdsJoined", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getGroupIdsJoined", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getGroupIdsJoined', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getGroupIdsJoined", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getGroups(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getGroups, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getGroups_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getGroups_result()
        try:
            result.success = self._handler([ctx, args.groupIds])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getGroups", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getGroups", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getGroups', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getGroups", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getHiddenContactMids(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getHiddenContactMids, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getHiddenContactMids_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getHiddenContactMids_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getHiddenContactMids", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getHiddenContactMids", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getHiddenContactMids', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getHiddenContactMids", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getIdentityIdentifier(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getIdentityIdentifier, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getIdentityIdentifier_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getIdentityIdentifier_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getIdentityIdentifier", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getIdentityIdentifier", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getIdentityIdentifier', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getIdentityIdentifier", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getLastAnnouncementIndex(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getLastAnnouncementIndex, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getLastAnnouncementIndex_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getLastAnnouncementIndex_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getLastAnnouncementIndex", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getLastAnnouncementIndex", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getLastAnnouncementIndex', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getLastAnnouncementIndex", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getLastOpRevision(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getLastOpRevision, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getLastOpRevision_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getLastOpRevision_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getLastOpRevision", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getLastOpRevision", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getLastOpRevision', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getLastOpRevision", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getSuggestRevisions(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getSuggestRevisions, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getSuggestRevisions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getSuggestRevisions_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getSuggestRevisions", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getSuggestRevisions", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getSuggestRevisions', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getSuggestRevisions", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getPreviousMessagesV2WithReadCount(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getPreviousMessagesV2WithReadCount, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getPreviousMessagesV2WithReadCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getPreviousMessagesV2WithReadCount_result()
        try:
            result.success = self._handler([ctx, args.messageBoxId, args.endMessageId, args.messagesCount])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getPreviousMessagesV2WithReadCount", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getPreviousMessagesV2WithReadCount", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getPreviousMessagesV2WithReadCount', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getPreviousMessagesV2WithReadCount", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getMessageBox(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getMessageBox, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getMessageBox_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMessageBox_result()
        try:
            result.success = self._handler([ctx, args.channelId, args.messageBoxId, args.lastMessagesCount])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getMessageBox", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getMessageBox", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getMessageBox', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getMessageBox", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getMessageBoxCompactWrapUp(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getMessageBoxCompactWrapUp, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getMessageBoxCompactWrapUp_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMessageBoxCompactWrapUp_result()
        try:
            result.success = self._handler([ctx, args.mid])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getMessageBoxCompactWrapUp", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getMessageBoxCompactWrapUp", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getMessageBoxCompactWrapUp', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getMessageBoxCompactWrapUp", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getMessageBoxCompactWrapUpList(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getMessageBoxCompactWrapUpList, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getMessageBoxCompactWrapUpList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMessageBoxCompactWrapUpList_result()
        try:
            result.success = self._handler([ctx, args.start, args.messageBoxCount])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getMessageBoxCompactWrapUpList", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getMessageBoxCompactWrapUpList", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getMessageBoxCompactWrapUpList', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getMessageBoxCompactWrapUpList", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getMessageBoxList(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getMessageBoxList, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getMessageBoxList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMessageBoxList_result()
        try:
            result.success = self._handler([ctx, args.channelId, args.lastMessagesCount])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getMessageBoxList", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getMessageBoxList", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getMessageBoxList', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getMessageBoxList", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getMessageBoxListByStatus(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getMessageBoxListByStatus, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getMessageBoxListByStatus_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMessageBoxListByStatus_result()
        try:
            result.success = self._handler([ctx, args.channelId, args.lastMessagesCount, args.status])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getMessageBoxListByStatus", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getMessageBoxListByStatus", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getMessageBoxListByStatus', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getMessageBoxListByStatus", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getMessageBoxWrapUp(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getMessageBoxWrapUp, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getMessageBoxWrapUp_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMessageBoxWrapUp_result()
        try:
            result.success = self._handler([ctx, args.mid])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getMessageBoxWrapUp", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getMessageBoxWrapUp", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getMessageBoxWrapUp', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getMessageBoxWrapUp", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getMessageBoxWrapUpList(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getMessageBoxWrapUpList, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getMessageBoxWrapUpList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMessageBoxWrapUpList_result()
        try:
            result.success = self._handler([ctx, args.start, args.messageBoxCount])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getMessageBoxWrapUpList", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getMessageBoxWrapUpList", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getMessageBoxWrapUpList', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getMessageBoxWrapUpList", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getMessagesBySequenceNumber(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getMessagesBySequenceNumber, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getMessagesBySequenceNumber_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMessagesBySequenceNumber_result()
        try:
            result.success = self._handler([ctx, args.channelId, args.messageBoxId, args.startSeq, args.endSeq])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getMessagesBySequenceNumber", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getMessagesBySequenceNumber", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getMessagesBySequenceNumber', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getMessagesBySequenceNumber", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getNextMessages(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getNextMessages, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getNextMessages_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getNextMessages_result()
        try:
            result.success = self._handler([ctx, args.messageBoxId, args.startSeq, args.messagesCount])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getNextMessages", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getNextMessages", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getNextMessages', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getNextMessages", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getNotificationPolicy(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getNotificationPolicy, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getNotificationPolicy_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getNotificationPolicy_result()
        try:
            result.success = self._handler([ctx, args.carrier])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getNotificationPolicy", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getNotificationPolicy", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getNotificationPolicy', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getNotificationPolicy", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getPreviousMessages(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getPreviousMessages, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getPreviousMessages_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getPreviousMessages_result()
        try:
            result.success = self._handler([ctx, args.messageBoxId, args.endSeq, args.messagesCount])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getPreviousMessages", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getPreviousMessages", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getPreviousMessages', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getPreviousMessages", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getProfile(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getProfile, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getProfile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getProfile_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getProfile", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getProfile", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getProfile', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getProfile", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getProximityMatchCandidateList(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getProximityMatchCandidateList, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getProximityMatchCandidateList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getProximityMatchCandidateList_result()
        try:
            result.success = self._handler([ctx, args.sessionId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getProximityMatchCandidateList", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getProximityMatchCandidateList", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getProximityMatchCandidateList', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getProximityMatchCandidateList", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getProximityMatchCandidates(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getProximityMatchCandidates, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getProximityMatchCandidates_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getProximityMatchCandidates_result()
        try:
            result.success = self._handler([ctx, args.sessionId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getProximityMatchCandidates", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getProximityMatchCandidates", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getProximityMatchCandidates', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getProximityMatchCandidates", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getRecentMessages(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getRecentMessages, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getRecentMessages_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRecentMessages_result()
        try:
            result.success = self._handler([ctx, args.messageBoxId, args.messagesCount])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getRecentMessages", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getRecentMessages", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getRecentMessages', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getRecentMessages", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getRecommendationIds(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getRecommendationIds, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getRecommendationIds_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRecommendationIds_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getRecommendationIds", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getRecommendationIds", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getRecommendationIds', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getRecommendationIds", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getRoom(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getRoom, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getRoom_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRoom_result()
        try:
            result.success = self._handler([ctx, args.roomId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getRoom", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getRoom", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getRoom', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getRoom", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getRSAKeyInfo(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getRSAKeyInfo, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getRSAKeyInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRSAKeyInfo_result()
        try:
            result.success = self._handler([ctx, args.provider])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getRSAKeyInfo", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getRSAKeyInfo", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getRSAKeyInfo', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getRSAKeyInfo", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getServerTime(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getServerTime, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getServerTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getServerTime_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getServerTime", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getServerTime", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getServerTime', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getServerTime", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getSessions(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getSessions, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getSessions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getSessions_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getSessions", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getSessions", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getSessions', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getSessions", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getSettings(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getSettings, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getSettings_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getSettings_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getSettings", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getSettings", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getSettings', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getSettings", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getGroupsV2(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getGroupsV2, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getGroupsV2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getGroupsV2_result()
        try:
            result.success = self._handler([ctx, args.groupIds])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getGroupsV2", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getGroupsV2", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getGroupsV2', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getGroupsV2", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getSettingsAttributes(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getSettingsAttributes, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getSettingsAttributes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getSettingsAttributes_result()
        try:
            result.success = self._handler([ctx, args.attrBitset])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getSettingsAttributes", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getSettingsAttributes", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getSettingsAttributes', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getSettingsAttributes", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getSystemConfiguration(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getSystemConfiguration, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getSystemConfiguration_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getSystemConfiguration_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getSystemConfiguration", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getSystemConfiguration", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getSystemConfiguration', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getSystemConfiguration", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getUserTicket(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getUserTicket, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getUserTicket_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getUserTicket_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getUserTicket", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getUserTicket", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getUserTicket', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getUserTicket", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getWapInvitation(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getWapInvitation, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getWapInvitation_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getWapInvitation_result()
        try:
            result.success = self._handler([ctx, args.invitationHash])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getWapInvitation", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getWapInvitation", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getWapInvitation', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getWapInvitation", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _invalidateUserTicket(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_invalidateUserTicket, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = invalidateUserTicket_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = invalidateUserTicket_result()
        try:
            self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "invalidateUserTicket", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "invalidateUserTicket", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('invalidateUserTicket', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "invalidateUserTicket", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _inviteFriendsBySms(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_inviteFriendsBySms, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = inviteFriendsBySms_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = inviteFriendsBySms_result()
        try:
            self._handler([ctx, args.phoneNumberList])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "inviteFriendsBySms", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "inviteFriendsBySms", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('inviteFriendsBySms', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "inviteFriendsBySms", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _inviteIntoGroup(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_inviteIntoGroup, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = inviteIntoGroup_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = inviteIntoGroup_result()
        try:
            self._handler([ctx, args.reqSeq, args.groupId, args.contactIds])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "inviteIntoGroup", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "inviteIntoGroup", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('inviteIntoGroup', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "inviteIntoGroup", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _inviteIntoRoom(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_inviteIntoRoom, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = inviteIntoRoom_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = inviteIntoRoom_result()
        try:
            self._handler([ctx, args.reqSeq, args.roomId, args.contactIds])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "inviteIntoRoom", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "inviteIntoRoom", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('inviteIntoRoom', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "inviteIntoRoom", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _inviteViaEmail(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_inviteViaEmail, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = inviteViaEmail_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = inviteViaEmail_result()
        try:
            self._handler([ctx, args.reqSeq, args.email, args.name])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "inviteViaEmail", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "inviteViaEmail", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('inviteViaEmail', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "inviteViaEmail", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _isIdentityIdentifierAvailable(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_isIdentityIdentifierAvailable, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = isIdentityIdentifierAvailable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = isIdentityIdentifierAvailable_result()
        try:
            result.success = self._handler([ctx, args.provider, args.identifier])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "isIdentityIdentifierAvailable", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "isIdentityIdentifierAvailable", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('isIdentityIdentifierAvailable', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "isIdentityIdentifierAvailable", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _isUseridAvailable(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_isUseridAvailable, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = isUseridAvailable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = isUseridAvailable_result()
        try:
            result.success = self._handler([ctx, args.userid])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "isUseridAvailable", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "isUseridAvailable", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('isUseridAvailable', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "isUseridAvailable", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _kickoutFromGroup(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_kickoutFromGroup, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = kickoutFromGroup_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = kickoutFromGroup_result()
        try:
            self._handler([ctx, args.reqSeq, args.groupId, args.contactIds])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "kickoutFromGroup", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "kickoutFromGroup", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('kickoutFromGroup', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "kickoutFromGroup", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _reissueGroupTicket(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_reissueGroupTicket, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = reissueGroupTicket_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = reissueGroupTicket_result()
        try:
            result.success = self._handler([ctx, args.groupMid])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "reissueGroupTicket", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "reissueGroupTicket", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('reissueGroupTicket', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "reissueGroupTicket", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _findGroupByTicket(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_findGroupByTicket, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = findGroupByTicket_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findGroupByTicket_result()
        try:
            result.success = self._handler([ctx, args.ticketId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "findGroupByTicket", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "findGroupByTicket", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('findGroupByTicket', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "findGroupByTicket", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _leaveGroup(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_leaveGroup, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = leaveGroup_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = leaveGroup_result()
        try:
            self._handler([ctx, args.reqSeq, args.groupId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "leaveGroup", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "leaveGroup", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('leaveGroup', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "leaveGroup", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _leaveRoom(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_leaveRoom, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = leaveRoom_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = leaveRoom_result()
        try:
            self._handler([ctx, args.reqSeq, args.roomId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "leaveRoom", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "leaveRoom", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('leaveRoom', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "leaveRoom", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _loginWithIdentityCredential(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_loginWithIdentityCredential, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = loginWithIdentityCredential_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = loginWithIdentityCredential_result()
        try:
            result.success = self._handler([ctx, args.identityProvider, args.identifier, args.password, args.keepLoggedIn, args.accessLocation, args.systemName, args.certificate])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "loginWithIdentityCredential", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "loginWithIdentityCredential", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('loginWithIdentityCredential', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "loginWithIdentityCredential", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _loginWithIdentityCredentialForCertificate(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_loginWithIdentityCredentialForCertificate, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = loginWithIdentityCredentialForCertificate_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = loginWithIdentityCredentialForCertificate_result()
        try:
            result.success = self._handler([ctx, args.identityProvider, args.identifier, args.password, args.keepLoggedIn, args.accessLocation, args.systemName, args.certificate])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "loginWithIdentityCredentialForCertificate", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "loginWithIdentityCredentialForCertificate", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('loginWithIdentityCredentialForCertificate', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "loginWithIdentityCredentialForCertificate", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _loginWithVerifier(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_loginWithVerifier, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = loginWithVerifier_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = loginWithVerifier_result()
        try:
            result.success = self._handler([ctx, args.verifier])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "loginWithVerifier", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "loginWithVerifier", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('loginWithVerifier', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "loginWithVerifier", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _loginWithVerifierForCerificate(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_loginWithVerifierForCerificate, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = loginWithVerifierForCerificate_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = loginWithVerifierForCerificate_result()
        try:
            result.success = self._handler([ctx, args.verifier])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "loginWithVerifierForCerificate", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "loginWithVerifierForCerificate", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('loginWithVerifierForCerificate', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "loginWithVerifierForCerificate", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _loginWithVerifierForCertificate(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_loginWithVerifierForCertificate, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = loginWithVerifierForCertificate_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = loginWithVerifierForCertificate_result()
        try:
            result.success = self._handler([ctx, args.verifier])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "loginWithVerifierForCertificate", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "loginWithVerifierForCertificate", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('loginWithVerifierForCertificate', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "loginWithVerifierForCertificate", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _logout(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_logout, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = logout_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = logout_result()
        try:
            self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "logout", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "logout", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('logout', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "logout", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _logoutSession(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_logoutSession, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = logoutSession_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = logoutSession_result()
        try:
            self._handler([ctx, args.tokenKey])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "logoutSession", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "logoutSession", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('logoutSession', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "logoutSession", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _noop(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_noop, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = noop_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = noop_result()
        try:
            self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "noop", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "noop", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('noop', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "noop", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _notifiedRedirect(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_notifiedRedirect, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = notifiedRedirect_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = notifiedRedirect_result()
        try:
            self._handler([ctx, args.paramMap])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "notifiedRedirect", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "notifiedRedirect", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('notifiedRedirect', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "notifiedRedirect", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _notifyBuddyOnAir(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_notifyBuddyOnAir, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = notifyBuddyOnAir_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = notifyBuddyOnAir_result()
        try:
            result.success = self._handler([ctx, args.seq, args.receiverMids])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "notifyBuddyOnAir", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "notifyBuddyOnAir", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('notifyBuddyOnAir', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "notifyBuddyOnAir", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _notifyIndividualEvent(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_notifyIndividualEvent, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = notifyIndividualEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = notifyIndividualEvent_result()
        try:
            self._handler([ctx, args.notificationStatus, args.receiverMids])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "notifyIndividualEvent", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "notifyIndividualEvent", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('notifyIndividualEvent', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "notifyIndividualEvent", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _notifyInstalled(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_notifyInstalled, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = notifyInstalled_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = notifyInstalled_result()
        try:
            self._handler([ctx, args.udidHash, args.applicationTypeWithExtensions])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "notifyInstalled", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "notifyInstalled", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('notifyInstalled', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "notifyInstalled", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _notifyRegistrationComplete(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_notifyRegistrationComplete, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = notifyRegistrationComplete_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = notifyRegistrationComplete_result()
        try:
            self._handler([ctx, args.udidHash, args.applicationTypeWithExtensions])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "notifyRegistrationComplete", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "notifyRegistrationComplete", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('notifyRegistrationComplete', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "notifyRegistrationComplete", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _notifySleep(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_notifySleep, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = notifySleep_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = notifySleep_result()
        try:
            self._handler([ctx, args.lastRev, args.badge])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "notifySleep", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "notifySleep", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('notifySleep', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "notifySleep", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _notifyUpdated(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_notifyUpdated, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = notifyUpdated_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = notifyUpdated_result()
        try:
            self._handler([ctx, args.lastRev, args.deviceInfo])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "notifyUpdated", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "notifyUpdated", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('notifyUpdated', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "notifyUpdated", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _openProximityMatch(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_openProximityMatch, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = openProximityMatch_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = openProximityMatch_result()
        try:
            result.success = self._handler([ctx, args.location])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "openProximityMatch", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "openProximityMatch", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('openProximityMatch', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "openProximityMatch", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _registerBuddyUser(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_registerBuddyUser, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = registerBuddyUser_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = registerBuddyUser_result()
        try:
            result.success = self._handler([ctx, args.buddyId, args.registrarPassword])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerBuddyUser", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerBuddyUser", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('registerBuddyUser', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "registerBuddyUser", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _registerBuddyUserid(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_registerBuddyUserid, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = registerBuddyUserid_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = registerBuddyUserid_result()
        try:
            self._handler([ctx, args.seq, args.userid])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerBuddyUserid", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerBuddyUserid", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('registerBuddyUserid', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "registerBuddyUserid", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _registerDevice(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_registerDevice, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = registerDevice_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = registerDevice_result()
        try:
            result.success = self._handler([ctx, args.sessionId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerDevice", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerDevice", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('registerDevice', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "registerDevice", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _registerDeviceWithIdentityCredential(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_registerDeviceWithIdentityCredential, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = registerDeviceWithIdentityCredential_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = registerDeviceWithIdentityCredential_result()
        try:
            result.success = self._handler([ctx, args.sessionId, args.provider, args.identifier, args.verifier])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerDeviceWithIdentityCredential", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerDeviceWithIdentityCredential", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('registerDeviceWithIdentityCredential', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "registerDeviceWithIdentityCredential", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _registerDeviceWithoutPhoneNumber(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_registerDeviceWithoutPhoneNumber, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = registerDeviceWithoutPhoneNumber_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = registerDeviceWithoutPhoneNumber_result()
        try:
            result.success = self._handler([ctx, args.region, args.udidHash, args.deviceInfo])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerDeviceWithoutPhoneNumber", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerDeviceWithoutPhoneNumber", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('registerDeviceWithoutPhoneNumber', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "registerDeviceWithoutPhoneNumber", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _registerDeviceWithoutPhoneNumberWithIdentityCredential(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_registerDeviceWithoutPhoneNumberWithIdentityCredential, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = registerDeviceWithoutPhoneNumberWithIdentityCredential_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = registerDeviceWithoutPhoneNumberWithIdentityCredential_result()
        try:
            result.success = self._handler([ctx, args.region, args.udidHash, args.deviceInfo, args.provider, args.identifier, args.verifier, args.mid, args.migrationPincodeSessionId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerDeviceWithoutPhoneNumberWithIdentityCredential", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerDeviceWithoutPhoneNumberWithIdentityCredential", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('registerDeviceWithoutPhoneNumberWithIdentityCredential', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "registerDeviceWithoutPhoneNumberWithIdentityCredential", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _registerUserid(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_registerUserid, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = registerUserid_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = registerUserid_result()
        try:
            result.success = self._handler([ctx, args.reqSeq, args.userid])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerUserid", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerUserid", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('registerUserid', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "registerUserid", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _registerWapDevice(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_registerWapDevice, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = registerWapDevice_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = registerWapDevice_result()
        try:
            result.success = self._handler([ctx, args.invitationHash, args.guidHash, args.email, args.deviceInfo])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerWapDevice", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerWapDevice", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('registerWapDevice', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "registerWapDevice", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _registerWithExistingSnsIdAndIdentityCredential(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_registerWithExistingSnsIdAndIdentityCredential, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = registerWithExistingSnsIdAndIdentityCredential_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = registerWithExistingSnsIdAndIdentityCredential_result()
        try:
            result.success = self._handler([ctx, args.identityCredential, args.region, args.udidHash, args.deviceInfo])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerWithExistingSnsIdAndIdentityCredential", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerWithExistingSnsIdAndIdentityCredential", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('registerWithExistingSnsIdAndIdentityCredential', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "registerWithExistingSnsIdAndIdentityCredential", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _registerWithSnsId(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_registerWithSnsId, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = registerWithSnsId_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = registerWithSnsId_result()
        try:
            result.success = self._handler([ctx, args.snsIdType, args.snsAccessToken, args.region, args.udidHash, args.deviceInfo, args.mid])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerWithSnsId", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerWithSnsId", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('registerWithSnsId', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "registerWithSnsId", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _registerWithSnsIdAndIdentityCredential(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_registerWithSnsIdAndIdentityCredential, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = registerWithSnsIdAndIdentityCredential_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = registerWithSnsIdAndIdentityCredential_result()
        try:
            result.success = self._handler([ctx, args.snsIdType, args.snsAccessToken, args.identityCredential, args.region, args.udidHash, args.deviceInfo])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerWithSnsIdAndIdentityCredential", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerWithSnsIdAndIdentityCredential", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('registerWithSnsIdAndIdentityCredential', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "registerWithSnsIdAndIdentityCredential", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _reissueDeviceCredential(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_reissueDeviceCredential, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = reissueDeviceCredential_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = reissueDeviceCredential_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "reissueDeviceCredential", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "reissueDeviceCredential", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('reissueDeviceCredential', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "reissueDeviceCredential", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _reissueUserTicket(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_reissueUserTicket, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = reissueUserTicket_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = reissueUserTicket_result()
        try:
            result.success = self._handler([ctx, args.expirationTime, args.maxUseCount])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "reissueUserTicket", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "reissueUserTicket", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('reissueUserTicket', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "reissueUserTicket", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getMessageReadRange(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getMessageReadRange, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getMessageReadRange_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMessageReadRange_result()
        try:
            result.success = self._handler([ctx, args.chatIds])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getMessageReadRange", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getMessageReadRange", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getMessageReadRange', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getMessageReadRange", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _rejectGroupInvitation(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_rejectGroupInvitation, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = rejectGroupInvitation_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = rejectGroupInvitation_result()
        try:
            self._handler([ctx, args.reqSeq, args.groupId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "rejectGroupInvitation", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "rejectGroupInvitation", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('rejectGroupInvitation', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "rejectGroupInvitation", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _releaseSession(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_releaseSession, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = releaseSession_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = releaseSession_result()
        try:
            self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "releaseSession", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "releaseSession", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('releaseSession', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "releaseSession", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _removeAllMessages(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_removeAllMessages, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = removeAllMessages_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeAllMessages_result()
        try:
            self._handler([ctx, args.seq, args.lastMessageId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "removeAllMessages", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "removeAllMessages", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('removeAllMessages', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "removeAllMessages", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _removeBuddyLocation(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_removeBuddyLocation, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = removeBuddyLocation_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeBuddyLocation_result()
        try:
            self._handler([ctx, args.mid, args.index])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "removeBuddyLocation", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "removeBuddyLocation", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('removeBuddyLocation', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "removeBuddyLocation", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _removeMessage(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_removeMessage, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = removeMessage_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeMessage_result()
        try:
            result.success = self._handler([ctx, args.messageId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "removeMessage", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "removeMessage", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('removeMessage', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "removeMessage", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _makeUserAddMyselfAsContact(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_makeUserAddMyselfAsContact, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = makeUserAddMyselfAsContact_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = makeUserAddMyselfAsContact_result()
        try:
            result.success = self._handler([ctx, args.contactOwnerMid])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "makeUserAddMyselfAsContact", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "makeUserAddMyselfAsContact", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('makeUserAddMyselfAsContact', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "makeUserAddMyselfAsContact", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _removeMessageFromMyHome(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_removeMessageFromMyHome, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = removeMessageFromMyHome_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeMessageFromMyHome_result()
        try:
            result.success = self._handler([ctx, args.messageId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "removeMessageFromMyHome", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "removeMessageFromMyHome", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('removeMessageFromMyHome', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "removeMessageFromMyHome", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _removeSnsId(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_removeSnsId, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = removeSnsId_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeSnsId_result()
        try:
            result.success = self._handler([ctx, args.snsIdType])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "removeSnsId", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "removeSnsId", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('removeSnsId', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "removeSnsId", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _report(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_report, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = report_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = report_result()
        try:
            self._handler([ctx, args.syncOpRevision, args.category, args.report])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "report", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "report", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('report', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "report", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _reportContacts(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_reportContacts, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = reportContacts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = reportContacts_result()
        try:
            result.success = self._handler([ctx, args.syncOpRevision, args.category, args.contactReports, args.actionType])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "reportContacts", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "reportContacts", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('reportContacts', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "reportContacts", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _reportGroups(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_reportGroups, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = reportGroups_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = reportGroups_result()
        try:
            self._handler([ctx, args.syncOpRevision, args.groups])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "reportGroups", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "reportGroups", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('reportGroups', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "reportGroups", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _reportProfile(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_reportProfile, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = reportProfile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = reportProfile_result()
        try:
            self._handler([ctx, args.syncOpRevision, args.profile])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "reportProfile", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "reportProfile", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('reportProfile', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "reportProfile", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _reportRooms(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_reportRooms, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = reportRooms_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = reportRooms_result()
        try:
            self._handler([ctx, args.syncOpRevision, args.rooms])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "reportRooms", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "reportRooms", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('reportRooms', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "reportRooms", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _findAndAddContactByMetaTag(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_findAndAddContactByMetaTag, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = findAndAddContactByMetaTag_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findAndAddContactByMetaTag_result()
        try:
            result.success = self._handler([ctx, args.reqSeq, args.userid, args.reference])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "findAndAddContactByMetaTag", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "findAndAddContactByMetaTag", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('findAndAddContactByMetaTag', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "findAndAddContactByMetaTag", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _reportSettings(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_reportSettings, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = reportSettings_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = reportSettings_result()
        try:
            self._handler([ctx, args.syncOpRevision, args.settings])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "reportSettings", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "reportSettings", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('reportSettings', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "reportSettings", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _reportSpam(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_reportSpam, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = reportSpam_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = reportSpam_result()
        try:
            self._handler([ctx, args.chatMid, args.memberMids, args.spammerReasons, args.senderMids, args.spamMessageIds, args.spamMessages])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "reportSpam", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "reportSpam", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('reportSpam', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "reportSpam", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _reportSpammer(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_reportSpammer, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = reportSpammer_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = reportSpammer_result()
        try:
            self._handler([ctx, args.spammerMid, args.spammerReasons, args.spamMessageIds])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "reportSpammer", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "reportSpammer", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('reportSpammer', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "reportSpammer", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _requestAccountPasswordReset(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_requestAccountPasswordReset, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = requestAccountPasswordReset_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = requestAccountPasswordReset_result()
        try:
            self._handler([ctx, args.provider, args.identifier, args.locale])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "requestAccountPasswordReset", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "requestAccountPasswordReset", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('requestAccountPasswordReset', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "requestAccountPasswordReset", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _requestEmailConfirmation(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_requestEmailConfirmation, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = requestEmailConfirmation_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = requestEmailConfirmation_result()
        try:
            result.success = self._handler([ctx, args.emailConfirmation])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "requestEmailConfirmation", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "requestEmailConfirmation", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('requestEmailConfirmation', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "requestEmailConfirmation", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _requestIdentityUnbind(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_requestIdentityUnbind, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = requestIdentityUnbind_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = requestIdentityUnbind_result()
        try:
            self._handler([ctx, args.provider, args.identifier])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "requestIdentityUnbind", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "requestIdentityUnbind", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('requestIdentityUnbind', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "requestIdentityUnbind", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _resendEmailConfirmation(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_resendEmailConfirmation, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = resendEmailConfirmation_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = resendEmailConfirmation_result()
        try:
            result.success = self._handler([ctx, args.verifier])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "resendEmailConfirmation", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "resendEmailConfirmation", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('resendEmailConfirmation', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "resendEmailConfirmation", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _resendPinCode(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_resendPinCode, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = resendPinCode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = resendPinCode_result()
        try:
            self._handler([ctx, args.sessionId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "resendPinCode", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "resendPinCode", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('resendPinCode', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "resendPinCode", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _resendPinCodeBySMS(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_resendPinCodeBySMS, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = resendPinCodeBySMS_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = resendPinCodeBySMS_result()
        try:
            self._handler([ctx, args.sessionId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "resendPinCodeBySMS", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "resendPinCodeBySMS", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('resendPinCodeBySMS', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "resendPinCodeBySMS", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _sendChatChecked(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_sendChatChecked, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = sendChatChecked_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sendChatChecked_result()
        try:
            self._handler([ctx, args.seq, args.consumer, args.lastMessageId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "sendChatChecked", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "sendChatChecked", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('sendChatChecked', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "sendChatChecked", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _sendMessageAwaitCommit(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_sendMessageAwaitCommit, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = sendMessageAwaitCommit_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sendMessageAwaitCommit_result()
        try:
            result.success = self._handler([ctx, args.seq, args.message])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "sendMessageAwaitCommit", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "sendMessageAwaitCommit", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('sendMessageAwaitCommit', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "sendMessageAwaitCommit", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _sendChatRemoved(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_sendChatRemoved, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = sendChatRemoved_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sendChatRemoved_result()
        try:
            self._handler([ctx, args.seq, args.consumer, args.lastMessageId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "sendChatRemoved", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "sendChatRemoved", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('sendChatRemoved', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "sendChatRemoved", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _sendContentPreviewUpdated(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_sendContentPreviewUpdated, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = sendContentPreviewUpdated_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sendContentPreviewUpdated_result()
        try:
            result.success = self._handler([ctx, args.esq, args.messageId, args.receiverMids])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "sendContentPreviewUpdated", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "sendContentPreviewUpdated", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('sendContentPreviewUpdated', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "sendContentPreviewUpdated", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _sendContentReceipt(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_sendContentReceipt, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = sendContentReceipt_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sendContentReceipt_result()
        try:
            self._handler([ctx, args.seq, args.consumer, args.messageId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "sendContentReceipt", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "sendContentReceipt", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('sendContentReceipt', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "sendContentReceipt", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _sendDummyPush(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_sendDummyPush, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = sendDummyPush_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sendDummyPush_result()
        try:
            self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "sendDummyPush", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "sendDummyPush", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('sendDummyPush', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "sendDummyPush", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _removeE2EEPublicKey(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_removeE2EEPublicKey, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = removeE2EEPublicKey_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeE2EEPublicKey_result()
        try:
            self._handler([ctx, args.publicKey])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "removeE2EEPublicKey", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "removeE2EEPublicKey", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('removeE2EEPublicKey', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "removeE2EEPublicKey", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _negotiateE2EEPublicKey(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_negotiateE2EEPublicKey, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = negotiateE2EEPublicKey_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = negotiateE2EEPublicKey_result()
        try:
            result.success = self._handler([ctx, args.mid])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "negotiateE2EEPublicKey", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "negotiateE2EEPublicKey", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('negotiateE2EEPublicKey', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "negotiateE2EEPublicKey", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getE2EEPublicKey(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getE2EEPublicKey, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getE2EEPublicKey_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getE2EEPublicKey_result()
        try:
            result.success = self._handler([ctx, args.mid, args.version, args.keyId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getE2EEPublicKey", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getE2EEPublicKey", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getE2EEPublicKey', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getE2EEPublicKey", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _requestE2EEKeyExchange(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_requestE2EEKeyExchange, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = requestE2EEKeyExchange_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = requestE2EEKeyExchange_result()
        try:
            self._handler([ctx, args.reqSeq, args.temporalPublicKey, args.publicKey, args.verifier])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "requestE2EEKeyExchange", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "requestE2EEKeyExchange", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('requestE2EEKeyExchange', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "requestE2EEKeyExchange", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getLastE2EEPublicKeys(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getLastE2EEPublicKeys, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getLastE2EEPublicKeys_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getLastE2EEPublicKeys_result()
        try:
            result.success = self._handler([ctx, args.chatMid])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getLastE2EEPublicKeys", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getLastE2EEPublicKeys", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getLastE2EEPublicKeys', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getLastE2EEPublicKeys", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _registerE2EEPublicKey(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_registerE2EEPublicKey, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = registerE2EEPublicKey_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = registerE2EEPublicKey_result()
        try:
            result.success = self._handler([ctx, args.reqSeq, args.publicKey])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerE2EEPublicKey", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "registerE2EEPublicKey", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('registerE2EEPublicKey', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "registerE2EEPublicKey", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getE2EEPublicKeys(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getE2EEPublicKeys, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getE2EEPublicKeys_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getE2EEPublicKeys_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getE2EEPublicKeys", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getE2EEPublicKeys", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getE2EEPublicKeys', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getE2EEPublicKeys", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getE2EEPublicKeysEx(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getE2EEPublicKeysEx, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getE2EEPublicKeysEx_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getE2EEPublicKeysEx_result()
        try:
            result.success = self._handler([ctx, args.ignoreE2EEStatus])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getE2EEPublicKeysEx", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getE2EEPublicKeysEx", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getE2EEPublicKeysEx', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getE2EEPublicKeysEx", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getReadMessageOpsInBulk(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getReadMessageOpsInBulk, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getReadMessageOpsInBulk_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getReadMessageOpsInBulk_result()
        try:
            result.success = self._handler([ctx, args.chatIds])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getReadMessageOpsInBulk", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getReadMessageOpsInBulk", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getReadMessageOpsInBulk', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getReadMessageOpsInBulk", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _sendEvent(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_sendEvent, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = sendEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sendEvent_result()
        try:
            result.success = self._handler([ctx, args.seq, args.message])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "sendEvent", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "sendEvent", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('sendEvent', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "sendEvent", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _sendMessage(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_sendMessage, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = sendMessage_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sendMessage_result()
        try:
            result.success = self._handler([ctx, args.seq, args.message])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "sendMessage", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "sendMessage", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('sendMessage', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "sendMessage", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _sendMessageIgnored(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_sendMessageIgnored, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = sendMessageIgnored_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sendMessageIgnored_result()
        try:
            self._handler([ctx, args.seq, args.consumer, args.messageIds])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "sendMessageIgnored", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "sendMessageIgnored", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('sendMessageIgnored', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "sendMessageIgnored", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _sendMessageReceipt(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_sendMessageReceipt, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = sendMessageReceipt_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sendMessageReceipt_result()
        try:
            self._handler([ctx, args.seq, args.consumer, args.messageIds])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "sendMessageReceipt", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "sendMessageReceipt", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('sendMessageReceipt', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "sendMessageReceipt", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _findContactByMetaTag(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_findContactByMetaTag, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = findContactByMetaTag_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findContactByMetaTag_result()
        try:
            result.success = self._handler([ctx, args.userid, args.reference])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "findContactByMetaTag", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "findContactByMetaTag", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('findContactByMetaTag', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "findContactByMetaTag", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _sendMessageToMyHome(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_sendMessageToMyHome, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = sendMessageToMyHome_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sendMessageToMyHome_result()
        try:
            result.success = self._handler([ctx, args.seq, args.message])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "sendMessageToMyHome", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "sendMessageToMyHome", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('sendMessageToMyHome', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "sendMessageToMyHome", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _setBuddyLocation(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_setBuddyLocation, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = setBuddyLocation_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setBuddyLocation_result()
        try:
            self._handler([ctx, args.mid, args.index, args.location])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "setBuddyLocation", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "setBuddyLocation", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('setBuddyLocation', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "setBuddyLocation", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _setIdentityCredential(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_setIdentityCredential, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = setIdentityCredential_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setIdentityCredential_result()
        try:
            self._handler([ctx, args.identifier, args.verifier, args.provider])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "setIdentityCredential", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "setIdentityCredential", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('setIdentityCredential', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "setIdentityCredential", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _setNotificationsEnabled(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_setNotificationsEnabled, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = setNotificationsEnabled_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setNotificationsEnabled_result()
        try:
            self._handler([ctx, args.reqSeq, args.type, args.target, args.enablement])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "setNotificationsEnabled", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "setNotificationsEnabled", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('setNotificationsEnabled', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "setNotificationsEnabled", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _startUpdateVerification(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_startUpdateVerification, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = startUpdateVerification_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = startUpdateVerification_result()
        try:
            result.success = self._handler([ctx, args.region, args.carrier, args.phone, args.udidHash, args.deviceInfo, args.networkCode, args.locale])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "startUpdateVerification", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "startUpdateVerification", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('startUpdateVerification', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "startUpdateVerification", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _startVerification(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_startVerification, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = startVerification_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = startVerification_result()
        try:
            result.success = self._handler([ctx, args.region, args.carrier, args.phone, args.udidHash, args.deviceInfo, args.networkCode, args.mid, args.locale, args.simInfo, args.oldUdidHash])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "startVerification", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "startVerification", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('startVerification', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "startVerification", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _updateGroupPreferenceAttribute(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_updateGroupPreferenceAttribute, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = updateGroupPreferenceAttribute_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateGroupPreferenceAttribute_result()
        try:
            self._handler([ctx, args.reqSeq, args.groupMid, args.updatedAttrs])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateGroupPreferenceAttribute", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateGroupPreferenceAttribute", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('updateGroupPreferenceAttribute', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "updateGroupPreferenceAttribute", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _createRoomV2(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_createRoomV2, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = createRoomV2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createRoomV2_result()
        try:
            result.success = self._handler([ctx, args.reqSeq, args.contactIds])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "createRoomV2", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "createRoomV2", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('createRoomV2', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "createRoomV2", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _storeUpdateProfileAttribute(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_storeUpdateProfileAttribute, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = storeUpdateProfileAttribute_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storeUpdateProfileAttribute_result()
        try:
            self._handler([ctx, args.seq, args.profileAttribute, args.value])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "storeUpdateProfileAttribute", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "storeUpdateProfileAttribute", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('storeUpdateProfileAttribute', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "storeUpdateProfileAttribute", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _syncContactBySnsIds(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_syncContactBySnsIds, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = syncContactBySnsIds_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = syncContactBySnsIds_result()
        try:
            result.success = self._handler([ctx, args.reqSeq, args.modifications])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "syncContactBySnsIds", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "syncContactBySnsIds", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('syncContactBySnsIds', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "syncContactBySnsIds", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _syncContacts(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_syncContacts, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = syncContacts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = syncContacts_result()
        try:
            result.success = self._handler([ctx, args.reqSeq, args.localContacts])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "syncContacts", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "syncContacts", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('syncContacts', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "syncContacts", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _trySendMessage(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_trySendMessage, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = trySendMessage_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = trySendMessage_result()
        try:
            result.success = self._handler([ctx, args.seq, args.message])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "trySendMessage", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "trySendMessage", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('trySendMessage', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "trySendMessage", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getNextMessagesV2(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getNextMessagesV2, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getNextMessagesV2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getNextMessagesV2_result()
        try:
            result.success = self._handler([ctx, args.messageBoxId, args.startMessageId, args.messagesCount])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getNextMessagesV2", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getNextMessagesV2", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getNextMessagesV2', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getNextMessagesV2", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getMessageBoxCompactWrapUpV2(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getMessageBoxCompactWrapUpV2, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getMessageBoxCompactWrapUpV2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMessageBoxCompactWrapUpV2_result()
        try:
            result.success = self._handler([ctx, args.messageBoxId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getMessageBoxCompactWrapUpV2", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getMessageBoxCompactWrapUpV2", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getMessageBoxCompactWrapUpV2', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getMessageBoxCompactWrapUpV2", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getRecentMessagesV2(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getRecentMessagesV2, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getRecentMessagesV2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRecentMessagesV2_result()
        try:
            result.success = self._handler([ctx, args.messageBoxId, args.messagesCount])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getRecentMessagesV2", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getRecentMessagesV2", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getRecentMessagesV2', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getRecentMessagesV2", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _validateContactsOnBot(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_validateContactsOnBot, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = validateContactsOnBot_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = validateContactsOnBot_result()
        try:
            result.success = self._handler([ctx, args.contacts])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "validateContactsOnBot", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "validateContactsOnBot", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('validateContactsOnBot', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "validateContactsOnBot", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _tryFriendRequest(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_tryFriendRequest, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = tryFriendRequest_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tryFriendRequest_result()
        try:
            self._handler([ctx, args.midOrEMid, args.method, args.friendRequestParams])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "tryFriendRequest", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "tryFriendRequest", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('tryFriendRequest', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "tryFriendRequest", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _unblockContact(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_unblockContact, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = unblockContact_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = unblockContact_result()
        try:
            self._handler([ctx, args.reqSeq, args.id])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "unblockContact", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "unblockContact", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('unblockContact', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "unblockContact", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _unblockRecommendation(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_unblockRecommendation, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = unblockRecommendation_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = unblockRecommendation_result()
        try:
            self._handler([ctx, args.reqSeq, args.id])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "unblockRecommendation", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "unblockRecommendation", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('unblockRecommendation', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "unblockRecommendation", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _unregisterUserAndDevice(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_unregisterUserAndDevice, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = unregisterUserAndDevice_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = unregisterUserAndDevice_result()
        try:
            result.success = self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "unregisterUserAndDevice", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "unregisterUserAndDevice", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('unregisterUserAndDevice', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "unregisterUserAndDevice", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _updateApnsDeviceToken(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_updateApnsDeviceToken, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = updateApnsDeviceToken_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateApnsDeviceToken_result()
        try:
            self._handler([ctx, args.apnsDeviceToken])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateApnsDeviceToken", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateApnsDeviceToken", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('updateApnsDeviceToken', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "updateApnsDeviceToken", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _updateBuddySetting(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_updateBuddySetting, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = updateBuddySetting_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateBuddySetting_result()
        try:
            self._handler([ctx, args.key, args.value])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateBuddySetting", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateBuddySetting", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('updateBuddySetting', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "updateBuddySetting", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _updateC2DMRegistrationId(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_updateC2DMRegistrationId, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = updateC2DMRegistrationId_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateC2DMRegistrationId_result()
        try:
            self._handler([ctx, args.registrationId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateC2DMRegistrationId", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateC2DMRegistrationId", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('updateC2DMRegistrationId', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "updateC2DMRegistrationId", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _updateContactSetting(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_updateContactSetting, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = updateContactSetting_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateContactSetting_result()
        try:
            self._handler([ctx, args.reqSeq, args.mid, args.flag, args.value])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateContactSetting", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateContactSetting", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('updateContactSetting', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "updateContactSetting", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _updateCustomModeSettings(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_updateCustomModeSettings, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = updateCustomModeSettings_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateCustomModeSettings_result()
        try:
            self._handler([ctx, args.customMode, args.paramMap])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateCustomModeSettings", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateCustomModeSettings", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('updateCustomModeSettings', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "updateCustomModeSettings", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _updateDeviceInfo(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_updateDeviceInfo, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = updateDeviceInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateDeviceInfo_result()
        try:
            self._handler([ctx, args.deviceUid, args.deviceInfo])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateDeviceInfo", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateDeviceInfo", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('updateDeviceInfo', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "updateDeviceInfo", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _updateGroup(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_updateGroup, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = updateGroup_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateGroup_result()
        try:
            self._handler([ctx, args.reqSeq, args.group])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateGroup", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateGroup", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('updateGroup', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "updateGroup", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _updateNotificationToken(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_updateNotificationToken, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = updateNotificationToken_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateNotificationToken_result()
        try:
            self._handler([ctx, args.type, args.token])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateNotificationToken", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateNotificationToken", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('updateNotificationToken', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "updateNotificationToken", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _updateNotificationTokenWithBytes(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_updateNotificationTokenWithBytes, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = updateNotificationTokenWithBytes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateNotificationTokenWithBytes_result()
        try:
            self._handler([ctx, args.type, args.token])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateNotificationTokenWithBytes", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateNotificationTokenWithBytes", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('updateNotificationTokenWithBytes', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "updateNotificationTokenWithBytes", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _updateProfile(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_updateProfile, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = updateProfile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateProfile_result()
        try:
            self._handler([ctx, args.reqSeq, args.profile])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateProfile", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateProfile", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('updateProfile', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "updateProfile", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _updateProfileAttribute(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_updateProfileAttribute, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = updateProfileAttribute_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateProfileAttribute_result()
        try:
            self._handler([ctx, args.reqSeq, args.attr, args.value])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateProfileAttribute", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateProfileAttribute", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('updateProfileAttribute', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "updateProfileAttribute", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _updateRegion(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_updateRegion, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = updateRegion_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateRegion_result()
        try:
            self._handler([ctx, args.region])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateRegion", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateRegion", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('updateRegion', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "updateRegion", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _updateSettings(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_updateSettings, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = updateSettings_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateSettings_result()
        try:
            self._handler([ctx, args.reqSeq, args.settings])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateSettings", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateSettings", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('updateSettings', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "updateSettings", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _updateSettings2(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_updateSettings2, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = updateSettings2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateSettings2_result()
        try:
            result.success = self._handler([ctx, args.reqSeq, args.settings])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateSettings2", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateSettings2", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('updateSettings2', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "updateSettings2", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _updateSettingsAttribute(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_updateSettingsAttribute, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = updateSettingsAttribute_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateSettingsAttribute_result()
        try:
            self._handler([ctx, args.reqSeq, args.attr, args.value])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateSettingsAttribute", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateSettingsAttribute", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('updateSettingsAttribute', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "updateSettingsAttribute", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _updateSettingsAttributes(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_updateSettingsAttributes, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = updateSettingsAttributes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateSettingsAttributes_result()
        try:
            result.success = self._handler([ctx, args.reqSeq, args.attrBitset, args.settings])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateSettingsAttributes", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "updateSettingsAttributes", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('updateSettingsAttributes', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "updateSettingsAttributes", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _verifyIdentityCredential(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_verifyIdentityCredential, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = verifyIdentityCredential_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = verifyIdentityCredential_result()
        try:
            self._handler([ctx, args.identityProvider, args.identifier, args.password])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "verifyIdentityCredential", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "verifyIdentityCredential", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('verifyIdentityCredential', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "verifyIdentityCredential", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _verifyIdentityCredentialWithResult(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_verifyIdentityCredentialWithResult, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = verifyIdentityCredentialWithResult_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = verifyIdentityCredentialWithResult_result()
        try:
            result.success = self._handler([ctx, args.identityCredential])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "verifyIdentityCredentialWithResult", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "verifyIdentityCredentialWithResult", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('verifyIdentityCredentialWithResult', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "verifyIdentityCredentialWithResult", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _verifyPhone(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_verifyPhone, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = verifyPhone_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = verifyPhone_result()
        try:
            result.success = self._handler([ctx, args.sessionId, args.pinCode, args.udidHash])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "verifyPhone", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "verifyPhone", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('verifyPhone', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "verifyPhone", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _verifyQrcode(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_verifyQrcode, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = verifyQrcode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = verifyQrcode_result()
        try:
            result.success = self._handler([ctx, args.verifier, args.pinCode])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "verifyQrcode", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "verifyQrcode", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('verifyQrcode', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "verifyQrcode", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


def _write_application_exception(ctx, oprot, method, ex_code=None, message=None, exception=None):
    if exception is not None:
        x = exception
    else:
        x = TApplicationException(type=ex_code, message=message)
    oprot.write_response_headers(ctx)
    oprot.writeMessageBegin(method, TMessageType.EXCEPTION, 0)
    x.write(oprot)
    oprot.writeMessageEnd()
    oprot.get_transport().flush()
    return x

class getChatRoomAnnouncementsBulk_args(object):
    """
    Attributes:
     - chatRoomMids
    """
    def __init__(self, chatRoomMids=None):
        self.chatRoomMids = chatRoomMids

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.LIST:
                    self.chatRoomMids = []
                    (_, elem623) = iprot.readListBegin()
                    for _ in range(elem623):
                        elem624 = iprot.readString()
                        self.chatRoomMids.append(elem624)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getChatRoomAnnouncementsBulk_args')
        if self.chatRoomMids is not None:
            oprot.writeFieldBegin('chatRoomMids', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.chatRoomMids))
            for elem625 in self.chatRoomMids:
                oprot.writeString(elem625)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.chatRoomMids))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getChatRoomAnnouncementsBulk_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_, _, elem626) = iprot.readMapBegin()
                    for _ in range(elem626):
                        elem628 = iprot.readString()
                        elem627 = []
                        (_, elem629) = iprot.readListBegin()
                        for _ in range(elem629):
                            elem630 = ChatRoomAnnouncement()
                            elem630.read(iprot)
                            elem627.append(elem630)
                        iprot.readListEnd()
                        self.success[elem628] = elem627
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getChatRoomAnnouncementsBulk_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.success))
            for elem632, elem631 in self.success.items():
                oprot.writeString(elem632)
                oprot.writeListBegin(TType.STRUCT, len(elem631))
                for elem633 in elem631:
                    elem633.write(oprot)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getChatRoomAnnouncements_args(object):
    """
    Attributes:
     - chatRoomMid
    """
    def __init__(self, chatRoomMid=None):
        self.chatRoomMid = chatRoomMid

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.chatRoomMid = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getChatRoomAnnouncements_args')
        if self.chatRoomMid is not None:
            oprot.writeFieldBegin('chatRoomMid', TType.STRING, 2)
            oprot.writeString(self.chatRoomMid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.chatRoomMid))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getChatRoomAnnouncements_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem634) = iprot.readListBegin()
                    for _ in range(elem634):
                        elem635 = ChatRoomAnnouncement()
                        elem635.read(iprot)
                        self.success.append(elem635)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getChatRoomAnnouncements_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem636 in self.success:
                elem636.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class createChatRoomAnnouncement_args(object):
    """
    Attributes:
     - reqSeq
     - chatRoomMid
     - type
     - contents
    """
    def __init__(self, reqSeq=None, chatRoomMid=None, type=None, contents=None):
        self.reqSeq = reqSeq
        self.chatRoomMid = chatRoomMid
        self.type = type
        self.contents = contents

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.chatRoomMid = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.type = ChatRoomAnnouncementType(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.contents = ChatRoomAnnouncementContents()
                    self.contents.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('createChatRoomAnnouncement_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.chatRoomMid is not None:
            oprot.writeFieldBegin('chatRoomMid', TType.STRING, 2)
            oprot.writeString(self.chatRoomMid)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 3)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.contents is not None:
            oprot.writeFieldBegin('contents', TType.STRUCT, 4)
            self.contents.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.chatRoomMid))
        value = (value * 31) ^ hash(make_hashable(self.type))
        value = (value * 31) ^ hash(make_hashable(self.contents))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class createChatRoomAnnouncement_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ChatRoomAnnouncement()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('createChatRoomAnnouncement_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class removeChatRoomAnnouncement_args(object):
    """
    Attributes:
     - reqSeq
     - chatRoomMid
     - announcementSeq
    """
    def __init__(self, reqSeq=None, chatRoomMid=None, announcementSeq=None):
        self.reqSeq = reqSeq
        self.chatRoomMid = chatRoomMid
        self.announcementSeq = announcementSeq

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.chatRoomMid = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.announcementSeq = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('removeChatRoomAnnouncement_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.chatRoomMid is not None:
            oprot.writeFieldBegin('chatRoomMid', TType.STRING, 2)
            oprot.writeString(self.chatRoomMid)
            oprot.writeFieldEnd()
        if self.announcementSeq is not None:
            oprot.writeFieldBegin('announcementSeq', TType.I64, 3)
            oprot.writeI64(self.announcementSeq)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.chatRoomMid))
        value = (value * 31) ^ hash(make_hashable(self.announcementSeq))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class removeChatRoomAnnouncement_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('removeChatRoomAnnouncement_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class unsendMessage_args(object):
    """
    Attributes:
     - seq
     - messageId
    """
    def __init__(self, seq=None, messageId=None):
        self.seq = seq
        self.messageId = messageId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.seq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.messageId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('unsendMessage_args')
        if self.seq is not None:
            oprot.writeFieldBegin('seq', TType.I32, 1)
            oprot.writeI32(self.seq)
            oprot.writeFieldEnd()
        if self.messageId is not None:
            oprot.writeFieldBegin('messageId', TType.STRING, 2)
            oprot.writeString(self.messageId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.seq))
        value = (value * 31) ^ hash(make_hashable(self.messageId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class unsendMessage_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('unsendMessage_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getGroupWithoutMembers_args(object):
    """
    Attributes:
     - groupId
    """
    def __init__(self, groupId=None):
        self.groupId = groupId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.groupId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getGroupWithoutMembers_args')
        if self.groupId is not None:
            oprot.writeFieldBegin('groupId', TType.STRING, 2)
            oprot.writeString(self.groupId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.groupId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getGroupWithoutMembers_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Group()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getGroupWithoutMembers_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class requestResendMessage_args(object):
    """
    Attributes:
     - reqSeq
     - senderMid
     - messageId
    """
    def __init__(self, reqSeq=None, senderMid=None, messageId=None):
        self.reqSeq = reqSeq
        self.senderMid = senderMid
        self.messageId = messageId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.senderMid = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.messageId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('requestResendMessage_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.senderMid is not None:
            oprot.writeFieldBegin('senderMid', TType.STRING, 2)
            oprot.writeString(self.senderMid)
            oprot.writeFieldEnd()
        if self.messageId is not None:
            oprot.writeFieldBegin('messageId', TType.STRING, 3)
            oprot.writeString(self.messageId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.senderMid))
        value = (value * 31) ^ hash(make_hashable(self.messageId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class requestResendMessage_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('requestResendMessage_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class respondResendMessage_args(object):
    """
    Attributes:
     - reqSeq
     - receiverMid
     - originalMessageId
     - resendMessage
     - errorCode
    """
    def __init__(self, reqSeq=None, receiverMid=None, originalMessageId=None, resendMessage=None, errorCode=None):
        self.reqSeq = reqSeq
        self.receiverMid = receiverMid
        self.originalMessageId = originalMessageId
        self.resendMessage = resendMessage
        self.errorCode = errorCode

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.receiverMid = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.originalMessageId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.resendMessage = Message()
                    self.resendMessage.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.errorCode = ErrorCode(iprot.readI32())
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('respondResendMessage_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.receiverMid is not None:
            oprot.writeFieldBegin('receiverMid', TType.STRING, 2)
            oprot.writeString(self.receiverMid)
            oprot.writeFieldEnd()
        if self.originalMessageId is not None:
            oprot.writeFieldBegin('originalMessageId', TType.STRING, 3)
            oprot.writeString(self.originalMessageId)
            oprot.writeFieldEnd()
        if self.resendMessage is not None:
            oprot.writeFieldBegin('resendMessage', TType.STRUCT, 4)
            self.resendMessage.write(oprot)
            oprot.writeFieldEnd()
        if self.errorCode is not None:
            oprot.writeFieldBegin('errorCode', TType.I32, 5)
            oprot.writeI32(self.errorCode)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.receiverMid))
        value = (value * 31) ^ hash(make_hashable(self.originalMessageId))
        value = (value * 31) ^ hash(make_hashable(self.resendMessage))
        value = (value * 31) ^ hash(make_hashable(self.errorCode))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class respondResendMessage_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('respondResendMessage_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class acceptGroupInvitation_args(object):
    """
    Attributes:
     - reqSeq
     - groupId
    """
    def __init__(self, reqSeq=None, groupId=None):
        self.reqSeq = reqSeq
        self.groupId = groupId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.groupId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('acceptGroupInvitation_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.groupId is not None:
            oprot.writeFieldBegin('groupId', TType.STRING, 2)
            oprot.writeString(self.groupId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.groupId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class acceptGroupInvitation_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('acceptGroupInvitation_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class acceptGroupInvitationByTicket_args(object):
    """
    Attributes:
     - reqSeq
     - GroupMid
     - ticketId
    """
    def __init__(self, reqSeq=None, GroupMid=None, ticketId=None):
        self.reqSeq = reqSeq
        self.GroupMid = GroupMid
        self.ticketId = ticketId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.GroupMid = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.ticketId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('acceptGroupInvitationByTicket_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.GroupMid is not None:
            oprot.writeFieldBegin('GroupMid', TType.STRING, 2)
            oprot.writeString(self.GroupMid)
            oprot.writeFieldEnd()
        if self.ticketId is not None:
            oprot.writeFieldBegin('ticketId', TType.STRING, 3)
            oprot.writeString(self.ticketId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.GroupMid))
        value = (value * 31) ^ hash(make_hashable(self.ticketId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class acceptGroupInvitationByTicket_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('acceptGroupInvitationByTicket_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class acceptProximityMatches_args(object):
    """
    Attributes:
     - sessionId
     - ids
    """
    def __init__(self, sessionId=None, ids=None):
        self.sessionId = sessionId
        self.ids = ids

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.ids = set()
                    (_, elem637) = iprot.readSetBegin()
                    for _ in range(elem637):
                        elem638 = iprot.readString()
                        self.ids.add(elem638)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('acceptProximityMatches_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 2)
            oprot.writeString(self.sessionId)
            oprot.writeFieldEnd()
        if self.ids is not None:
            oprot.writeFieldBegin('ids', TType.SET, 3)
            oprot.writeSetBegin(TType.STRING, len(self.ids))
            for elem639 in self.ids:
                oprot.writeString(elem639)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.sessionId))
        value = (value * 31) ^ hash(make_hashable(self.ids))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class acceptProximityMatches_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('acceptProximityMatches_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class acquireCallRoute_args(object):
    """
    Attributes:
     - to
    """
    def __init__(self, to=None):
        self.to = to

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.to = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('acquireCallRoute_args')
        if self.to is not None:
            oprot.writeFieldBegin('to', TType.STRING, 2)
            oprot.writeString(self.to)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.to))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class acquireCallRoute_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem640) = iprot.readListBegin()
                    for _ in range(elem640):
                        elem641 = iprot.readString()
                        self.success.append(elem641)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('acquireCallRoute_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for elem642 in self.success:
                oprot.writeString(elem642)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class acquireCallTicket_args(object):
    """
    Attributes:
     - to
    """
    def __init__(self, to=None):
        self.to = to

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.to = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('acquireCallTicket_args')
        if self.to is not None:
            oprot.writeFieldBegin('to', TType.STRING, 2)
            oprot.writeString(self.to)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.to))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class acquireCallTicket_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('acquireCallTicket_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class acquireEncryptedAccessToken_args(object):
    """
    Attributes:
     - featureType
    """
    def __init__(self, featureType=None):
        self.featureType = featureType

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I32:
                    self.featureType = FeatureType(iprot.readI32())
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('acquireEncryptedAccessToken_args')
        if self.featureType is not None:
            oprot.writeFieldBegin('featureType', TType.I32, 2)
            oprot.writeI32(self.featureType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.featureType))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class acquireEncryptedAccessToken_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('acquireEncryptedAccessToken_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class addSnsId_args(object):
    """
    Attributes:
     - snsIdType
     - snsAccessToken
    """
    def __init__(self, snsIdType=None, snsAccessToken=None):
        self.snsIdType = snsIdType
        self.snsAccessToken = snsAccessToken

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I32:
                    self.snsIdType = SnsIdType(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.snsAccessToken = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('addSnsId_args')
        if self.snsIdType is not None:
            oprot.writeFieldBegin('snsIdType', TType.I32, 2)
            oprot.writeI32(self.snsIdType)
            oprot.writeFieldEnd()
        if self.snsAccessToken is not None:
            oprot.writeFieldBegin('snsAccessToken', TType.STRING, 3)
            oprot.writeString(self.snsAccessToken)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.snsIdType))
        value = (value * 31) ^ hash(make_hashable(self.snsAccessToken))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class addSnsId_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('addSnsId_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class blockContact_args(object):
    """
    Attributes:
     - reqSeq
     - id
    """
    def __init__(self, reqSeq=None, id=None):
        self.reqSeq = reqSeq
        self.id = id

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.id = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('blockContact_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 2)
            oprot.writeString(self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.id))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class blockContact_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('blockContact_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class blockRecommendation_args(object):
    """
    Attributes:
     - reqSeq
     - id
    """
    def __init__(self, reqSeq=None, id=None):
        self.reqSeq = reqSeq
        self.id = id

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.id = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('blockRecommendation_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 2)
            oprot.writeString(self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.id))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class blockRecommendation_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('blockRecommendation_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class cancelGroupInvitation_args(object):
    """
    Attributes:
     - reqSeq
     - groupId
     - contactIds
    """
    def __init__(self, reqSeq=None, groupId=None, contactIds=None):
        self.reqSeq = reqSeq
        self.groupId = groupId
        self.contactIds = contactIds

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.groupId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.contactIds = []
                    (_, elem643) = iprot.readListBegin()
                    for _ in range(elem643):
                        elem644 = iprot.readString()
                        self.contactIds.append(elem644)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('cancelGroupInvitation_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.groupId is not None:
            oprot.writeFieldBegin('groupId', TType.STRING, 2)
            oprot.writeString(self.groupId)
            oprot.writeFieldEnd()
        if self.contactIds is not None:
            oprot.writeFieldBegin('contactIds', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.contactIds))
            for elem645 in self.contactIds:
                oprot.writeString(elem645)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.groupId))
        value = (value * 31) ^ hash(make_hashable(self.contactIds))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class cancelGroupInvitation_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('cancelGroupInvitation_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class changeVerificationMethod_args(object):
    """
    Attributes:
     - sessionId
     - method
    """
    def __init__(self, sessionId=None, method=None):
        self.sessionId = sessionId
        self.method = method

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.method = VerificationMethod(iprot.readI32())
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('changeVerificationMethod_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 2)
            oprot.writeString(self.sessionId)
            oprot.writeFieldEnd()
        if self.method is not None:
            oprot.writeFieldBegin('method', TType.I32, 3)
            oprot.writeI32(self.method)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.sessionId))
        value = (value * 31) ^ hash(make_hashable(self.method))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class changeVerificationMethod_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = VerificationSessionData()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('changeVerificationMethod_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class clearIdentityCredential_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('clearIdentityCredential_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class clearIdentityCredential_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('clearIdentityCredential_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class clearMessageBox_args(object):
    """
    Attributes:
     - channelId
     - messageBoxId
    """
    def __init__(self, channelId=None, messageBoxId=None):
        self.channelId = channelId
        self.messageBoxId = messageBoxId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.channelId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.messageBoxId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('clearMessageBox_args')
        if self.channelId is not None:
            oprot.writeFieldBegin('channelId', TType.STRING, 2)
            oprot.writeString(self.channelId)
            oprot.writeFieldEnd()
        if self.messageBoxId is not None:
            oprot.writeFieldBegin('messageBoxId', TType.STRING, 3)
            oprot.writeString(self.messageBoxId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.channelId))
        value = (value * 31) ^ hash(make_hashable(self.messageBoxId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class clearMessageBox_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('clearMessageBox_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class closeProximityMatch_args(object):
    """
    Attributes:
     - sessionId
    """
    def __init__(self, sessionId=None):
        self.sessionId = sessionId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('closeProximityMatch_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 2)
            oprot.writeString(self.sessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.sessionId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class closeProximityMatch_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('closeProximityMatch_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class commitSendMessage_args(object):
    """
    Attributes:
     - seq
     - messageId
     - receiverMids
    """
    def __init__(self, seq=None, messageId=None, receiverMids=None):
        self.seq = seq
        self.messageId = messageId
        self.receiverMids = receiverMids

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.seq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.messageId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.receiverMids = []
                    (_, elem646) = iprot.readListBegin()
                    for _ in range(elem646):
                        elem647 = iprot.readString()
                        self.receiverMids.append(elem647)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('commitSendMessage_args')
        if self.seq is not None:
            oprot.writeFieldBegin('seq', TType.I32, 1)
            oprot.writeI32(self.seq)
            oprot.writeFieldEnd()
        if self.messageId is not None:
            oprot.writeFieldBegin('messageId', TType.STRING, 2)
            oprot.writeString(self.messageId)
            oprot.writeFieldEnd()
        if self.receiverMids is not None:
            oprot.writeFieldBegin('receiverMids', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.receiverMids))
            for elem648 in self.receiverMids:
                oprot.writeString(elem648)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.seq))
        value = (value * 31) ^ hash(make_hashable(self.messageId))
        value = (value * 31) ^ hash(make_hashable(self.receiverMids))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class commitSendMessage_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_, _, elem649) = iprot.readMapBegin()
                    for _ in range(elem649):
                        elem651 = iprot.readString()
                        elem650 = iprot.readString()
                        self.success[elem651] = elem650
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('commitSendMessage_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for elem653, elem652 in self.success.items():
                oprot.writeString(elem653)
                oprot.writeString(elem652)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class commitSendMessages_args(object):
    """
    Attributes:
     - seq
     - messageIds
     - receiverMids
    """
    def __init__(self, seq=None, messageIds=None, receiverMids=None):
        self.seq = seq
        self.messageIds = messageIds
        self.receiverMids = receiverMids

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.seq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.messageIds = []
                    (_, elem654) = iprot.readListBegin()
                    for _ in range(elem654):
                        elem655 = iprot.readString()
                        self.messageIds.append(elem655)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.receiverMids = []
                    (_, elem656) = iprot.readListBegin()
                    for _ in range(elem656):
                        elem657 = iprot.readString()
                        self.receiverMids.append(elem657)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('commitSendMessages_args')
        if self.seq is not None:
            oprot.writeFieldBegin('seq', TType.I32, 1)
            oprot.writeI32(self.seq)
            oprot.writeFieldEnd()
        if self.messageIds is not None:
            oprot.writeFieldBegin('messageIds', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.messageIds))
            for elem658 in self.messageIds:
                oprot.writeString(elem658)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.receiverMids is not None:
            oprot.writeFieldBegin('receiverMids', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.receiverMids))
            for elem659 in self.receiverMids:
                oprot.writeString(elem659)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.seq))
        value = (value * 31) ^ hash(make_hashable(self.messageIds))
        value = (value * 31) ^ hash(make_hashable(self.receiverMids))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class commitSendMessages_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_, _, elem660) = iprot.readMapBegin()
                    for _ in range(elem660):
                        elem662 = iprot.readString()
                        elem661 = iprot.readString()
                        self.success[elem662] = elem661
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('commitSendMessages_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for elem664, elem663 in self.success.items():
                oprot.writeString(elem664)
                oprot.writeString(elem663)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class commitUpdateProfile_args(object):
    """
    Attributes:
     - seq
     - attrs
     - receiverMids
    """
    def __init__(self, seq=None, attrs=None, receiverMids=None):
        self.seq = seq
        self.attrs = attrs
        self.receiverMids = receiverMids

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.seq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.attrs = []
                    (_, elem665) = iprot.readListBegin()
                    for _ in range(elem665):
                        elem666 = ProfileAttribute(iprot.readI32())
                        self.attrs.append(elem666)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.receiverMids = []
                    (_, elem667) = iprot.readListBegin()
                    for _ in range(elem667):
                        elem668 = iprot.readString()
                        self.receiverMids.append(elem668)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('commitUpdateProfile_args')
        if self.seq is not None:
            oprot.writeFieldBegin('seq', TType.I32, 1)
            oprot.writeI32(self.seq)
            oprot.writeFieldEnd()
        if self.attrs is not None:
            oprot.writeFieldBegin('attrs', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.attrs))
            for elem669 in self.attrs:
                oprot.writeI32(elem669)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.receiverMids is not None:
            oprot.writeFieldBegin('receiverMids', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.receiverMids))
            for elem670 in self.receiverMids:
                oprot.writeString(elem670)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.seq))
        value = (value * 31) ^ hash(make_hashable(self.attrs))
        value = (value * 31) ^ hash(make_hashable(self.receiverMids))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class commitUpdateProfile_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_, _, elem671) = iprot.readMapBegin()
                    for _ in range(elem671):
                        elem673 = iprot.readString()
                        elem672 = iprot.readString()
                        self.success[elem673] = elem672
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('commitUpdateProfile_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for elem675, elem674 in self.success.items():
                oprot.writeString(elem675)
                oprot.writeString(elem674)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class confirmEmail_args(object):
    """
    Attributes:
     - verifier
     - pinCode
    """
    def __init__(self, verifier=None, pinCode=None):
        self.verifier = verifier
        self.pinCode = pinCode

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.verifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.pinCode = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('confirmEmail_args')
        if self.verifier is not None:
            oprot.writeFieldBegin('verifier', TType.STRING, 2)
            oprot.writeString(self.verifier)
            oprot.writeFieldEnd()
        if self.pinCode is not None:
            oprot.writeFieldBegin('pinCode', TType.STRING, 3)
            oprot.writeString(self.pinCode)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.verifier))
        value = (value * 31) ^ hash(make_hashable(self.pinCode))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class confirmEmail_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('confirmEmail_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class createGroup_args(object):
    """
    Attributes:
     - seq
     - name
     - contactIds
    """
    def __init__(self, seq=None, name=None, contactIds=None):
        self.seq = seq
        self.name = name
        self.contactIds = contactIds

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.seq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.contactIds = []
                    (_, elem676) = iprot.readListBegin()
                    for _ in range(elem676):
                        elem677 = iprot.readString()
                        self.contactIds.append(elem677)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('createGroup_args')
        if self.seq is not None:
            oprot.writeFieldBegin('seq', TType.I32, 1)
            oprot.writeI32(self.seq)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.contactIds is not None:
            oprot.writeFieldBegin('contactIds', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.contactIds))
            for elem678 in self.contactIds:
                oprot.writeString(elem678)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.seq))
        value = (value * 31) ^ hash(make_hashable(self.name))
        value = (value * 31) ^ hash(make_hashable(self.contactIds))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class createGroup_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Group()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('createGroup_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class createQrcodeBase64Image_args(object):
    """
    Attributes:
     - url
     - characterSet
     - imageSize
     - x
     - y
     - width
     - height
    """
    def __init__(self, url=None, characterSet=None, imageSize=None, x=None, y=None, width=None, height=None):
        self.url = url
        self.characterSet = characterSet
        self.imageSize = imageSize
        self.x = x
        self.y = y
        self.width = width
        self.height = height

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.url = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.characterSet = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.imageSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.x = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.y = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.width = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.height = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('createQrcodeBase64Image_args')
        if self.url is not None:
            oprot.writeFieldBegin('url', TType.STRING, 2)
            oprot.writeString(self.url)
            oprot.writeFieldEnd()
        if self.characterSet is not None:
            oprot.writeFieldBegin('characterSet', TType.STRING, 3)
            oprot.writeString(self.characterSet)
            oprot.writeFieldEnd()
        if self.imageSize is not None:
            oprot.writeFieldBegin('imageSize', TType.I32, 4)
            oprot.writeI32(self.imageSize)
            oprot.writeFieldEnd()
        if self.x is not None:
            oprot.writeFieldBegin('x', TType.I32, 5)
            oprot.writeI32(self.x)
            oprot.writeFieldEnd()
        if self.y is not None:
            oprot.writeFieldBegin('y', TType.I32, 6)
            oprot.writeI32(self.y)
            oprot.writeFieldEnd()
        if self.width is not None:
            oprot.writeFieldBegin('width', TType.I32, 7)
            oprot.writeI32(self.width)
            oprot.writeFieldEnd()
        if self.height is not None:
            oprot.writeFieldBegin('height', TType.I32, 8)
            oprot.writeI32(self.height)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.url))
        value = (value * 31) ^ hash(make_hashable(self.characterSet))
        value = (value * 31) ^ hash(make_hashable(self.imageSize))
        value = (value * 31) ^ hash(make_hashable(self.x))
        value = (value * 31) ^ hash(make_hashable(self.y))
        value = (value * 31) ^ hash(make_hashable(self.width))
        value = (value * 31) ^ hash(make_hashable(self.height))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class createQrcodeBase64Image_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('createQrcodeBase64Image_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class createRoom_args(object):
    """
    Attributes:
     - reqSeq
     - contactIds
    """
    def __init__(self, reqSeq=None, contactIds=None):
        self.reqSeq = reqSeq
        self.contactIds = contactIds

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.contactIds = []
                    (_, elem679) = iprot.readListBegin()
                    for _ in range(elem679):
                        elem680 = iprot.readString()
                        self.contactIds.append(elem680)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('createRoom_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.contactIds is not None:
            oprot.writeFieldBegin('contactIds', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.contactIds))
            for elem681 in self.contactIds:
                oprot.writeString(elem681)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.contactIds))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class createRoom_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Room()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('createRoom_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class createSession_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('createSession_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class createSession_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('createSession_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class fetchAnnouncements_args(object):
    """
    Attributes:
     - lastFetchedIndex
    """
    def __init__(self, lastFetchedIndex=None):
        self.lastFetchedIndex = lastFetchedIndex

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I32:
                    self.lastFetchedIndex = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('fetchAnnouncements_args')
        if self.lastFetchedIndex is not None:
            oprot.writeFieldBegin('lastFetchedIndex', TType.I32, 2)
            oprot.writeI32(self.lastFetchedIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.lastFetchedIndex))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class fetchAnnouncements_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem682) = iprot.readListBegin()
                    for _ in range(elem682):
                        elem683 = Announcement()
                        elem683.read(iprot)
                        self.success.append(elem683)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('fetchAnnouncements_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem684 in self.success:
                elem684.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class fetchMessages_args(object):
    """
    Attributes:
     - localTs
     - count
    """
    def __init__(self, localTs=None, count=None):
        self.localTs = localTs
        self.count = count

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I64:
                    self.localTs = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('fetchMessages_args')
        if self.localTs is not None:
            oprot.writeFieldBegin('localTs', TType.I64, 2)
            oprot.writeI64(self.localTs)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 3)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.localTs))
        value = (value * 31) ^ hash(make_hashable(self.count))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class fetchMessages_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem685) = iprot.readListBegin()
                    for _ in range(elem685):
                        elem686 = Message()
                        elem686.read(iprot)
                        self.success.append(elem686)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('fetchMessages_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem687 in self.success:
                elem687.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class fetchOperations_args(object):
    """
    Attributes:
     - localRev
     - count
    """
    def __init__(self, localRev=None, count=None):
        self.localRev = localRev
        self.count = count

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I64:
                    self.localRev = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('fetchOperations_args')
        if self.localRev is not None:
            oprot.writeFieldBegin('localRev', TType.I64, 2)
            oprot.writeI64(self.localRev)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 3)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.localRev))
        value = (value * 31) ^ hash(make_hashable(self.count))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class fetchOperations_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem688) = iprot.readListBegin()
                    for _ in range(elem688):
                        elem689 = Operation()
                        elem689.read(iprot)
                        self.success.append(elem689)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ShouldSyncException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('fetchOperations_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem690 in self.success:
                elem690.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class fetchOps_args(object):
    """
    Attributes:
     - localRev
     - count
     - globalRev
     - individualRev
    """
    def __init__(self, localRev=None, count=None, globalRev=None, individualRev=None):
        self.localRev = localRev
        self.count = count
        self.globalRev = globalRev
        self.individualRev = individualRev

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I64:
                    self.localRev = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.globalRev = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.individualRev = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('fetchOps_args')
        if self.localRev is not None:
            oprot.writeFieldBegin('localRev', TType.I64, 2)
            oprot.writeI64(self.localRev)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 3)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        if self.globalRev is not None:
            oprot.writeFieldBegin('globalRev', TType.I64, 4)
            oprot.writeI64(self.globalRev)
            oprot.writeFieldEnd()
        if self.individualRev is not None:
            oprot.writeFieldBegin('individualRev', TType.I64, 5)
            oprot.writeI64(self.individualRev)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.localRev))
        value = (value * 31) ^ hash(make_hashable(self.count))
        value = (value * 31) ^ hash(make_hashable(self.globalRev))
        value = (value * 31) ^ hash(make_hashable(self.individualRev))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class fetchOps_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem691) = iprot.readListBegin()
                    for _ in range(elem691):
                        elem692 = Operation()
                        elem692.read(iprot)
                        self.success.append(elem692)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ShouldSyncException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('fetchOps_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem693 in self.success:
                elem693.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class findAndAddContactsByEmail_args(object):
    """
    Attributes:
     - reqSeq
     - emails
    """
    def __init__(self, reqSeq=None, emails=None):
        self.reqSeq = reqSeq
        self.emails = emails

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.SET:
                    self.emails = set()
                    (_, elem694) = iprot.readSetBegin()
                    for _ in range(elem694):
                        elem695 = iprot.readString()
                        self.emails.add(elem695)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('findAndAddContactsByEmail_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.emails is not None:
            oprot.writeFieldBegin('emails', TType.SET, 2)
            oprot.writeSetBegin(TType.STRING, len(self.emails))
            for elem696 in self.emails:
                oprot.writeString(elem696)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.emails))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class findAndAddContactsByEmail_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_, _, elem697) = iprot.readMapBegin()
                    for _ in range(elem697):
                        elem699 = iprot.readString()
                        elem698 = Contact()
                        elem698.read(iprot)
                        self.success[elem699] = elem698
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('findAndAddContactsByEmail_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for elem701, elem700 in self.success.items():
                oprot.writeString(elem701)
                elem700.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class findAndAddContactsByMid_args(object):
    """
    Attributes:
     - reqSeq
     - mid
     - type
     - reference
    """
    def __init__(self, reqSeq=None, mid=None, type=None, reference=None):
        self.reqSeq = reqSeq
        self.mid = mid
        self.type = type
        self.reference = reference

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mid = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.type = ContactType(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.reference = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('findAndAddContactsByMid_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.mid is not None:
            oprot.writeFieldBegin('mid', TType.STRING, 2)
            oprot.writeString(self.mid)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 3)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.reference is not None:
            oprot.writeFieldBegin('reference', TType.STRING, 4)
            oprot.writeString(self.reference)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.mid))
        value = (value * 31) ^ hash(make_hashable(self.type))
        value = (value * 31) ^ hash(make_hashable(self.reference))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class findAndAddContactsByMid_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_, _, elem702) = iprot.readMapBegin()
                    for _ in range(elem702):
                        elem704 = iprot.readString()
                        elem703 = Contact()
                        elem703.read(iprot)
                        self.success[elem704] = elem703
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('findAndAddContactsByMid_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for elem706, elem705 in self.success.items():
                oprot.writeString(elem706)
                elem705.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class findGroupByTicketV2_args(object):
    """
    Attributes:
     - ticketId
    """
    def __init__(self, ticketId=None):
        self.ticketId = ticketId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ticketId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('findGroupByTicketV2_args')
        if self.ticketId is not None:
            oprot.writeFieldBegin('ticketId', TType.STRING, 1)
            oprot.writeString(self.ticketId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.ticketId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class findGroupByTicketV2_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Group()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('findGroupByTicketV2_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class findAndAddContactsByPhone_args(object):
    """
    Attributes:
     - reqSeq
     - phones
    """
    def __init__(self, reqSeq=None, phones=None):
        self.reqSeq = reqSeq
        self.phones = phones

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.SET:
                    self.phones = set()
                    (_, elem707) = iprot.readSetBegin()
                    for _ in range(elem707):
                        elem708 = iprot.readString()
                        self.phones.add(elem708)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('findAndAddContactsByPhone_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.phones is not None:
            oprot.writeFieldBegin('phones', TType.SET, 2)
            oprot.writeSetBegin(TType.STRING, len(self.phones))
            for elem709 in self.phones:
                oprot.writeString(elem709)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.phones))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class findAndAddContactsByPhone_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_, _, elem710) = iprot.readMapBegin()
                    for _ in range(elem710):
                        elem712 = iprot.readString()
                        elem711 = Contact()
                        elem711.read(iprot)
                        self.success[elem712] = elem711
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('findAndAddContactsByPhone_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for elem714, elem713 in self.success.items():
                oprot.writeString(elem714)
                elem713.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getFriendRequests_args(object):
    """
    Attributes:
     - direction
     - lastSeenSeqId
    """
    def __init__(self, direction=None, lastSeenSeqId=None):
        self.direction = direction
        self.lastSeenSeqId = lastSeenSeqId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.direction = FriendRequestDirection(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.lastSeenSeqId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getFriendRequests_args')
        if self.direction is not None:
            oprot.writeFieldBegin('direction', TType.I32, 1)
            oprot.writeI32(self.direction)
            oprot.writeFieldEnd()
        if self.lastSeenSeqId is not None:
            oprot.writeFieldBegin('lastSeenSeqId', TType.I64, 2)
            oprot.writeI64(self.lastSeenSeqId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.direction))
        value = (value * 31) ^ hash(make_hashable(self.lastSeenSeqId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getFriendRequests_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem715) = iprot.readListBegin()
                    for _ in range(elem715):
                        elem716 = FriendRequest()
                        elem716.read(iprot)
                        self.success.append(elem716)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getFriendRequests_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem717 in self.success:
                elem717.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class removeFriendRequest_args(object):
    """
    Attributes:
     - direction
     - midOrEMid
    """
    def __init__(self, direction=None, midOrEMid=None):
        self.direction = direction
        self.midOrEMid = midOrEMid

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.direction = FriendRequestDirection(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.midOrEMid = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('removeFriendRequest_args')
        if self.direction is not None:
            oprot.writeFieldBegin('direction', TType.I32, 1)
            oprot.writeI32(self.direction)
            oprot.writeFieldEnd()
        if self.midOrEMid is not None:
            oprot.writeFieldBegin('midOrEMid', TType.STRING, 2)
            oprot.writeString(self.midOrEMid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.direction))
        value = (value * 31) ^ hash(make_hashable(self.midOrEMid))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class removeFriendRequest_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('removeFriendRequest_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class findAndAddContactsByUserid_args(object):
    """
    Attributes:
     - reqSeq
     - userid
    """
    def __init__(self, reqSeq=None, userid=None):
        self.reqSeq = reqSeq
        self.userid = userid

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.userid = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('findAndAddContactsByUserid_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.userid is not None:
            oprot.writeFieldBegin('userid', TType.STRING, 2)
            oprot.writeString(self.userid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.userid))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class findAndAddContactsByUserid_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_, _, elem718) = iprot.readMapBegin()
                    for _ in range(elem718):
                        elem720 = iprot.readString()
                        elem719 = Contact()
                        elem719.read(iprot)
                        self.success[elem720] = elem719
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('findAndAddContactsByUserid_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for elem722, elem721 in self.success.items():
                oprot.writeString(elem722)
                elem721.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class findContactByUserid_args(object):
    """
    Attributes:
     - userid
    """
    def __init__(self, userid=None):
        self.userid = userid

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.userid = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('findContactByUserid_args')
        if self.userid is not None:
            oprot.writeFieldBegin('userid', TType.STRING, 2)
            oprot.writeString(self.userid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.userid))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class findContactByUserid_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Contact()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('findContactByUserid_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class findContactByUserTicket_args(object):
    """
    Attributes:
     - ticketIdWithTag
    """
    def __init__(self, ticketIdWithTag=None):
        self.ticketIdWithTag = ticketIdWithTag

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.ticketIdWithTag = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('findContactByUserTicket_args')
        if self.ticketIdWithTag is not None:
            oprot.writeFieldBegin('ticketIdWithTag', TType.STRING, 2)
            oprot.writeString(self.ticketIdWithTag)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.ticketIdWithTag))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class findContactByUserTicket_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Contact()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('findContactByUserTicket_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class findContactsByEmail_args(object):
    """
    Attributes:
     - emails
    """
    def __init__(self, emails=None):
        self.emails = emails

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.SET:
                    self.emails = set()
                    (_, elem723) = iprot.readSetBegin()
                    for _ in range(elem723):
                        elem724 = iprot.readString()
                        self.emails.add(elem724)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('findContactsByEmail_args')
        if self.emails is not None:
            oprot.writeFieldBegin('emails', TType.SET, 2)
            oprot.writeSetBegin(TType.STRING, len(self.emails))
            for elem725 in self.emails:
                oprot.writeString(elem725)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.emails))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class findContactsByEmail_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_, _, elem726) = iprot.readMapBegin()
                    for _ in range(elem726):
                        elem728 = iprot.readString()
                        elem727 = Contact()
                        elem727.read(iprot)
                        self.success[elem728] = elem727
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('findContactsByEmail_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for elem730, elem729 in self.success.items():
                oprot.writeString(elem730)
                elem729.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class findContactsByPhone_args(object):
    """
    Attributes:
     - phones
    """
    def __init__(self, phones=None):
        self.phones = phones

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.SET:
                    self.phones = set()
                    (_, elem731) = iprot.readSetBegin()
                    for _ in range(elem731):
                        elem732 = iprot.readString()
                        self.phones.add(elem732)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('findContactsByPhone_args')
        if self.phones is not None:
            oprot.writeFieldBegin('phones', TType.SET, 2)
            oprot.writeSetBegin(TType.STRING, len(self.phones))
            for elem733 in self.phones:
                oprot.writeString(elem733)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.phones))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class findContactsByPhone_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_, _, elem734) = iprot.readMapBegin()
                    for _ in range(elem734):
                        elem736 = iprot.readString()
                        elem735 = Contact()
                        elem735.read(iprot)
                        self.success[elem736] = elem735
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('findContactsByPhone_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for elem738, elem737 in self.success.items():
                oprot.writeString(elem738)
                elem737.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class findSnsIdUserStatus_args(object):
    """
    Attributes:
     - snsIdType
     - snsAccessToken
     - udidHash
    """
    def __init__(self, snsIdType=None, snsAccessToken=None, udidHash=None):
        self.snsIdType = snsIdType
        self.snsAccessToken = snsAccessToken
        self.udidHash = udidHash

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I32:
                    self.snsIdType = SnsIdType(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.snsAccessToken = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.udidHash = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('findSnsIdUserStatus_args')
        if self.snsIdType is not None:
            oprot.writeFieldBegin('snsIdType', TType.I32, 2)
            oprot.writeI32(self.snsIdType)
            oprot.writeFieldEnd()
        if self.snsAccessToken is not None:
            oprot.writeFieldBegin('snsAccessToken', TType.STRING, 3)
            oprot.writeString(self.snsAccessToken)
            oprot.writeFieldEnd()
        if self.udidHash is not None:
            oprot.writeFieldBegin('udidHash', TType.STRING, 4)
            oprot.writeString(self.udidHash)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.snsIdType))
        value = (value * 31) ^ hash(make_hashable(self.snsAccessToken))
        value = (value * 31) ^ hash(make_hashable(self.udidHash))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class findSnsIdUserStatus_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = SnsIdUserStatus()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('findSnsIdUserStatus_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class finishUpdateVerification_args(object):
    """
    Attributes:
     - sessionId
    """
    def __init__(self, sessionId=None):
        self.sessionId = sessionId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('finishUpdateVerification_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 2)
            oprot.writeString(self.sessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.sessionId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class finishUpdateVerification_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('finishUpdateVerification_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class generateUserTicket_args(object):
    """
    Attributes:
     - expirationTime
     - maxUseCount
    """
    def __init__(self, expirationTime=None, maxUseCount=None):
        self.expirationTime = expirationTime
        self.maxUseCount = maxUseCount

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 3:
                if ftype == TType.I64:
                    self.expirationTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.maxUseCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('generateUserTicket_args')
        if self.expirationTime is not None:
            oprot.writeFieldBegin('expirationTime', TType.I64, 3)
            oprot.writeI64(self.expirationTime)
            oprot.writeFieldEnd()
        if self.maxUseCount is not None:
            oprot.writeFieldBegin('maxUseCount', TType.I32, 4)
            oprot.writeI32(self.maxUseCount)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.expirationTime))
        value = (value * 31) ^ hash(make_hashable(self.maxUseCount))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class generateUserTicket_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Ticket()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('generateUserTicket_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class destroyMessage_args(object):
    """
    Attributes:
     - seq
     - chatId
     - messageId
     - sessionId
    """
    def __init__(self, seq=None, chatId=None, messageId=None, sessionId=None):
        self.seq = seq
        self.chatId = chatId
        self.messageId = messageId
        self.sessionId = sessionId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.seq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.chatId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.messageId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('destroyMessage_args')
        if self.seq is not None:
            oprot.writeFieldBegin('seq', TType.I32, 1)
            oprot.writeI32(self.seq)
            oprot.writeFieldEnd()
        if self.chatId is not None:
            oprot.writeFieldBegin('chatId', TType.STRING, 2)
            oprot.writeString(self.chatId)
            oprot.writeFieldEnd()
        if self.messageId is not None:
            oprot.writeFieldBegin('messageId', TType.STRING, 3)
            oprot.writeString(self.messageId)
            oprot.writeFieldEnd()
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 4)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.seq))
        value = (value * 31) ^ hash(make_hashable(self.chatId))
        value = (value * 31) ^ hash(make_hashable(self.messageId))
        value = (value * 31) ^ hash(make_hashable(self.sessionId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class destroyMessage_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('destroyMessage_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getAcceptedProximityMatches_args(object):
    """
    Attributes:
     - sessionId
    """
    def __init__(self, sessionId=None):
        self.sessionId = sessionId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getAcceptedProximityMatches_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 2)
            oprot.writeString(self.sessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.sessionId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getAcceptedProximityMatches_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = set()
                    (_, elem739) = iprot.readSetBegin()
                    for _ in range(elem739):
                        elem740 = iprot.readString()
                        self.success.add(elem740)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getAcceptedProximityMatches_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.STRING, len(self.success))
            for elem741 in self.success:
                oprot.writeString(elem741)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getActiveBuddySubscriberIds_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getActiveBuddySubscriberIds_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getActiveBuddySubscriberIds_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem742) = iprot.readListBegin()
                    for _ in range(elem742):
                        elem743 = iprot.readString()
                        self.success.append(elem743)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getActiveBuddySubscriberIds_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for elem744 in self.success:
                oprot.writeString(elem744)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getAllContactIds_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getAllContactIds_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getAllContactIds_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem745) = iprot.readListBegin()
                    for _ in range(elem745):
                        elem746 = iprot.readString()
                        self.success.append(elem746)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getAllContactIds_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for elem747 in self.success:
                oprot.writeString(elem747)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getAuthQrcode_args(object):
    """
    Attributes:
     - keepLoggedIn
     - systemName
    """
    def __init__(self, keepLoggedIn=None, systemName=None):
        self.keepLoggedIn = keepLoggedIn
        self.systemName = systemName

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.BOOL:
                    self.keepLoggedIn = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.systemName = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getAuthQrcode_args')
        if self.keepLoggedIn is not None:
            oprot.writeFieldBegin('keepLoggedIn', TType.BOOL, 2)
            oprot.writeBool(self.keepLoggedIn)
            oprot.writeFieldEnd()
        if self.systemName is not None:
            oprot.writeFieldBegin('systemName', TType.STRING, 3)
            oprot.writeString(self.systemName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.keepLoggedIn))
        value = (value * 31) ^ hash(make_hashable(self.systemName))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getAuthQrcode_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = AuthQrcode()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getAuthQrcode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getBlockedContactIds_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getBlockedContactIds_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getBlockedContactIds_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem748) = iprot.readListBegin()
                    for _ in range(elem748):
                        elem749 = iprot.readString()
                        self.success.append(elem749)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getBlockedContactIds_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for elem750 in self.success:
                oprot.writeString(elem750)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerWithPhoneNumber_args(object):
    """
    Attributes:
     - sessionId
     - migrationPincodeSessionId
    """
    def __init__(self, sessionId=None, migrationPincodeSessionId=None):
        self.sessionId = sessionId
        self.migrationPincodeSessionId = migrationPincodeSessionId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.migrationPincodeSessionId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerWithPhoneNumber_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 2)
            oprot.writeString(self.sessionId)
            oprot.writeFieldEnd()
        if self.migrationPincodeSessionId is not None:
            oprot.writeFieldBegin('migrationPincodeSessionId', TType.STRING, 3)
            oprot.writeString(self.migrationPincodeSessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.sessionId))
        value = (value * 31) ^ hash(make_hashable(self.migrationPincodeSessionId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerWithPhoneNumber_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = RegisterWithPhoneNumberResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerWithPhoneNumber_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerWithPhoneNumberAndPassword_args(object):
    """
    Attributes:
     - sessionId
     - keynm
     - encrypted
    """
    def __init__(self, sessionId=None, keynm=None, encrypted=None):
        self.sessionId = sessionId
        self.keynm = keynm
        self.encrypted = encrypted

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.keynm = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.encrypted = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerWithPhoneNumberAndPassword_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 2)
            oprot.writeString(self.sessionId)
            oprot.writeFieldEnd()
        if self.keynm is not None:
            oprot.writeFieldBegin('keynm', TType.STRING, 3)
            oprot.writeString(self.keynm)
            oprot.writeFieldEnd()
        if self.encrypted is not None:
            oprot.writeFieldBegin('encrypted', TType.STRING, 4)
            oprot.writeString(self.encrypted)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.sessionId))
        value = (value * 31) ^ hash(make_hashable(self.keynm))
        value = (value * 31) ^ hash(make_hashable(self.encrypted))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerWithPhoneNumberAndPassword_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = RegisterWithPhoneNumberResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerWithPhoneNumberAndPassword_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getAnalyticsInfo_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getAnalyticsInfo_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getAnalyticsInfo_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = AnalyticsInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getAnalyticsInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class reportClientStatistics_args(object):
    """
    Attributes:
     - reqSeq
     - category
     - count
    """
    def __init__(self, reqSeq=None, category=None, count=None):
        self.reqSeq = reqSeq
        self.category = category
        self.count = count

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.category = ReportCategory(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('reportClientStatistics_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.category is not None:
            oprot.writeFieldBegin('category', TType.I32, 2)
            oprot.writeI32(self.category)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 3)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.category))
        value = (value * 31) ^ hash(make_hashable(self.count))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class reportClientStatistics_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('reportClientStatistics_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class verifyPhoneNumberForLogin_args(object):
    """
    Attributes:
     - verifierFromPhone
     - pinCodeForPhone
     - verifierFromLogin
    """
    def __init__(self, verifierFromPhone=None, pinCodeForPhone=None, verifierFromLogin=None):
        self.verifierFromPhone = verifierFromPhone
        self.pinCodeForPhone = pinCodeForPhone
        self.verifierFromLogin = verifierFromLogin

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.verifierFromPhone = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.pinCodeForPhone = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.verifierFromLogin = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('verifyPhoneNumberForLogin_args')
        if self.verifierFromPhone is not None:
            oprot.writeFieldBegin('verifierFromPhone', TType.STRING, 2)
            oprot.writeString(self.verifierFromPhone)
            oprot.writeFieldEnd()
        if self.pinCodeForPhone is not None:
            oprot.writeFieldBegin('pinCodeForPhone', TType.STRING, 3)
            oprot.writeString(self.pinCodeForPhone)
            oprot.writeFieldEnd()
        if self.verifierFromLogin is not None:
            oprot.writeFieldBegin('verifierFromLogin', TType.STRING, 4)
            oprot.writeString(self.verifierFromLogin)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.verifierFromPhone))
        value = (value * 31) ^ hash(make_hashable(self.pinCodeForPhone))
        value = (value * 31) ^ hash(make_hashable(self.verifierFromLogin))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class verifyPhoneNumberForLogin_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('verifyPhoneNumberForLogin_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class verifyPhoneNumber_args(object):
    """
    Attributes:
     - sessionId
     - pinCode
     - udidHash
     - migrationPincodeSessionId
     - oldUdidHash
    """
    def __init__(self, sessionId=None, pinCode=None, udidHash=None, migrationPincodeSessionId=None, oldUdidHash=None):
        self.sessionId = sessionId
        self.pinCode = pinCode
        self.udidHash = udidHash
        self.migrationPincodeSessionId = migrationPincodeSessionId
        self.oldUdidHash = oldUdidHash

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.pinCode = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.udidHash = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.migrationPincodeSessionId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.oldUdidHash = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('verifyPhoneNumber_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 2)
            oprot.writeString(self.sessionId)
            oprot.writeFieldEnd()
        if self.pinCode is not None:
            oprot.writeFieldBegin('pinCode', TType.STRING, 3)
            oprot.writeString(self.pinCode)
            oprot.writeFieldEnd()
        if self.udidHash is not None:
            oprot.writeFieldBegin('udidHash', TType.STRING, 4)
            oprot.writeString(self.udidHash)
            oprot.writeFieldEnd()
        if self.migrationPincodeSessionId is not None:
            oprot.writeFieldBegin('migrationPincodeSessionId', TType.STRING, 5)
            oprot.writeString(self.migrationPincodeSessionId)
            oprot.writeFieldEnd()
        if self.oldUdidHash is not None:
            oprot.writeFieldBegin('oldUdidHash', TType.STRING, 6)
            oprot.writeString(self.oldUdidHash)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.sessionId))
        value = (value * 31) ^ hash(make_hashable(self.pinCode))
        value = (value * 31) ^ hash(make_hashable(self.udidHash))
        value = (value * 31) ^ hash(make_hashable(self.migrationPincodeSessionId))
        value = (value * 31) ^ hash(make_hashable(self.oldUdidHash))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class verifyPhoneNumber_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PhoneVerificationResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('verifyPhoneNumber_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getBlockedContactIdsByRange_args(object):
    """
    Attributes:
     - start
     - count
    """
    def __init__(self, start=None, count=None):
        self.start = start
        self.count = count

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getBlockedContactIdsByRange_args')
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 2)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 3)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.start))
        value = (value * 31) ^ hash(make_hashable(self.count))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getBlockedContactIdsByRange_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem751) = iprot.readListBegin()
                    for _ in range(elem751):
                        elem752 = iprot.readString()
                        self.success.append(elem752)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getBlockedContactIdsByRange_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for elem753 in self.success:
                oprot.writeString(elem753)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getBlockedRecommendationIds_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getBlockedRecommendationIds_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getBlockedRecommendationIds_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem754) = iprot.readListBegin()
                    for _ in range(elem754):
                        elem755 = iprot.readString()
                        self.success.append(elem755)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getBlockedRecommendationIds_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for elem756 in self.success:
                oprot.writeString(elem756)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getBuddyBlockerIds_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getBuddyBlockerIds_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getBuddyBlockerIds_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem757) = iprot.readListBegin()
                    for _ in range(elem757):
                        elem758 = iprot.readString()
                        self.success.append(elem758)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getBuddyBlockerIds_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for elem759 in self.success:
                oprot.writeString(elem759)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getBuddyLocation_args(object):
    """
    Attributes:
     - mid
     - index
    """
    def __init__(self, mid=None, index=None):
        self.mid = mid
        self.index = index

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.mid = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getBuddyLocation_args')
        if self.mid is not None:
            oprot.writeFieldBegin('mid', TType.STRING, 2)
            oprot.writeString(self.mid)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 3)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.mid))
        value = (value * 31) ^ hash(make_hashable(self.index))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getBuddyLocation_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Geolocation()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getBuddyLocation_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getCompactContactsModifiedSince_args(object):
    """
    Attributes:
     - timestamp
    """
    def __init__(self, timestamp=None):
        self.timestamp = timestamp

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getCompactContactsModifiedSince_args')
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 2)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.timestamp))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getCompactContactsModifiedSince_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem760) = iprot.readListBegin()
                    for _ in range(elem760):
                        elem761 = CompactContact()
                        elem761.read(iprot)
                        self.success.append(elem761)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getCompactContactsModifiedSince_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem762 in self.success:
                elem762.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getCompactGroup_args(object):
    """
    Attributes:
     - groupId
    """
    def __init__(self, groupId=None):
        self.groupId = groupId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.groupId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getCompactGroup_args')
        if self.groupId is not None:
            oprot.writeFieldBegin('groupId', TType.STRING, 2)
            oprot.writeString(self.groupId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.groupId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getCompactGroup_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Group()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getCompactGroup_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getCompactRoom_args(object):
    """
    Attributes:
     - roomId
    """
    def __init__(self, roomId=None):
        self.roomId = roomId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.roomId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getCompactRoom_args')
        if self.roomId is not None:
            oprot.writeFieldBegin('roomId', TType.STRING, 2)
            oprot.writeString(self.roomId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.roomId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getCompactRoom_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Room()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getCompactRoom_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getContact_args(object):
    """
    Attributes:
     - id
    """
    def __init__(self, id=None):
        self.id = id

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.id = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getContact_args')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 2)
            oprot.writeString(self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.id))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getContact_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Contact()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getContact_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getContacts_args(object):
    """
    Attributes:
     - ids
    """
    def __init__(self, ids=None):
        self.ids = ids

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.LIST:
                    self.ids = []
                    (_, elem763) = iprot.readListBegin()
                    for _ in range(elem763):
                        elem764 = iprot.readString()
                        self.ids.append(elem764)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getContacts_args')
        if self.ids is not None:
            oprot.writeFieldBegin('ids', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.ids))
            for elem765 in self.ids:
                oprot.writeString(elem765)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.ids))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getContacts_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem766) = iprot.readListBegin()
                    for _ in range(elem766):
                        elem767 = Contact()
                        elem767.read(iprot)
                        self.success.append(elem767)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getContacts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem768 in self.success:
                elem768.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getContactWithFriendRequestStatus_args(object):
    """
    Attributes:
     - id
    """
    def __init__(self, id=None):
        self.id = id

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.id = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getContactWithFriendRequestStatus_args')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 2)
            oprot.writeString(self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.id))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getContactWithFriendRequestStatus_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Contact()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getContactWithFriendRequestStatus_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getCountryWithRequestIp_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getCountryWithRequestIp_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getCountryWithRequestIp_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getCountryWithRequestIp_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getFavoriteMids_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getFavoriteMids_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getFavoriteMids_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem769) = iprot.readListBegin()
                    for _ in range(elem769):
                        elem770 = iprot.readString()
                        self.success.append(elem770)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getFavoriteMids_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for elem771 in self.success:
                oprot.writeString(elem771)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getGroup_args(object):
    """
    Attributes:
     - groupId
    """
    def __init__(self, groupId=None):
        self.groupId = groupId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.groupId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getGroup_args')
        if self.groupId is not None:
            oprot.writeFieldBegin('groupId', TType.STRING, 2)
            oprot.writeString(self.groupId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.groupId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getGroup_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Group()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getGroup_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getGroupIdsInvited_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getGroupIdsInvited_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getGroupIdsInvited_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem772) = iprot.readListBegin()
                    for _ in range(elem772):
                        elem773 = iprot.readString()
                        self.success.append(elem773)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getGroupIdsInvited_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for elem774 in self.success:
                oprot.writeString(elem774)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getGroupIdsJoined_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getGroupIdsJoined_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getGroupIdsJoined_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem775) = iprot.readListBegin()
                    for _ in range(elem775):
                        elem776 = iprot.readString()
                        self.success.append(elem776)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getGroupIdsJoined_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for elem777 in self.success:
                oprot.writeString(elem777)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getGroups_args(object):
    """
    Attributes:
     - groupIds
    """
    def __init__(self, groupIds=None):
        self.groupIds = groupIds

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.LIST:
                    self.groupIds = []
                    (_, elem778) = iprot.readListBegin()
                    for _ in range(elem778):
                        elem779 = iprot.readString()
                        self.groupIds.append(elem779)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getGroups_args')
        if self.groupIds is not None:
            oprot.writeFieldBegin('groupIds', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.groupIds))
            for elem780 in self.groupIds:
                oprot.writeString(elem780)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.groupIds))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getGroups_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem781) = iprot.readListBegin()
                    for _ in range(elem781):
                        elem782 = Group()
                        elem782.read(iprot)
                        self.success.append(elem782)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getGroups_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem783 in self.success:
                elem783.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getHiddenContactMids_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getHiddenContactMids_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getHiddenContactMids_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem784) = iprot.readListBegin()
                    for _ in range(elem784):
                        elem785 = iprot.readString()
                        self.success.append(elem785)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getHiddenContactMids_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for elem786 in self.success:
                oprot.writeString(elem786)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getIdentityIdentifier_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getIdentityIdentifier_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getIdentityIdentifier_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getIdentityIdentifier_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getLastAnnouncementIndex_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getLastAnnouncementIndex_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getLastAnnouncementIndex_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getLastAnnouncementIndex_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getLastOpRevision_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getLastOpRevision_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getLastOpRevision_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getLastOpRevision_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getSuggestRevisions_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getSuggestRevisions_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getSuggestRevisions_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = SuggestDictionaryRevisions()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getSuggestRevisions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getPreviousMessagesV2WithReadCount_args(object):
    """
    Attributes:
     - messageBoxId
     - endMessageId
     - messagesCount
    """
    def __init__(self, messageBoxId=None, endMessageId=None, messagesCount=None):
        self.messageBoxId = messageBoxId
        self.endMessageId = endMessageId
        self.messagesCount = messagesCount

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.messageBoxId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.endMessageId = MessageBoxV2MessageId()
                    self.endMessageId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.messagesCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getPreviousMessagesV2WithReadCount_args')
        if self.messageBoxId is not None:
            oprot.writeFieldBegin('messageBoxId', TType.STRING, 2)
            oprot.writeString(self.messageBoxId)
            oprot.writeFieldEnd()
        if self.endMessageId is not None:
            oprot.writeFieldBegin('endMessageId', TType.STRUCT, 3)
            self.endMessageId.write(oprot)
            oprot.writeFieldEnd()
        if self.messagesCount is not None:
            oprot.writeFieldBegin('messagesCount', TType.I32, 4)
            oprot.writeI32(self.messagesCount)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.messageBoxId))
        value = (value * 31) ^ hash(make_hashable(self.endMessageId))
        value = (value * 31) ^ hash(make_hashable(self.messagesCount))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getPreviousMessagesV2WithReadCount_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem787) = iprot.readListBegin()
                    for _ in range(elem787):
                        elem788 = Message()
                        elem788.read(iprot)
                        self.success.append(elem788)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getPreviousMessagesV2WithReadCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem789 in self.success:
                elem789.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getMessageBox_args(object):
    """
    Attributes:
     - channelId
     - messageBoxId
     - lastMessagesCount
    """
    def __init__(self, channelId=None, messageBoxId=None, lastMessagesCount=None):
        self.channelId = channelId
        self.messageBoxId = messageBoxId
        self.lastMessagesCount = lastMessagesCount

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.channelId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.messageBoxId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.lastMessagesCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getMessageBox_args')
        if self.channelId is not None:
            oprot.writeFieldBegin('channelId', TType.STRING, 2)
            oprot.writeString(self.channelId)
            oprot.writeFieldEnd()
        if self.messageBoxId is not None:
            oprot.writeFieldBegin('messageBoxId', TType.STRING, 3)
            oprot.writeString(self.messageBoxId)
            oprot.writeFieldEnd()
        if self.lastMessagesCount is not None:
            oprot.writeFieldBegin('lastMessagesCount', TType.I32, 4)
            oprot.writeI32(self.lastMessagesCount)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.channelId))
        value = (value * 31) ^ hash(make_hashable(self.messageBoxId))
        value = (value * 31) ^ hash(make_hashable(self.lastMessagesCount))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getMessageBox_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TMessageBox()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getMessageBox_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getMessageBoxCompactWrapUp_args(object):
    """
    Attributes:
     - mid
    """
    def __init__(self, mid=None):
        self.mid = mid

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.mid = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getMessageBoxCompactWrapUp_args')
        if self.mid is not None:
            oprot.writeFieldBegin('mid', TType.STRING, 2)
            oprot.writeString(self.mid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.mid))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getMessageBoxCompactWrapUp_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TMessageBoxWrapUp()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getMessageBoxCompactWrapUp_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getMessageBoxCompactWrapUpList_args(object):
    """
    Attributes:
     - start
     - messageBoxCount
    """
    def __init__(self, start=None, messageBoxCount=None):
        self.start = start
        self.messageBoxCount = messageBoxCount

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.messageBoxCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getMessageBoxCompactWrapUpList_args')
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 2)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.messageBoxCount is not None:
            oprot.writeFieldBegin('messageBoxCount', TType.I32, 3)
            oprot.writeI32(self.messageBoxCount)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.start))
        value = (value * 31) ^ hash(make_hashable(self.messageBoxCount))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getMessageBoxCompactWrapUpList_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TMessageBoxWrapUpResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getMessageBoxCompactWrapUpList_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getMessageBoxList_args(object):
    """
    Attributes:
     - channelId
     - lastMessagesCount
    """
    def __init__(self, channelId=None, lastMessagesCount=None):
        self.channelId = channelId
        self.lastMessagesCount = lastMessagesCount

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.channelId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.lastMessagesCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getMessageBoxList_args')
        if self.channelId is not None:
            oprot.writeFieldBegin('channelId', TType.STRING, 2)
            oprot.writeString(self.channelId)
            oprot.writeFieldEnd()
        if self.lastMessagesCount is not None:
            oprot.writeFieldBegin('lastMessagesCount', TType.I32, 3)
            oprot.writeI32(self.lastMessagesCount)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.channelId))
        value = (value * 31) ^ hash(make_hashable(self.lastMessagesCount))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getMessageBoxList_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem790) = iprot.readListBegin()
                    for _ in range(elem790):
                        elem791 = TMessageBox()
                        elem791.read(iprot)
                        self.success.append(elem791)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getMessageBoxList_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem792 in self.success:
                elem792.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getMessageBoxListByStatus_args(object):
    """
    Attributes:
     - channelId
     - lastMessagesCount
     - status
    """
    def __init__(self, channelId=None, lastMessagesCount=None, status=None):
        self.channelId = channelId
        self.lastMessagesCount = lastMessagesCount
        self.status = status

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.channelId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.lastMessagesCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.status = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getMessageBoxListByStatus_args')
        if self.channelId is not None:
            oprot.writeFieldBegin('channelId', TType.STRING, 2)
            oprot.writeString(self.channelId)
            oprot.writeFieldEnd()
        if self.lastMessagesCount is not None:
            oprot.writeFieldBegin('lastMessagesCount', TType.I32, 3)
            oprot.writeI32(self.lastMessagesCount)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.I32, 4)
            oprot.writeI32(self.status)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.channelId))
        value = (value * 31) ^ hash(make_hashable(self.lastMessagesCount))
        value = (value * 31) ^ hash(make_hashable(self.status))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getMessageBoxListByStatus_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem793) = iprot.readListBegin()
                    for _ in range(elem793):
                        elem794 = TMessageBox()
                        elem794.read(iprot)
                        self.success.append(elem794)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getMessageBoxListByStatus_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem795 in self.success:
                elem795.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getMessageBoxWrapUp_args(object):
    """
    Attributes:
     - mid
    """
    def __init__(self, mid=None):
        self.mid = mid

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.mid = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getMessageBoxWrapUp_args')
        if self.mid is not None:
            oprot.writeFieldBegin('mid', TType.STRING, 2)
            oprot.writeString(self.mid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.mid))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getMessageBoxWrapUp_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TMessageBoxWrapUp()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getMessageBoxWrapUp_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getMessageBoxWrapUpList_args(object):
    """
    Attributes:
     - start
     - messageBoxCount
    """
    def __init__(self, start=None, messageBoxCount=None):
        self.start = start
        self.messageBoxCount = messageBoxCount

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.messageBoxCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getMessageBoxWrapUpList_args')
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 2)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.messageBoxCount is not None:
            oprot.writeFieldBegin('messageBoxCount', TType.I32, 3)
            oprot.writeI32(self.messageBoxCount)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.start))
        value = (value * 31) ^ hash(make_hashable(self.messageBoxCount))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getMessageBoxWrapUpList_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TMessageBoxWrapUpResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getMessageBoxWrapUpList_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getMessagesBySequenceNumber_args(object):
    """
    Attributes:
     - channelId
     - messageBoxId
     - startSeq
     - endSeq
    """
    def __init__(self, channelId=None, messageBoxId=None, startSeq=None, endSeq=None):
        self.channelId = channelId
        self.messageBoxId = messageBoxId
        self.startSeq = startSeq
        self.endSeq = endSeq

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.channelId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.messageBoxId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.startSeq = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.endSeq = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getMessagesBySequenceNumber_args')
        if self.channelId is not None:
            oprot.writeFieldBegin('channelId', TType.STRING, 2)
            oprot.writeString(self.channelId)
            oprot.writeFieldEnd()
        if self.messageBoxId is not None:
            oprot.writeFieldBegin('messageBoxId', TType.STRING, 3)
            oprot.writeString(self.messageBoxId)
            oprot.writeFieldEnd()
        if self.startSeq is not None:
            oprot.writeFieldBegin('startSeq', TType.I64, 4)
            oprot.writeI64(self.startSeq)
            oprot.writeFieldEnd()
        if self.endSeq is not None:
            oprot.writeFieldBegin('endSeq', TType.I64, 5)
            oprot.writeI64(self.endSeq)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.channelId))
        value = (value * 31) ^ hash(make_hashable(self.messageBoxId))
        value = (value * 31) ^ hash(make_hashable(self.startSeq))
        value = (value * 31) ^ hash(make_hashable(self.endSeq))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getMessagesBySequenceNumber_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem796) = iprot.readListBegin()
                    for _ in range(elem796):
                        elem797 = Message()
                        elem797.read(iprot)
                        self.success.append(elem797)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getMessagesBySequenceNumber_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem798 in self.success:
                elem798.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getNextMessages_args(object):
    """
    Attributes:
     - messageBoxId
     - startSeq
     - messagesCount
    """
    def __init__(self, messageBoxId=None, startSeq=None, messagesCount=None):
        self.messageBoxId = messageBoxId
        self.startSeq = startSeq
        self.messagesCount = messagesCount

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.messageBoxId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.startSeq = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.messagesCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getNextMessages_args')
        if self.messageBoxId is not None:
            oprot.writeFieldBegin('messageBoxId', TType.STRING, 2)
            oprot.writeString(self.messageBoxId)
            oprot.writeFieldEnd()
        if self.startSeq is not None:
            oprot.writeFieldBegin('startSeq', TType.I64, 3)
            oprot.writeI64(self.startSeq)
            oprot.writeFieldEnd()
        if self.messagesCount is not None:
            oprot.writeFieldBegin('messagesCount', TType.I32, 4)
            oprot.writeI32(self.messagesCount)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.messageBoxId))
        value = (value * 31) ^ hash(make_hashable(self.startSeq))
        value = (value * 31) ^ hash(make_hashable(self.messagesCount))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getNextMessages_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem799) = iprot.readListBegin()
                    for _ in range(elem799):
                        elem800 = Message()
                        elem800.read(iprot)
                        self.success.append(elem800)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getNextMessages_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem801 in self.success:
                elem801.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getNotificationPolicy_args(object):
    """
    Attributes:
     - carrier
    """
    def __init__(self, carrier=None):
        self.carrier = carrier

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I32:
                    self.carrier = CarrierCode(iprot.readI32())
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getNotificationPolicy_args')
        if self.carrier is not None:
            oprot.writeFieldBegin('carrier', TType.I32, 2)
            oprot.writeI32(self.carrier)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.carrier))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getNotificationPolicy_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem802) = iprot.readListBegin()
                    for _ in range(elem802):
                        elem803 = NotificationType(iprot.readI32())
                        self.success.append(elem803)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getNotificationPolicy_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for elem804 in self.success:
                oprot.writeI32(elem804)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getPreviousMessages_args(object):
    """
    Attributes:
     - messageBoxId
     - endSeq
     - messagesCount
    """
    def __init__(self, messageBoxId=None, endSeq=None, messagesCount=None):
        self.messageBoxId = messageBoxId
        self.endSeq = endSeq
        self.messagesCount = messagesCount

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.messageBoxId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.endSeq = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.messagesCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getPreviousMessages_args')
        if self.messageBoxId is not None:
            oprot.writeFieldBegin('messageBoxId', TType.STRING, 2)
            oprot.writeString(self.messageBoxId)
            oprot.writeFieldEnd()
        if self.endSeq is not None:
            oprot.writeFieldBegin('endSeq', TType.I64, 3)
            oprot.writeI64(self.endSeq)
            oprot.writeFieldEnd()
        if self.messagesCount is not None:
            oprot.writeFieldBegin('messagesCount', TType.I32, 4)
            oprot.writeI32(self.messagesCount)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.messageBoxId))
        value = (value * 31) ^ hash(make_hashable(self.endSeq))
        value = (value * 31) ^ hash(make_hashable(self.messagesCount))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getPreviousMessages_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem805) = iprot.readListBegin()
                    for _ in range(elem805):
                        elem806 = Message()
                        elem806.read(iprot)
                        self.success.append(elem806)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getPreviousMessages_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem807 in self.success:
                elem807.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getProfile_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getProfile_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getProfile_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Profile()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getProfile_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getProximityMatchCandidateList_args(object):
    """
    Attributes:
     - sessionId
    """
    def __init__(self, sessionId=None):
        self.sessionId = sessionId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getProximityMatchCandidateList_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 2)
            oprot.writeString(self.sessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.sessionId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getProximityMatchCandidateList_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ProximityMatchCandidateResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getProximityMatchCandidateList_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getProximityMatchCandidates_args(object):
    """
    Attributes:
     - sessionId
    """
    def __init__(self, sessionId=None):
        self.sessionId = sessionId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getProximityMatchCandidates_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 2)
            oprot.writeString(self.sessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.sessionId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getProximityMatchCandidates_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = set()
                    (_, elem808) = iprot.readSetBegin()
                    for _ in range(elem808):
                        elem809 = Contact()
                        elem809.read(iprot)
                        self.success.add(elem809)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getProximityMatchCandidates_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.STRUCT, len(self.success))
            for elem810 in self.success:
                elem810.write(oprot)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getRecentMessages_args(object):
    """
    Attributes:
     - messageBoxId
     - messagesCount
    """
    def __init__(self, messageBoxId=None, messagesCount=None):
        self.messageBoxId = messageBoxId
        self.messagesCount = messagesCount

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.messageBoxId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.messagesCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getRecentMessages_args')
        if self.messageBoxId is not None:
            oprot.writeFieldBegin('messageBoxId', TType.STRING, 2)
            oprot.writeString(self.messageBoxId)
            oprot.writeFieldEnd()
        if self.messagesCount is not None:
            oprot.writeFieldBegin('messagesCount', TType.I32, 3)
            oprot.writeI32(self.messagesCount)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.messageBoxId))
        value = (value * 31) ^ hash(make_hashable(self.messagesCount))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getRecentMessages_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem811) = iprot.readListBegin()
                    for _ in range(elem811):
                        elem812 = Message()
                        elem812.read(iprot)
                        self.success.append(elem812)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getRecentMessages_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem813 in self.success:
                elem813.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getRecommendationIds_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getRecommendationIds_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getRecommendationIds_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem814) = iprot.readListBegin()
                    for _ in range(elem814):
                        elem815 = iprot.readString()
                        self.success.append(elem815)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getRecommendationIds_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for elem816 in self.success:
                oprot.writeString(elem816)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getRoom_args(object):
    """
    Attributes:
     - roomId
    """
    def __init__(self, roomId=None):
        self.roomId = roomId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.roomId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getRoom_args')
        if self.roomId is not None:
            oprot.writeFieldBegin('roomId', TType.STRING, 2)
            oprot.writeString(self.roomId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.roomId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getRoom_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Room()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getRoom_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getRSAKeyInfo_args(object):
    """
    Attributes:
     - provider
    """
    def __init__(self, provider=None):
        self.provider = provider

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I32:
                    self.provider = IdentityProvider(iprot.readI32())
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getRSAKeyInfo_args')
        if self.provider is not None:
            oprot.writeFieldBegin('provider', TType.I32, 2)
            oprot.writeI32(self.provider)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.provider))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getRSAKeyInfo_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = RSAKey()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getRSAKeyInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getServerTime_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getServerTime_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getServerTime_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getServerTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getSessions_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getSessions_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getSessions_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem817) = iprot.readListBegin()
                    for _ in range(elem817):
                        elem818 = LoginSession()
                        elem818.read(iprot)
                        self.success.append(elem818)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getSessions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem819 in self.success:
                elem819.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getSettings_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getSettings_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getSettings_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Settings()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getSettings_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getGroupsV2_args(object):
    """
    Attributes:
     - groupIds
    """
    def __init__(self, groupIds=None):
        self.groupIds = groupIds

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.LIST:
                    self.groupIds = []
                    (_, elem820) = iprot.readListBegin()
                    for _ in range(elem820):
                        elem821 = iprot.readString()
                        self.groupIds.append(elem821)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getGroupsV2_args')
        if self.groupIds is not None:
            oprot.writeFieldBegin('groupIds', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.groupIds))
            for elem822 in self.groupIds:
                oprot.writeString(elem822)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.groupIds))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getGroupsV2_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem823) = iprot.readListBegin()
                    for _ in range(elem823):
                        elem824 = Group()
                        elem824.read(iprot)
                        self.success.append(elem824)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getGroupsV2_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem825 in self.success:
                elem825.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getSettingsAttributes_args(object):
    """
    Attributes:
     - attrBitset
    """
    def __init__(self, attrBitset=None):
        self.attrBitset = attrBitset

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I32:
                    self.attrBitset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getSettingsAttributes_args')
        if self.attrBitset is not None:
            oprot.writeFieldBegin('attrBitset', TType.I32, 2)
            oprot.writeI32(self.attrBitset)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.attrBitset))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getSettingsAttributes_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Settings()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getSettingsAttributes_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getSystemConfiguration_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getSystemConfiguration_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getSystemConfiguration_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = SystemConfiguration()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getSystemConfiguration_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getUserTicket_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getUserTicket_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getUserTicket_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Ticket()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getUserTicket_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getWapInvitation_args(object):
    """
    Attributes:
     - invitationHash
    """
    def __init__(self, invitationHash=None):
        self.invitationHash = invitationHash

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.invitationHash = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getWapInvitation_args')
        if self.invitationHash is not None:
            oprot.writeFieldBegin('invitationHash', TType.STRING, 2)
            oprot.writeString(self.invitationHash)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.invitationHash))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getWapInvitation_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = WapInvitation()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getWapInvitation_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class invalidateUserTicket_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('invalidateUserTicket_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class invalidateUserTicket_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('invalidateUserTicket_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class inviteFriendsBySms_args(object):
    """
    Attributes:
     - phoneNumberList
    """
    def __init__(self, phoneNumberList=None):
        self.phoneNumberList = phoneNumberList

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.LIST:
                    self.phoneNumberList = []
                    (_, elem826) = iprot.readListBegin()
                    for _ in range(elem826):
                        elem827 = iprot.readString()
                        self.phoneNumberList.append(elem827)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('inviteFriendsBySms_args')
        if self.phoneNumberList is not None:
            oprot.writeFieldBegin('phoneNumberList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.phoneNumberList))
            for elem828 in self.phoneNumberList:
                oprot.writeString(elem828)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.phoneNumberList))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class inviteFriendsBySms_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('inviteFriendsBySms_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class inviteIntoGroup_args(object):
    """
    Attributes:
     - reqSeq
     - groupId
     - contactIds
    """
    def __init__(self, reqSeq=None, groupId=None, contactIds=None):
        self.reqSeq = reqSeq
        self.groupId = groupId
        self.contactIds = contactIds

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.groupId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.contactIds = []
                    (_, elem829) = iprot.readListBegin()
                    for _ in range(elem829):
                        elem830 = iprot.readString()
                        self.contactIds.append(elem830)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('inviteIntoGroup_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.groupId is not None:
            oprot.writeFieldBegin('groupId', TType.STRING, 2)
            oprot.writeString(self.groupId)
            oprot.writeFieldEnd()
        if self.contactIds is not None:
            oprot.writeFieldBegin('contactIds', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.contactIds))
            for elem831 in self.contactIds:
                oprot.writeString(elem831)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.groupId))
        value = (value * 31) ^ hash(make_hashable(self.contactIds))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class inviteIntoGroup_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('inviteIntoGroup_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class inviteIntoRoom_args(object):
    """
    Attributes:
     - reqSeq
     - roomId
     - contactIds
    """
    def __init__(self, reqSeq=None, roomId=None, contactIds=None):
        self.reqSeq = reqSeq
        self.roomId = roomId
        self.contactIds = contactIds

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.roomId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.contactIds = []
                    (_, elem832) = iprot.readListBegin()
                    for _ in range(elem832):
                        elem833 = iprot.readString()
                        self.contactIds.append(elem833)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('inviteIntoRoom_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.roomId is not None:
            oprot.writeFieldBegin('roomId', TType.STRING, 2)
            oprot.writeString(self.roomId)
            oprot.writeFieldEnd()
        if self.contactIds is not None:
            oprot.writeFieldBegin('contactIds', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.contactIds))
            for elem834 in self.contactIds:
                oprot.writeString(elem834)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.roomId))
        value = (value * 31) ^ hash(make_hashable(self.contactIds))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class inviteIntoRoom_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('inviteIntoRoom_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class inviteViaEmail_args(object):
    """
    Attributes:
     - reqSeq
     - email
     - name
    """
    def __init__(self, reqSeq=None, email=None, name=None):
        self.reqSeq = reqSeq
        self.email = email
        self.name = name

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.email = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('inviteViaEmail_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.email is not None:
            oprot.writeFieldBegin('email', TType.STRING, 2)
            oprot.writeString(self.email)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 3)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.email))
        value = (value * 31) ^ hash(make_hashable(self.name))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class inviteViaEmail_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('inviteViaEmail_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class isIdentityIdentifierAvailable_args(object):
    """
    Attributes:
     - provider
     - identifier
    """
    def __init__(self, provider=None, identifier=None):
        self.provider = provider
        self.identifier = identifier

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 3:
                if ftype == TType.I32:
                    self.provider = IdentityProvider(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.identifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('isIdentityIdentifierAvailable_args')
        if self.provider is not None:
            oprot.writeFieldBegin('provider', TType.I32, 3)
            oprot.writeI32(self.provider)
            oprot.writeFieldEnd()
        if self.identifier is not None:
            oprot.writeFieldBegin('identifier', TType.STRING, 2)
            oprot.writeString(self.identifier)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.provider))
        value = (value * 31) ^ hash(make_hashable(self.identifier))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class isIdentityIdentifierAvailable_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('isIdentityIdentifierAvailable_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class isUseridAvailable_args(object):
    """
    Attributes:
     - userid
    """
    def __init__(self, userid=None):
        self.userid = userid

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.userid = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('isUseridAvailable_args')
        if self.userid is not None:
            oprot.writeFieldBegin('userid', TType.STRING, 2)
            oprot.writeString(self.userid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.userid))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class isUseridAvailable_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('isUseridAvailable_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class kickoutFromGroup_args(object):
    """
    Attributes:
     - reqSeq
     - groupId
     - contactIds
    """
    def __init__(self, reqSeq=None, groupId=None, contactIds=None):
        self.reqSeq = reqSeq
        self.groupId = groupId
        self.contactIds = contactIds

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.groupId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.contactIds = []
                    (_, elem835) = iprot.readListBegin()
                    for _ in range(elem835):
                        elem836 = iprot.readString()
                        self.contactIds.append(elem836)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('kickoutFromGroup_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.groupId is not None:
            oprot.writeFieldBegin('groupId', TType.STRING, 2)
            oprot.writeString(self.groupId)
            oprot.writeFieldEnd()
        if self.contactIds is not None:
            oprot.writeFieldBegin('contactIds', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.contactIds))
            for elem837 in self.contactIds:
                oprot.writeString(elem837)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.groupId))
        value = (value * 31) ^ hash(make_hashable(self.contactIds))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class kickoutFromGroup_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('kickoutFromGroup_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class reissueGroupTicket_args(object):
    """
    Attributes:
     - groupMid
    """
    def __init__(self, groupMid=None):
        self.groupMid = groupMid

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.groupMid = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('reissueGroupTicket_args')
        if self.groupMid is not None:
            oprot.writeFieldBegin('groupMid', TType.STRING, 1)
            oprot.writeString(self.groupMid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.groupMid))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class reissueGroupTicket_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('reissueGroupTicket_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class findGroupByTicket_args(object):
    """
    Attributes:
     - ticketId
    """
    def __init__(self, ticketId=None):
        self.ticketId = ticketId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ticketId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('findGroupByTicket_args')
        if self.ticketId is not None:
            oprot.writeFieldBegin('ticketId', TType.STRING, 1)
            oprot.writeString(self.ticketId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.ticketId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class findGroupByTicket_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Group()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('findGroupByTicket_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class leaveGroup_args(object):
    """
    Attributes:
     - reqSeq
     - groupId
    """
    def __init__(self, reqSeq=None, groupId=None):
        self.reqSeq = reqSeq
        self.groupId = groupId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.groupId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('leaveGroup_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.groupId is not None:
            oprot.writeFieldBegin('groupId', TType.STRING, 2)
            oprot.writeString(self.groupId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.groupId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class leaveGroup_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('leaveGroup_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class leaveRoom_args(object):
    """
    Attributes:
     - reqSeq
     - roomId
    """
    def __init__(self, reqSeq=None, roomId=None):
        self.reqSeq = reqSeq
        self.roomId = roomId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.roomId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('leaveRoom_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.roomId is not None:
            oprot.writeFieldBegin('roomId', TType.STRING, 2)
            oprot.writeString(self.roomId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.roomId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class leaveRoom_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('leaveRoom_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class loginWithIdentityCredential_args(object):
    """
    Attributes:
     - identityProvider
     - identifier
     - password
     - keepLoggedIn
     - accessLocation
     - systemName
     - certificate
    """
    def __init__(self, identityProvider=None, identifier=None, password=None, keepLoggedIn=None, accessLocation=None, systemName=None, certificate=None):
        self.identityProvider = identityProvider
        self.identifier = identifier
        self.password = password
        self.keepLoggedIn = keepLoggedIn
        self.accessLocation = accessLocation
        self.systemName = systemName
        self.certificate = certificate

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 8:
                if ftype == TType.I32:
                    self.identityProvider = IdentityProvider(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.identifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.password = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.keepLoggedIn = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.accessLocation = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.systemName = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.certificate = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('loginWithIdentityCredential_args')
        if self.identityProvider is not None:
            oprot.writeFieldBegin('identityProvider', TType.I32, 8)
            oprot.writeI32(self.identityProvider)
            oprot.writeFieldEnd()
        if self.identifier is not None:
            oprot.writeFieldBegin('identifier', TType.STRING, 3)
            oprot.writeString(self.identifier)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 4)
            oprot.writeString(self.password)
            oprot.writeFieldEnd()
        if self.keepLoggedIn is not None:
            oprot.writeFieldBegin('keepLoggedIn', TType.BOOL, 5)
            oprot.writeBool(self.keepLoggedIn)
            oprot.writeFieldEnd()
        if self.accessLocation is not None:
            oprot.writeFieldBegin('accessLocation', TType.STRING, 6)
            oprot.writeString(self.accessLocation)
            oprot.writeFieldEnd()
        if self.systemName is not None:
            oprot.writeFieldBegin('systemName', TType.STRING, 7)
            oprot.writeString(self.systemName)
            oprot.writeFieldEnd()
        if self.certificate is not None:
            oprot.writeFieldBegin('certificate', TType.STRING, 9)
            oprot.writeString(self.certificate)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.identityProvider))
        value = (value * 31) ^ hash(make_hashable(self.identifier))
        value = (value * 31) ^ hash(make_hashable(self.password))
        value = (value * 31) ^ hash(make_hashable(self.keepLoggedIn))
        value = (value * 31) ^ hash(make_hashable(self.accessLocation))
        value = (value * 31) ^ hash(make_hashable(self.systemName))
        value = (value * 31) ^ hash(make_hashable(self.certificate))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class loginWithIdentityCredential_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('loginWithIdentityCredential_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class loginWithIdentityCredentialForCertificate_args(object):
    """
    Attributes:
     - identityProvider
     - identifier
     - password
     - keepLoggedIn
     - accessLocation
     - systemName
     - certificate
    """
    def __init__(self, identityProvider=None, identifier=None, password=None, keepLoggedIn=None, accessLocation=None, systemName=None, certificate=None):
        self.identityProvider = identityProvider
        self.identifier = identifier
        self.password = password
        self.keepLoggedIn = keepLoggedIn
        self.accessLocation = accessLocation
        self.systemName = systemName
        self.certificate = certificate

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 8:
                if ftype == TType.I32:
                    self.identityProvider = IdentityProvider(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.identifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.password = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.keepLoggedIn = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.accessLocation = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.systemName = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.certificate = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('loginWithIdentityCredentialForCertificate_args')
        if self.identityProvider is not None:
            oprot.writeFieldBegin('identityProvider', TType.I32, 8)
            oprot.writeI32(self.identityProvider)
            oprot.writeFieldEnd()
        if self.identifier is not None:
            oprot.writeFieldBegin('identifier', TType.STRING, 3)
            oprot.writeString(self.identifier)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 4)
            oprot.writeString(self.password)
            oprot.writeFieldEnd()
        if self.keepLoggedIn is not None:
            oprot.writeFieldBegin('keepLoggedIn', TType.BOOL, 5)
            oprot.writeBool(self.keepLoggedIn)
            oprot.writeFieldEnd()
        if self.accessLocation is not None:
            oprot.writeFieldBegin('accessLocation', TType.STRING, 6)
            oprot.writeString(self.accessLocation)
            oprot.writeFieldEnd()
        if self.systemName is not None:
            oprot.writeFieldBegin('systemName', TType.STRING, 7)
            oprot.writeString(self.systemName)
            oprot.writeFieldEnd()
        if self.certificate is not None:
            oprot.writeFieldBegin('certificate', TType.STRING, 9)
            oprot.writeString(self.certificate)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.identityProvider))
        value = (value * 31) ^ hash(make_hashable(self.identifier))
        value = (value * 31) ^ hash(make_hashable(self.password))
        value = (value * 31) ^ hash(make_hashable(self.keepLoggedIn))
        value = (value * 31) ^ hash(make_hashable(self.accessLocation))
        value = (value * 31) ^ hash(make_hashable(self.systemName))
        value = (value * 31) ^ hash(make_hashable(self.certificate))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class loginWithIdentityCredentialForCertificate_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = LoginResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('loginWithIdentityCredentialForCertificate_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class loginWithVerifier_args(object):
    """
    Attributes:
     - verifier
    """
    def __init__(self, verifier=None):
        self.verifier = verifier

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 3:
                if ftype == TType.STRING:
                    self.verifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('loginWithVerifier_args')
        if self.verifier is not None:
            oprot.writeFieldBegin('verifier', TType.STRING, 3)
            oprot.writeString(self.verifier)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.verifier))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class loginWithVerifier_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('loginWithVerifier_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class loginWithVerifierForCerificate_args(object):
    """
    Attributes:
     - verifier
    """
    def __init__(self, verifier=None):
        self.verifier = verifier

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 3:
                if ftype == TType.STRING:
                    self.verifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('loginWithVerifierForCerificate_args')
        if self.verifier is not None:
            oprot.writeFieldBegin('verifier', TType.STRING, 3)
            oprot.writeString(self.verifier)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.verifier))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class loginWithVerifierForCerificate_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = LoginResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('loginWithVerifierForCerificate_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class loginWithVerifierForCertificate_args(object):
    """
    Attributes:
     - verifier
    """
    def __init__(self, verifier=None):
        self.verifier = verifier

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 3:
                if ftype == TType.STRING:
                    self.verifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('loginWithVerifierForCertificate_args')
        if self.verifier is not None:
            oprot.writeFieldBegin('verifier', TType.STRING, 3)
            oprot.writeString(self.verifier)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.verifier))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class loginWithVerifierForCertificate_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = LoginResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('loginWithVerifierForCertificate_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class logout_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('logout_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class logout_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('logout_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class logoutSession_args(object):
    """
    Attributes:
     - tokenKey
    """
    def __init__(self, tokenKey=None):
        self.tokenKey = tokenKey

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.tokenKey = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('logoutSession_args')
        if self.tokenKey is not None:
            oprot.writeFieldBegin('tokenKey', TType.STRING, 2)
            oprot.writeString(self.tokenKey)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.tokenKey))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class logoutSession_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('logoutSession_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class noop_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('noop_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class noop_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('noop_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class notifiedRedirect_args(object):
    """
    Attributes:
     - paramMap
    """
    def __init__(self, paramMap=None):
        self.paramMap = paramMap

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.MAP:
                    self.paramMap = {}
                    (_, _, elem838) = iprot.readMapBegin()
                    for _ in range(elem838):
                        elem840 = iprot.readString()
                        elem839 = iprot.readString()
                        self.paramMap[elem840] = elem839
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('notifiedRedirect_args')
        if self.paramMap is not None:
            oprot.writeFieldBegin('paramMap', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.paramMap))
            for elem842, elem841 in self.paramMap.items():
                oprot.writeString(elem842)
                oprot.writeString(elem841)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.paramMap))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class notifiedRedirect_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('notifiedRedirect_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class notifyBuddyOnAir_args(object):
    """
    Attributes:
     - seq
     - receiverMids
    """
    def __init__(self, seq=None, receiverMids=None):
        self.seq = seq
        self.receiverMids = receiverMids

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.seq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.receiverMids = []
                    (_, elem843) = iprot.readListBegin()
                    for _ in range(elem843):
                        elem844 = iprot.readString()
                        self.receiverMids.append(elem844)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('notifyBuddyOnAir_args')
        if self.seq is not None:
            oprot.writeFieldBegin('seq', TType.I32, 1)
            oprot.writeI32(self.seq)
            oprot.writeFieldEnd()
        if self.receiverMids is not None:
            oprot.writeFieldBegin('receiverMids', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.receiverMids))
            for elem845 in self.receiverMids:
                oprot.writeString(elem845)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.seq))
        value = (value * 31) ^ hash(make_hashable(self.receiverMids))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class notifyBuddyOnAir_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_, _, elem846) = iprot.readMapBegin()
                    for _ in range(elem846):
                        elem848 = iprot.readString()
                        elem847 = iprot.readString()
                        self.success[elem848] = elem847
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('notifyBuddyOnAir_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for elem850, elem849 in self.success.items():
                oprot.writeString(elem850)
                oprot.writeString(elem849)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class notifyIndividualEvent_args(object):
    """
    Attributes:
     - notificationStatus
     - receiverMids
    """
    def __init__(self, notificationStatus=None, receiverMids=None):
        self.notificationStatus = notificationStatus
        self.receiverMids = receiverMids

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I32:
                    self.notificationStatus = NotificationStatus(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.receiverMids = []
                    (_, elem851) = iprot.readListBegin()
                    for _ in range(elem851):
                        elem852 = iprot.readString()
                        self.receiverMids.append(elem852)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('notifyIndividualEvent_args')
        if self.notificationStatus is not None:
            oprot.writeFieldBegin('notificationStatus', TType.I32, 2)
            oprot.writeI32(self.notificationStatus)
            oprot.writeFieldEnd()
        if self.receiverMids is not None:
            oprot.writeFieldBegin('receiverMids', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.receiverMids))
            for elem853 in self.receiverMids:
                oprot.writeString(elem853)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.notificationStatus))
        value = (value * 31) ^ hash(make_hashable(self.receiverMids))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class notifyIndividualEvent_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('notifyIndividualEvent_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class notifyInstalled_args(object):
    """
    Attributes:
     - udidHash
     - applicationTypeWithExtensions
    """
    def __init__(self, udidHash=None, applicationTypeWithExtensions=None):
        self.udidHash = udidHash
        self.applicationTypeWithExtensions = applicationTypeWithExtensions

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.udidHash = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.applicationTypeWithExtensions = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('notifyInstalled_args')
        if self.udidHash is not None:
            oprot.writeFieldBegin('udidHash', TType.STRING, 2)
            oprot.writeString(self.udidHash)
            oprot.writeFieldEnd()
        if self.applicationTypeWithExtensions is not None:
            oprot.writeFieldBegin('applicationTypeWithExtensions', TType.STRING, 3)
            oprot.writeString(self.applicationTypeWithExtensions)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.udidHash))
        value = (value * 31) ^ hash(make_hashable(self.applicationTypeWithExtensions))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class notifyInstalled_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('notifyInstalled_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class notifyRegistrationComplete_args(object):
    """
    Attributes:
     - udidHash
     - applicationTypeWithExtensions
    """
    def __init__(self, udidHash=None, applicationTypeWithExtensions=None):
        self.udidHash = udidHash
        self.applicationTypeWithExtensions = applicationTypeWithExtensions

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.udidHash = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.applicationTypeWithExtensions = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('notifyRegistrationComplete_args')
        if self.udidHash is not None:
            oprot.writeFieldBegin('udidHash', TType.STRING, 2)
            oprot.writeString(self.udidHash)
            oprot.writeFieldEnd()
        if self.applicationTypeWithExtensions is not None:
            oprot.writeFieldBegin('applicationTypeWithExtensions', TType.STRING, 3)
            oprot.writeString(self.applicationTypeWithExtensions)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.udidHash))
        value = (value * 31) ^ hash(make_hashable(self.applicationTypeWithExtensions))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class notifyRegistrationComplete_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('notifyRegistrationComplete_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class notifySleep_args(object):
    """
    Attributes:
     - lastRev
     - badge
    """
    def __init__(self, lastRev=None, badge=None):
        self.lastRev = lastRev
        self.badge = badge

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I64:
                    self.lastRev = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.badge = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('notifySleep_args')
        if self.lastRev is not None:
            oprot.writeFieldBegin('lastRev', TType.I64, 2)
            oprot.writeI64(self.lastRev)
            oprot.writeFieldEnd()
        if self.badge is not None:
            oprot.writeFieldBegin('badge', TType.I32, 3)
            oprot.writeI32(self.badge)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.lastRev))
        value = (value * 31) ^ hash(make_hashable(self.badge))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class notifySleep_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('notifySleep_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class notifyUpdated_args(object):
    """
    Attributes:
     - lastRev
     - deviceInfo
    """
    def __init__(self, lastRev=None, deviceInfo=None):
        self.lastRev = lastRev
        self.deviceInfo = deviceInfo

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I64:
                    self.lastRev = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.deviceInfo = DeviceInfo()
                    self.deviceInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('notifyUpdated_args')
        if self.lastRev is not None:
            oprot.writeFieldBegin('lastRev', TType.I64, 2)
            oprot.writeI64(self.lastRev)
            oprot.writeFieldEnd()
        if self.deviceInfo is not None:
            oprot.writeFieldBegin('deviceInfo', TType.STRUCT, 3)
            self.deviceInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.lastRev))
        value = (value * 31) ^ hash(make_hashable(self.deviceInfo))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class notifyUpdated_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('notifyUpdated_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class openProximityMatch_args(object):
    """
    Attributes:
     - location
    """
    def __init__(self, location=None):
        self.location = location

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.location = Location()
                    self.location.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('openProximityMatch_args')
        if self.location is not None:
            oprot.writeFieldBegin('location', TType.STRUCT, 2)
            self.location.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.location))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class openProximityMatch_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('openProximityMatch_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerBuddyUser_args(object):
    """
    Attributes:
     - buddyId
     - registrarPassword
    """
    def __init__(self, buddyId=None, registrarPassword=None):
        self.buddyId = buddyId
        self.registrarPassword = registrarPassword

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.buddyId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.registrarPassword = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerBuddyUser_args')
        if self.buddyId is not None:
            oprot.writeFieldBegin('buddyId', TType.STRING, 2)
            oprot.writeString(self.buddyId)
            oprot.writeFieldEnd()
        if self.registrarPassword is not None:
            oprot.writeFieldBegin('registrarPassword', TType.STRING, 3)
            oprot.writeString(self.registrarPassword)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.buddyId))
        value = (value * 31) ^ hash(make_hashable(self.registrarPassword))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerBuddyUser_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerBuddyUser_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerBuddyUserid_args(object):
    """
    Attributes:
     - seq
     - userid
    """
    def __init__(self, seq=None, userid=None):
        self.seq = seq
        self.userid = userid

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I32:
                    self.seq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.userid = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerBuddyUserid_args')
        if self.seq is not None:
            oprot.writeFieldBegin('seq', TType.I32, 2)
            oprot.writeI32(self.seq)
            oprot.writeFieldEnd()
        if self.userid is not None:
            oprot.writeFieldBegin('userid', TType.STRING, 3)
            oprot.writeString(self.userid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.seq))
        value = (value * 31) ^ hash(make_hashable(self.userid))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerBuddyUserid_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerBuddyUserid_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerDevice_args(object):
    """
    Attributes:
     - sessionId
    """
    def __init__(self, sessionId=None):
        self.sessionId = sessionId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerDevice_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 2)
            oprot.writeString(self.sessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.sessionId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerDevice_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerDevice_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerDeviceWithIdentityCredential_args(object):
    """
    Attributes:
     - sessionId
     - provider
     - identifier
     - verifier
    """
    def __init__(self, sessionId=None, provider=None, identifier=None, verifier=None):
        self.sessionId = sessionId
        self.provider = provider
        self.identifier = identifier
        self.verifier = verifier

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.provider = IdentityProvider(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.identifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.verifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerDeviceWithIdentityCredential_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 2)
            oprot.writeString(self.sessionId)
            oprot.writeFieldEnd()
        if self.provider is not None:
            oprot.writeFieldBegin('provider', TType.I32, 5)
            oprot.writeI32(self.provider)
            oprot.writeFieldEnd()
        if self.identifier is not None:
            oprot.writeFieldBegin('identifier', TType.STRING, 3)
            oprot.writeString(self.identifier)
            oprot.writeFieldEnd()
        if self.verifier is not None:
            oprot.writeFieldBegin('verifier', TType.STRING, 4)
            oprot.writeString(self.verifier)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.sessionId))
        value = (value * 31) ^ hash(make_hashable(self.provider))
        value = (value * 31) ^ hash(make_hashable(self.identifier))
        value = (value * 31) ^ hash(make_hashable(self.verifier))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerDeviceWithIdentityCredential_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerDeviceWithIdentityCredential_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerDeviceWithoutPhoneNumber_args(object):
    """
    Attributes:
     - region
     - udidHash
     - deviceInfo
    """
    def __init__(self, region=None, udidHash=None, deviceInfo=None):
        self.region = region
        self.udidHash = udidHash
        self.deviceInfo = deviceInfo

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.region = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.udidHash = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.deviceInfo = DeviceInfo()
                    self.deviceInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerDeviceWithoutPhoneNumber_args')
        if self.region is not None:
            oprot.writeFieldBegin('region', TType.STRING, 2)
            oprot.writeString(self.region)
            oprot.writeFieldEnd()
        if self.udidHash is not None:
            oprot.writeFieldBegin('udidHash', TType.STRING, 3)
            oprot.writeString(self.udidHash)
            oprot.writeFieldEnd()
        if self.deviceInfo is not None:
            oprot.writeFieldBegin('deviceInfo', TType.STRUCT, 4)
            self.deviceInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.region))
        value = (value * 31) ^ hash(make_hashable(self.udidHash))
        value = (value * 31) ^ hash(make_hashable(self.deviceInfo))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerDeviceWithoutPhoneNumber_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerDeviceWithoutPhoneNumber_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerDeviceWithoutPhoneNumberWithIdentityCredential_args(object):
    """
    Attributes:
     - region
     - udidHash
     - deviceInfo
     - provider
     - identifier
     - verifier
     - mid
     - migrationPincodeSessionId
    """
    def __init__(self, region=None, udidHash=None, deviceInfo=None, provider=None, identifier=None, verifier=None, mid=None, migrationPincodeSessionId=None):
        self.region = region
        self.udidHash = udidHash
        self.deviceInfo = deviceInfo
        self.provider = provider
        self.identifier = identifier
        self.verifier = verifier
        self.mid = mid
        self.migrationPincodeSessionId = migrationPincodeSessionId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.region = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.udidHash = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.deviceInfo = DeviceInfo()
                    self.deviceInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.provider = IdentityProvider(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.identifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.verifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.mid = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.migrationPincodeSessionId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerDeviceWithoutPhoneNumberWithIdentityCredential_args')
        if self.region is not None:
            oprot.writeFieldBegin('region', TType.STRING, 2)
            oprot.writeString(self.region)
            oprot.writeFieldEnd()
        if self.udidHash is not None:
            oprot.writeFieldBegin('udidHash', TType.STRING, 3)
            oprot.writeString(self.udidHash)
            oprot.writeFieldEnd()
        if self.deviceInfo is not None:
            oprot.writeFieldBegin('deviceInfo', TType.STRUCT, 4)
            self.deviceInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.provider is not None:
            oprot.writeFieldBegin('provider', TType.I32, 5)
            oprot.writeI32(self.provider)
            oprot.writeFieldEnd()
        if self.identifier is not None:
            oprot.writeFieldBegin('identifier', TType.STRING, 6)
            oprot.writeString(self.identifier)
            oprot.writeFieldEnd()
        if self.verifier is not None:
            oprot.writeFieldBegin('verifier', TType.STRING, 7)
            oprot.writeString(self.verifier)
            oprot.writeFieldEnd()
        if self.mid is not None:
            oprot.writeFieldBegin('mid', TType.STRING, 8)
            oprot.writeString(self.mid)
            oprot.writeFieldEnd()
        if self.migrationPincodeSessionId is not None:
            oprot.writeFieldBegin('migrationPincodeSessionId', TType.STRING, 9)
            oprot.writeString(self.migrationPincodeSessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.region))
        value = (value * 31) ^ hash(make_hashable(self.udidHash))
        value = (value * 31) ^ hash(make_hashable(self.deviceInfo))
        value = (value * 31) ^ hash(make_hashable(self.provider))
        value = (value * 31) ^ hash(make_hashable(self.identifier))
        value = (value * 31) ^ hash(make_hashable(self.verifier))
        value = (value * 31) ^ hash(make_hashable(self.mid))
        value = (value * 31) ^ hash(make_hashable(self.migrationPincodeSessionId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerDeviceWithoutPhoneNumberWithIdentityCredential_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerDeviceWithoutPhoneNumberWithIdentityCredential_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerUserid_args(object):
    """
    Attributes:
     - reqSeq
     - userid
    """
    def __init__(self, reqSeq=None, userid=None):
        self.reqSeq = reqSeq
        self.userid = userid

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.userid = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerUserid_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.userid is not None:
            oprot.writeFieldBegin('userid', TType.STRING, 2)
            oprot.writeString(self.userid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.userid))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerUserid_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerUserid_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerWapDevice_args(object):
    """
    Attributes:
     - invitationHash
     - guidHash
     - email
     - deviceInfo
    """
    def __init__(self, invitationHash=None, guidHash=None, email=None, deviceInfo=None):
        self.invitationHash = invitationHash
        self.guidHash = guidHash
        self.email = email
        self.deviceInfo = deviceInfo

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.invitationHash = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.guidHash = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.email = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.deviceInfo = DeviceInfo()
                    self.deviceInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerWapDevice_args')
        if self.invitationHash is not None:
            oprot.writeFieldBegin('invitationHash', TType.STRING, 2)
            oprot.writeString(self.invitationHash)
            oprot.writeFieldEnd()
        if self.guidHash is not None:
            oprot.writeFieldBegin('guidHash', TType.STRING, 3)
            oprot.writeString(self.guidHash)
            oprot.writeFieldEnd()
        if self.email is not None:
            oprot.writeFieldBegin('email', TType.STRING, 4)
            oprot.writeString(self.email)
            oprot.writeFieldEnd()
        if self.deviceInfo is not None:
            oprot.writeFieldBegin('deviceInfo', TType.STRUCT, 5)
            self.deviceInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.invitationHash))
        value = (value * 31) ^ hash(make_hashable(self.guidHash))
        value = (value * 31) ^ hash(make_hashable(self.email))
        value = (value * 31) ^ hash(make_hashable(self.deviceInfo))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerWapDevice_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerWapDevice_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerWithExistingSnsIdAndIdentityCredential_args(object):
    """
    Attributes:
     - identityCredential
     - region
     - udidHash
     - deviceInfo
    """
    def __init__(self, identityCredential=None, region=None, udidHash=None, deviceInfo=None):
        self.identityCredential = identityCredential
        self.region = region
        self.udidHash = udidHash
        self.deviceInfo = deviceInfo

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.identityCredential = IdentityCredential()
                    self.identityCredential.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.region = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.udidHash = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.deviceInfo = DeviceInfo()
                    self.deviceInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerWithExistingSnsIdAndIdentityCredential_args')
        if self.identityCredential is not None:
            oprot.writeFieldBegin('identityCredential', TType.STRUCT, 2)
            self.identityCredential.write(oprot)
            oprot.writeFieldEnd()
        if self.region is not None:
            oprot.writeFieldBegin('region', TType.STRING, 3)
            oprot.writeString(self.region)
            oprot.writeFieldEnd()
        if self.udidHash is not None:
            oprot.writeFieldBegin('udidHash', TType.STRING, 4)
            oprot.writeString(self.udidHash)
            oprot.writeFieldEnd()
        if self.deviceInfo is not None:
            oprot.writeFieldBegin('deviceInfo', TType.STRUCT, 5)
            self.deviceInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.identityCredential))
        value = (value * 31) ^ hash(make_hashable(self.region))
        value = (value * 31) ^ hash(make_hashable(self.udidHash))
        value = (value * 31) ^ hash(make_hashable(self.deviceInfo))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerWithExistingSnsIdAndIdentityCredential_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerWithExistingSnsIdAndIdentityCredential_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerWithSnsId_args(object):
    """
    Attributes:
     - snsIdType
     - snsAccessToken
     - region
     - udidHash
     - deviceInfo
     - mid
    """
    def __init__(self, snsIdType=None, snsAccessToken=None, region=None, udidHash=None, deviceInfo=None, mid=None):
        self.snsIdType = snsIdType
        self.snsAccessToken = snsAccessToken
        self.region = region
        self.udidHash = udidHash
        self.deviceInfo = deviceInfo
        self.mid = mid

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I32:
                    self.snsIdType = SnsIdType(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.snsAccessToken = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.region = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.udidHash = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.deviceInfo = DeviceInfo()
                    self.deviceInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.mid = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerWithSnsId_args')
        if self.snsIdType is not None:
            oprot.writeFieldBegin('snsIdType', TType.I32, 2)
            oprot.writeI32(self.snsIdType)
            oprot.writeFieldEnd()
        if self.snsAccessToken is not None:
            oprot.writeFieldBegin('snsAccessToken', TType.STRING, 3)
            oprot.writeString(self.snsAccessToken)
            oprot.writeFieldEnd()
        if self.region is not None:
            oprot.writeFieldBegin('region', TType.STRING, 4)
            oprot.writeString(self.region)
            oprot.writeFieldEnd()
        if self.udidHash is not None:
            oprot.writeFieldBegin('udidHash', TType.STRING, 5)
            oprot.writeString(self.udidHash)
            oprot.writeFieldEnd()
        if self.deviceInfo is not None:
            oprot.writeFieldBegin('deviceInfo', TType.STRUCT, 6)
            self.deviceInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.mid is not None:
            oprot.writeFieldBegin('mid', TType.STRING, 7)
            oprot.writeString(self.mid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.snsIdType))
        value = (value * 31) ^ hash(make_hashable(self.snsAccessToken))
        value = (value * 31) ^ hash(make_hashable(self.region))
        value = (value * 31) ^ hash(make_hashable(self.udidHash))
        value = (value * 31) ^ hash(make_hashable(self.deviceInfo))
        value = (value * 31) ^ hash(make_hashable(self.mid))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerWithSnsId_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = RegisterWithSnsIdResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerWithSnsId_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerWithSnsIdAndIdentityCredential_args(object):
    """
    Attributes:
     - snsIdType
     - snsAccessToken
     - identityCredential
     - region
     - udidHash
     - deviceInfo
    """
    def __init__(self, snsIdType=None, snsAccessToken=None, identityCredential=None, region=None, udidHash=None, deviceInfo=None):
        self.snsIdType = snsIdType
        self.snsAccessToken = snsAccessToken
        self.identityCredential = identityCredential
        self.region = region
        self.udidHash = udidHash
        self.deviceInfo = deviceInfo

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I32:
                    self.snsIdType = SnsIdType(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.snsAccessToken = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.identityCredential = IdentityCredential()
                    self.identityCredential.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.region = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.udidHash = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.deviceInfo = DeviceInfo()
                    self.deviceInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerWithSnsIdAndIdentityCredential_args')
        if self.snsIdType is not None:
            oprot.writeFieldBegin('snsIdType', TType.I32, 2)
            oprot.writeI32(self.snsIdType)
            oprot.writeFieldEnd()
        if self.snsAccessToken is not None:
            oprot.writeFieldBegin('snsAccessToken', TType.STRING, 3)
            oprot.writeString(self.snsAccessToken)
            oprot.writeFieldEnd()
        if self.identityCredential is not None:
            oprot.writeFieldBegin('identityCredential', TType.STRUCT, 4)
            self.identityCredential.write(oprot)
            oprot.writeFieldEnd()
        if self.region is not None:
            oprot.writeFieldBegin('region', TType.STRING, 5)
            oprot.writeString(self.region)
            oprot.writeFieldEnd()
        if self.udidHash is not None:
            oprot.writeFieldBegin('udidHash', TType.STRING, 6)
            oprot.writeString(self.udidHash)
            oprot.writeFieldEnd()
        if self.deviceInfo is not None:
            oprot.writeFieldBegin('deviceInfo', TType.STRUCT, 7)
            self.deviceInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.snsIdType))
        value = (value * 31) ^ hash(make_hashable(self.snsAccessToken))
        value = (value * 31) ^ hash(make_hashable(self.identityCredential))
        value = (value * 31) ^ hash(make_hashable(self.region))
        value = (value * 31) ^ hash(make_hashable(self.udidHash))
        value = (value * 31) ^ hash(make_hashable(self.deviceInfo))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerWithSnsIdAndIdentityCredential_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerWithSnsIdAndIdentityCredential_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class reissueDeviceCredential_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('reissueDeviceCredential_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class reissueDeviceCredential_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('reissueDeviceCredential_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class reissueUserTicket_args(object):
    """
    Attributes:
     - expirationTime
     - maxUseCount
    """
    def __init__(self, expirationTime=None, maxUseCount=None):
        self.expirationTime = expirationTime
        self.maxUseCount = maxUseCount

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 3:
                if ftype == TType.I64:
                    self.expirationTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.maxUseCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('reissueUserTicket_args')
        if self.expirationTime is not None:
            oprot.writeFieldBegin('expirationTime', TType.I64, 3)
            oprot.writeI64(self.expirationTime)
            oprot.writeFieldEnd()
        if self.maxUseCount is not None:
            oprot.writeFieldBegin('maxUseCount', TType.I32, 4)
            oprot.writeI32(self.maxUseCount)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.expirationTime))
        value = (value * 31) ^ hash(make_hashable(self.maxUseCount))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class reissueUserTicket_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('reissueUserTicket_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getMessageReadRange_args(object):
    """
    Attributes:
     - chatIds
    """
    def __init__(self, chatIds=None):
        self.chatIds = chatIds

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.LIST:
                    self.chatIds = []
                    (_, elem854) = iprot.readListBegin()
                    for _ in range(elem854):
                        elem855 = iprot.readString()
                        self.chatIds.append(elem855)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getMessageReadRange_args')
        if self.chatIds is not None:
            oprot.writeFieldBegin('chatIds', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.chatIds))
            for elem856 in self.chatIds:
                oprot.writeString(elem856)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.chatIds))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getMessageReadRange_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem857) = iprot.readListBegin()
                    for _ in range(elem857):
                        elem858 = TMessageReadRange()
                        elem858.read(iprot)
                        self.success.append(elem858)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getMessageReadRange_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem859 in self.success:
                elem859.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class rejectGroupInvitation_args(object):
    """
    Attributes:
     - reqSeq
     - groupId
    """
    def __init__(self, reqSeq=None, groupId=None):
        self.reqSeq = reqSeq
        self.groupId = groupId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.groupId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('rejectGroupInvitation_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.groupId is not None:
            oprot.writeFieldBegin('groupId', TType.STRING, 2)
            oprot.writeString(self.groupId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.groupId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class rejectGroupInvitation_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('rejectGroupInvitation_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class releaseSession_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('releaseSession_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class releaseSession_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('releaseSession_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class removeAllMessages_args(object):
    """
    Attributes:
     - seq
     - lastMessageId
    """
    def __init__(self, seq=None, lastMessageId=None):
        self.seq = seq
        self.lastMessageId = lastMessageId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.seq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.lastMessageId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('removeAllMessages_args')
        if self.seq is not None:
            oprot.writeFieldBegin('seq', TType.I32, 1)
            oprot.writeI32(self.seq)
            oprot.writeFieldEnd()
        if self.lastMessageId is not None:
            oprot.writeFieldBegin('lastMessageId', TType.STRING, 2)
            oprot.writeString(self.lastMessageId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.seq))
        value = (value * 31) ^ hash(make_hashable(self.lastMessageId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class removeAllMessages_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('removeAllMessages_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class removeBuddyLocation_args(object):
    """
    Attributes:
     - mid
     - index
    """
    def __init__(self, mid=None, index=None):
        self.mid = mid
        self.index = index

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.mid = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('removeBuddyLocation_args')
        if self.mid is not None:
            oprot.writeFieldBegin('mid', TType.STRING, 2)
            oprot.writeString(self.mid)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 3)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.mid))
        value = (value * 31) ^ hash(make_hashable(self.index))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class removeBuddyLocation_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('removeBuddyLocation_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class removeMessage_args(object):
    """
    Attributes:
     - messageId
    """
    def __init__(self, messageId=None):
        self.messageId = messageId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.messageId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('removeMessage_args')
        if self.messageId is not None:
            oprot.writeFieldBegin('messageId', TType.STRING, 2)
            oprot.writeString(self.messageId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.messageId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class removeMessage_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('removeMessage_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class makeUserAddMyselfAsContact_args(object):
    """
    Attributes:
     - contactOwnerMid
    """
    def __init__(self, contactOwnerMid=None):
        self.contactOwnerMid = contactOwnerMid

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.contactOwnerMid = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('makeUserAddMyselfAsContact_args')
        if self.contactOwnerMid is not None:
            oprot.writeFieldBegin('contactOwnerMid', TType.STRING, 1)
            oprot.writeString(self.contactOwnerMid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.contactOwnerMid))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class makeUserAddMyselfAsContact_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ContactTransition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('makeUserAddMyselfAsContact_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class removeMessageFromMyHome_args(object):
    """
    Attributes:
     - messageId
    """
    def __init__(self, messageId=None):
        self.messageId = messageId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.messageId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('removeMessageFromMyHome_args')
        if self.messageId is not None:
            oprot.writeFieldBegin('messageId', TType.STRING, 2)
            oprot.writeString(self.messageId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.messageId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class removeMessageFromMyHome_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('removeMessageFromMyHome_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class removeSnsId_args(object):
    """
    Attributes:
     - snsIdType
    """
    def __init__(self, snsIdType=None):
        self.snsIdType = snsIdType

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I32:
                    self.snsIdType = SnsIdType(iprot.readI32())
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('removeSnsId_args')
        if self.snsIdType is not None:
            oprot.writeFieldBegin('snsIdType', TType.I32, 2)
            oprot.writeI32(self.snsIdType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.snsIdType))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class removeSnsId_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('removeSnsId_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class report_args(object):
    """
    Attributes:
     - syncOpRevision
     - category
     - report
    """
    def __init__(self, syncOpRevision=None, category=None, report=None):
        self.syncOpRevision = syncOpRevision
        self.category = category
        self.report = report

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I64:
                    self.syncOpRevision = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.category = SyncCategory(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.report = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('report_args')
        if self.syncOpRevision is not None:
            oprot.writeFieldBegin('syncOpRevision', TType.I64, 2)
            oprot.writeI64(self.syncOpRevision)
            oprot.writeFieldEnd()
        if self.category is not None:
            oprot.writeFieldBegin('category', TType.I32, 3)
            oprot.writeI32(self.category)
            oprot.writeFieldEnd()
        if self.report is not None:
            oprot.writeFieldBegin('report', TType.STRING, 4)
            oprot.writeString(self.report)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.syncOpRevision))
        value = (value * 31) ^ hash(make_hashable(self.category))
        value = (value * 31) ^ hash(make_hashable(self.report))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class report_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('report_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class reportContacts_args(object):
    """
    Attributes:
     - syncOpRevision
     - category
     - contactReports
     - actionType
    """
    def __init__(self, syncOpRevision=None, category=None, contactReports=None, actionType=None):
        self.syncOpRevision = syncOpRevision
        self.category = category
        self.contactReports = contactReports
        self.actionType = actionType

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I64:
                    self.syncOpRevision = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.category = SyncCategory(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.contactReports = []
                    (_, elem860) = iprot.readListBegin()
                    for _ in range(elem860):
                        elem861 = ContactReport()
                        elem861.read(iprot)
                        self.contactReports.append(elem861)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.actionType = SyncActionType(iprot.readI32())
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('reportContacts_args')
        if self.syncOpRevision is not None:
            oprot.writeFieldBegin('syncOpRevision', TType.I64, 2)
            oprot.writeI64(self.syncOpRevision)
            oprot.writeFieldEnd()
        if self.category is not None:
            oprot.writeFieldBegin('category', TType.I32, 3)
            oprot.writeI32(self.category)
            oprot.writeFieldEnd()
        if self.contactReports is not None:
            oprot.writeFieldBegin('contactReports', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.contactReports))
            for elem862 in self.contactReports:
                elem862.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.actionType is not None:
            oprot.writeFieldBegin('actionType', TType.I32, 5)
            oprot.writeI32(self.actionType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.syncOpRevision))
        value = (value * 31) ^ hash(make_hashable(self.category))
        value = (value * 31) ^ hash(make_hashable(self.contactReports))
        value = (value * 31) ^ hash(make_hashable(self.actionType))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class reportContacts_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem863) = iprot.readListBegin()
                    for _ in range(elem863):
                        elem864 = ContactReportResult()
                        elem864.read(iprot)
                        self.success.append(elem864)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('reportContacts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem865 in self.success:
                elem865.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class reportGroups_args(object):
    """
    Attributes:
     - syncOpRevision
     - groups
    """
    def __init__(self, syncOpRevision=None, groups=None):
        self.syncOpRevision = syncOpRevision
        self.groups = groups

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I64:
                    self.syncOpRevision = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.groups = []
                    (_, elem866) = iprot.readListBegin()
                    for _ in range(elem866):
                        elem867 = Group()
                        elem867.read(iprot)
                        self.groups.append(elem867)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('reportGroups_args')
        if self.syncOpRevision is not None:
            oprot.writeFieldBegin('syncOpRevision', TType.I64, 2)
            oprot.writeI64(self.syncOpRevision)
            oprot.writeFieldEnd()
        if self.groups is not None:
            oprot.writeFieldBegin('groups', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.groups))
            for elem868 in self.groups:
                elem868.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.syncOpRevision))
        value = (value * 31) ^ hash(make_hashable(self.groups))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class reportGroups_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('reportGroups_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class reportProfile_args(object):
    """
    Attributes:
     - syncOpRevision
     - profile
    """
    def __init__(self, syncOpRevision=None, profile=None):
        self.syncOpRevision = syncOpRevision
        self.profile = profile

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I64:
                    self.syncOpRevision = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.profile = Profile()
                    self.profile.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('reportProfile_args')
        if self.syncOpRevision is not None:
            oprot.writeFieldBegin('syncOpRevision', TType.I64, 2)
            oprot.writeI64(self.syncOpRevision)
            oprot.writeFieldEnd()
        if self.profile is not None:
            oprot.writeFieldBegin('profile', TType.STRUCT, 3)
            self.profile.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.syncOpRevision))
        value = (value * 31) ^ hash(make_hashable(self.profile))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class reportProfile_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('reportProfile_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class reportRooms_args(object):
    """
    Attributes:
     - syncOpRevision
     - rooms
    """
    def __init__(self, syncOpRevision=None, rooms=None):
        self.syncOpRevision = syncOpRevision
        self.rooms = rooms

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I64:
                    self.syncOpRevision = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.rooms = []
                    (_, elem869) = iprot.readListBegin()
                    for _ in range(elem869):
                        elem870 = Room()
                        elem870.read(iprot)
                        self.rooms.append(elem870)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('reportRooms_args')
        if self.syncOpRevision is not None:
            oprot.writeFieldBegin('syncOpRevision', TType.I64, 2)
            oprot.writeI64(self.syncOpRevision)
            oprot.writeFieldEnd()
        if self.rooms is not None:
            oprot.writeFieldBegin('rooms', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.rooms))
            for elem871 in self.rooms:
                elem871.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.syncOpRevision))
        value = (value * 31) ^ hash(make_hashable(self.rooms))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class reportRooms_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('reportRooms_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class findAndAddContactByMetaTag_args(object):
    """
    Attributes:
     - reqSeq
     - userid
     - reference
    """
    def __init__(self, reqSeq=None, userid=None, reference=None):
        self.reqSeq = reqSeq
        self.userid = userid
        self.reference = reference

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.userid = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.reference = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('findAndAddContactByMetaTag_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.userid is not None:
            oprot.writeFieldBegin('userid', TType.STRING, 2)
            oprot.writeString(self.userid)
            oprot.writeFieldEnd()
        if self.reference is not None:
            oprot.writeFieldBegin('reference', TType.STRING, 3)
            oprot.writeString(self.reference)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.userid))
        value = (value * 31) ^ hash(make_hashable(self.reference))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class findAndAddContactByMetaTag_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Contact()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('findAndAddContactByMetaTag_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class reportSettings_args(object):
    """
    Attributes:
     - syncOpRevision
     - settings
    """
    def __init__(self, syncOpRevision=None, settings=None):
        self.syncOpRevision = syncOpRevision
        self.settings = settings

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I64:
                    self.syncOpRevision = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.settings = Settings()
                    self.settings.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('reportSettings_args')
        if self.syncOpRevision is not None:
            oprot.writeFieldBegin('syncOpRevision', TType.I64, 2)
            oprot.writeI64(self.syncOpRevision)
            oprot.writeFieldEnd()
        if self.settings is not None:
            oprot.writeFieldBegin('settings', TType.STRUCT, 3)
            self.settings.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.syncOpRevision))
        value = (value * 31) ^ hash(make_hashable(self.settings))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class reportSettings_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('reportSettings_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class reportSpam_args(object):
    """
    Attributes:
     - chatMid
     - memberMids
     - spammerReasons
     - senderMids
     - spamMessageIds
     - spamMessages
    """
    def __init__(self, chatMid=None, memberMids=None, spammerReasons=None, senderMids=None, spamMessageIds=None, spamMessages=None):
        self.chatMid = chatMid
        self.memberMids = memberMids
        self.spammerReasons = spammerReasons
        self.senderMids = senderMids
        self.spamMessageIds = spamMessageIds
        self.spamMessages = spamMessages

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.chatMid = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.memberMids = []
                    (_, elem872) = iprot.readListBegin()
                    for _ in range(elem872):
                        elem873 = iprot.readString()
                        self.memberMids.append(elem873)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.spammerReasons = []
                    (_, elem874) = iprot.readListBegin()
                    for _ in range(elem874):
                        elem875 = SpammerReason(iprot.readI32())
                        self.spammerReasons.append(elem875)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.senderMids = []
                    (_, elem876) = iprot.readListBegin()
                    for _ in range(elem876):
                        elem877 = iprot.readString()
                        self.senderMids.append(elem877)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.spamMessageIds = []
                    (_, elem878) = iprot.readListBegin()
                    for _ in range(elem878):
                        elem879 = iprot.readString()
                        self.spamMessageIds.append(elem879)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.spamMessages = []
                    (_, elem880) = iprot.readListBegin()
                    for _ in range(elem880):
                        elem881 = iprot.readString()
                        self.spamMessages.append(elem881)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('reportSpam_args')
        if self.chatMid is not None:
            oprot.writeFieldBegin('chatMid', TType.STRING, 2)
            oprot.writeString(self.chatMid)
            oprot.writeFieldEnd()
        if self.memberMids is not None:
            oprot.writeFieldBegin('memberMids', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.memberMids))
            for elem882 in self.memberMids:
                oprot.writeString(elem882)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.spammerReasons is not None:
            oprot.writeFieldBegin('spammerReasons', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.spammerReasons))
            for elem883 in self.spammerReasons:
                oprot.writeI32(elem883)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.senderMids is not None:
            oprot.writeFieldBegin('senderMids', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.senderMids))
            for elem884 in self.senderMids:
                oprot.writeString(elem884)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.spamMessageIds is not None:
            oprot.writeFieldBegin('spamMessageIds', TType.LIST, 6)
            oprot.writeListBegin(TType.STRING, len(self.spamMessageIds))
            for elem885 in self.spamMessageIds:
                oprot.writeString(elem885)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.spamMessages is not None:
            oprot.writeFieldBegin('spamMessages', TType.LIST, 7)
            oprot.writeListBegin(TType.STRING, len(self.spamMessages))
            for elem886 in self.spamMessages:
                oprot.writeString(elem886)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.chatMid))
        value = (value * 31) ^ hash(make_hashable(self.memberMids))
        value = (value * 31) ^ hash(make_hashable(self.spammerReasons))
        value = (value * 31) ^ hash(make_hashable(self.senderMids))
        value = (value * 31) ^ hash(make_hashable(self.spamMessageIds))
        value = (value * 31) ^ hash(make_hashable(self.spamMessages))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class reportSpam_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('reportSpam_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class reportSpammer_args(object):
    """
    Attributes:
     - spammerMid
     - spammerReasons
     - spamMessageIds
    """
    def __init__(self, spammerMid=None, spammerReasons=None, spamMessageIds=None):
        self.spammerMid = spammerMid
        self.spammerReasons = spammerReasons
        self.spamMessageIds = spamMessageIds

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.spammerMid = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.spammerReasons = []
                    (_, elem887) = iprot.readListBegin()
                    for _ in range(elem887):
                        elem888 = SpammerReason(iprot.readI32())
                        self.spammerReasons.append(elem888)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.spamMessageIds = []
                    (_, elem889) = iprot.readListBegin()
                    for _ in range(elem889):
                        elem890 = iprot.readString()
                        self.spamMessageIds.append(elem890)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('reportSpammer_args')
        if self.spammerMid is not None:
            oprot.writeFieldBegin('spammerMid', TType.STRING, 2)
            oprot.writeString(self.spammerMid)
            oprot.writeFieldEnd()
        if self.spammerReasons is not None:
            oprot.writeFieldBegin('spammerReasons', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.spammerReasons))
            for elem891 in self.spammerReasons:
                oprot.writeI32(elem891)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.spamMessageIds is not None:
            oprot.writeFieldBegin('spamMessageIds', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.spamMessageIds))
            for elem892 in self.spamMessageIds:
                oprot.writeString(elem892)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.spammerMid))
        value = (value * 31) ^ hash(make_hashable(self.spammerReasons))
        value = (value * 31) ^ hash(make_hashable(self.spamMessageIds))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class reportSpammer_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('reportSpammer_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class requestAccountPasswordReset_args(object):
    """
    Attributes:
     - provider
     - identifier
     - locale
    """
    def __init__(self, provider=None, identifier=None, locale=None):
        self.provider = provider
        self.identifier = identifier
        self.locale = locale

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 4:
                if ftype == TType.I32:
                    self.provider = IdentityProvider(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.identifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.locale = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('requestAccountPasswordReset_args')
        if self.provider is not None:
            oprot.writeFieldBegin('provider', TType.I32, 4)
            oprot.writeI32(self.provider)
            oprot.writeFieldEnd()
        if self.identifier is not None:
            oprot.writeFieldBegin('identifier', TType.STRING, 2)
            oprot.writeString(self.identifier)
            oprot.writeFieldEnd()
        if self.locale is not None:
            oprot.writeFieldBegin('locale', TType.STRING, 5)
            oprot.writeString(self.locale)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.provider))
        value = (value * 31) ^ hash(make_hashable(self.identifier))
        value = (value * 31) ^ hash(make_hashable(self.locale))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class requestAccountPasswordReset_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('requestAccountPasswordReset_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class requestEmailConfirmation_args(object):
    """
    Attributes:
     - emailConfirmation
    """
    def __init__(self, emailConfirmation=None):
        self.emailConfirmation = emailConfirmation

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.emailConfirmation = EmailConfirmation()
                    self.emailConfirmation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('requestEmailConfirmation_args')
        if self.emailConfirmation is not None:
            oprot.writeFieldBegin('emailConfirmation', TType.STRUCT, 2)
            self.emailConfirmation.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.emailConfirmation))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class requestEmailConfirmation_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = EmailConfirmationSession()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('requestEmailConfirmation_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class requestIdentityUnbind_args(object):
    """
    Attributes:
     - provider
     - identifier
    """
    def __init__(self, provider=None, identifier=None):
        self.provider = provider
        self.identifier = identifier

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 4:
                if ftype == TType.I32:
                    self.provider = IdentityProvider(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.identifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('requestIdentityUnbind_args')
        if self.provider is not None:
            oprot.writeFieldBegin('provider', TType.I32, 4)
            oprot.writeI32(self.provider)
            oprot.writeFieldEnd()
        if self.identifier is not None:
            oprot.writeFieldBegin('identifier', TType.STRING, 2)
            oprot.writeString(self.identifier)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.provider))
        value = (value * 31) ^ hash(make_hashable(self.identifier))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class requestIdentityUnbind_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('requestIdentityUnbind_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class resendEmailConfirmation_args(object):
    """
    Attributes:
     - verifier
    """
    def __init__(self, verifier=None):
        self.verifier = verifier

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.verifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('resendEmailConfirmation_args')
        if self.verifier is not None:
            oprot.writeFieldBegin('verifier', TType.STRING, 2)
            oprot.writeString(self.verifier)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.verifier))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class resendEmailConfirmation_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = EmailConfirmationSession()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('resendEmailConfirmation_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class resendPinCode_args(object):
    """
    Attributes:
     - sessionId
    """
    def __init__(self, sessionId=None):
        self.sessionId = sessionId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('resendPinCode_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 2)
            oprot.writeString(self.sessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.sessionId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class resendPinCode_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('resendPinCode_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class resendPinCodeBySMS_args(object):
    """
    Attributes:
     - sessionId
    """
    def __init__(self, sessionId=None):
        self.sessionId = sessionId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('resendPinCodeBySMS_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 2)
            oprot.writeString(self.sessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.sessionId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class resendPinCodeBySMS_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('resendPinCodeBySMS_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sendChatChecked_args(object):
    """
    Attributes:
     - seq
     - consumer
     - lastMessageId
    """
    def __init__(self, seq=None, consumer=None, lastMessageId=None):
        self.seq = seq
        self.consumer = consumer
        self.lastMessageId = lastMessageId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.seq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.consumer = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.lastMessageId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sendChatChecked_args')
        if self.seq is not None:
            oprot.writeFieldBegin('seq', TType.I32, 1)
            oprot.writeI32(self.seq)
            oprot.writeFieldEnd()
        if self.consumer is not None:
            oprot.writeFieldBegin('consumer', TType.STRING, 2)
            oprot.writeString(self.consumer)
            oprot.writeFieldEnd()
        if self.lastMessageId is not None:
            oprot.writeFieldBegin('lastMessageId', TType.STRING, 3)
            oprot.writeString(self.lastMessageId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.seq))
        value = (value * 31) ^ hash(make_hashable(self.consumer))
        value = (value * 31) ^ hash(make_hashable(self.lastMessageId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sendChatChecked_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sendChatChecked_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sendMessageAwaitCommit_args(object):
    """
    Attributes:
     - seq
     - message
    """
    def __init__(self, seq=None, message=None):
        self.seq = seq
        self.message = message

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.seq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.message = Message()
                    self.message.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sendMessageAwaitCommit_args')
        if self.seq is not None:
            oprot.writeFieldBegin('seq', TType.I32, 1)
            oprot.writeI32(self.seq)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRUCT, 2)
            self.message.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.seq))
        value = (value * 31) ^ hash(make_hashable(self.message))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sendMessageAwaitCommit_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CommitMessageResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sendMessageAwaitCommit_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sendChatRemoved_args(object):
    """
    Attributes:
     - seq
     - consumer
     - lastMessageId
    """
    def __init__(self, seq=None, consumer=None, lastMessageId=None):
        self.seq = seq
        self.consumer = consumer
        self.lastMessageId = lastMessageId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.seq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.consumer = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.lastMessageId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sendChatRemoved_args')
        if self.seq is not None:
            oprot.writeFieldBegin('seq', TType.I32, 1)
            oprot.writeI32(self.seq)
            oprot.writeFieldEnd()
        if self.consumer is not None:
            oprot.writeFieldBegin('consumer', TType.STRING, 2)
            oprot.writeString(self.consumer)
            oprot.writeFieldEnd()
        if self.lastMessageId is not None:
            oprot.writeFieldBegin('lastMessageId', TType.STRING, 3)
            oprot.writeString(self.lastMessageId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.seq))
        value = (value * 31) ^ hash(make_hashable(self.consumer))
        value = (value * 31) ^ hash(make_hashable(self.lastMessageId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sendChatRemoved_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sendChatRemoved_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sendContentPreviewUpdated_args(object):
    """
    Attributes:
     - esq
     - messageId
     - receiverMids
    """
    def __init__(self, esq=None, messageId=None, receiverMids=None):
        self.esq = esq
        self.messageId = messageId
        self.receiverMids = receiverMids

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.esq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.messageId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.receiverMids = []
                    (_, elem893) = iprot.readListBegin()
                    for _ in range(elem893):
                        elem894 = iprot.readString()
                        self.receiverMids.append(elem894)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sendContentPreviewUpdated_args')
        if self.esq is not None:
            oprot.writeFieldBegin('esq', TType.I32, 1)
            oprot.writeI32(self.esq)
            oprot.writeFieldEnd()
        if self.messageId is not None:
            oprot.writeFieldBegin('messageId', TType.STRING, 2)
            oprot.writeString(self.messageId)
            oprot.writeFieldEnd()
        if self.receiverMids is not None:
            oprot.writeFieldBegin('receiverMids', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.receiverMids))
            for elem895 in self.receiverMids:
                oprot.writeString(elem895)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.esq))
        value = (value * 31) ^ hash(make_hashable(self.messageId))
        value = (value * 31) ^ hash(make_hashable(self.receiverMids))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sendContentPreviewUpdated_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_, _, elem896) = iprot.readMapBegin()
                    for _ in range(elem896):
                        elem898 = iprot.readString()
                        elem897 = iprot.readString()
                        self.success[elem898] = elem897
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sendContentPreviewUpdated_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for elem900, elem899 in self.success.items():
                oprot.writeString(elem900)
                oprot.writeString(elem899)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sendContentReceipt_args(object):
    """
    Attributes:
     - seq
     - consumer
     - messageId
    """
    def __init__(self, seq=None, consumer=None, messageId=None):
        self.seq = seq
        self.consumer = consumer
        self.messageId = messageId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.seq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.consumer = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.messageId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sendContentReceipt_args')
        if self.seq is not None:
            oprot.writeFieldBegin('seq', TType.I32, 1)
            oprot.writeI32(self.seq)
            oprot.writeFieldEnd()
        if self.consumer is not None:
            oprot.writeFieldBegin('consumer', TType.STRING, 2)
            oprot.writeString(self.consumer)
            oprot.writeFieldEnd()
        if self.messageId is not None:
            oprot.writeFieldBegin('messageId', TType.STRING, 3)
            oprot.writeString(self.messageId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.seq))
        value = (value * 31) ^ hash(make_hashable(self.consumer))
        value = (value * 31) ^ hash(make_hashable(self.messageId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sendContentReceipt_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sendContentReceipt_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sendDummyPush_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sendDummyPush_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sendDummyPush_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sendDummyPush_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class removeE2EEPublicKey_args(object):
    """
    Attributes:
     - publicKey
    """
    def __init__(self, publicKey=None):
        self.publicKey = publicKey

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.publicKey = E2EEPublicKey()
                    self.publicKey.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('removeE2EEPublicKey_args')
        if self.publicKey is not None:
            oprot.writeFieldBegin('publicKey', TType.STRUCT, 2)
            self.publicKey.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.publicKey))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class removeE2EEPublicKey_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('removeE2EEPublicKey_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class negotiateE2EEPublicKey_args(object):
    """
    Attributes:
     - mid
    """
    def __init__(self, mid=None):
        self.mid = mid

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.mid = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('negotiateE2EEPublicKey_args')
        if self.mid is not None:
            oprot.writeFieldBegin('mid', TType.STRING, 2)
            oprot.writeString(self.mid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.mid))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class negotiateE2EEPublicKey_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = E2EENegotiationResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('negotiateE2EEPublicKey_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getE2EEPublicKey_args(object):
    """
    Attributes:
     - mid
     - version
     - keyId
    """
    def __init__(self, mid=None, version=None, keyId=None):
        self.mid = mid
        self.version = version
        self.keyId = keyId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.mid = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.keyId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getE2EEPublicKey_args')
        if self.mid is not None:
            oprot.writeFieldBegin('mid', TType.STRING, 2)
            oprot.writeString(self.mid)
            oprot.writeFieldEnd()
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.I32, 3)
            oprot.writeI32(self.version)
            oprot.writeFieldEnd()
        if self.keyId is not None:
            oprot.writeFieldBegin('keyId', TType.I32, 4)
            oprot.writeI32(self.keyId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.mid))
        value = (value * 31) ^ hash(make_hashable(self.version))
        value = (value * 31) ^ hash(make_hashable(self.keyId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getE2EEPublicKey_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = E2EEPublicKey()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getE2EEPublicKey_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class requestE2EEKeyExchange_args(object):
    """
    Attributes:
     - reqSeq
     - temporalPublicKey
     - publicKey
     - verifier
    """
    def __init__(self, reqSeq=None, temporalPublicKey=None, publicKey=None, verifier=None):
        self.reqSeq = reqSeq
        self.temporalPublicKey = temporalPublicKey
        self.publicKey = publicKey
        self.verifier = verifier

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.temporalPublicKey = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.publicKey = E2EEPublicKey()
                    self.publicKey.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.verifier = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('requestE2EEKeyExchange_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.temporalPublicKey is not None:
            oprot.writeFieldBegin('temporalPublicKey', TType.STRING, 2)
            oprot.writeBinary(self.temporalPublicKey)
            oprot.writeFieldEnd()
        if self.publicKey is not None:
            oprot.writeFieldBegin('publicKey', TType.STRUCT, 3)
            self.publicKey.write(oprot)
            oprot.writeFieldEnd()
        if self.verifier is not None:
            oprot.writeFieldBegin('verifier', TType.STRING, 4)
            oprot.writeBinary(self.verifier)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.temporalPublicKey))
        value = (value * 31) ^ hash(make_hashable(self.publicKey))
        value = (value * 31) ^ hash(make_hashable(self.verifier))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class requestE2EEKeyExchange_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('requestE2EEKeyExchange_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getLastE2EEPublicKeys_args(object):
    """
    Attributes:
     - chatMid
    """
    def __init__(self, chatMid=None):
        self.chatMid = chatMid

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.chatMid = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getLastE2EEPublicKeys_args')
        if self.chatMid is not None:
            oprot.writeFieldBegin('chatMid', TType.STRING, 2)
            oprot.writeString(self.chatMid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.chatMid))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getLastE2EEPublicKeys_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_, _, elem901) = iprot.readMapBegin()
                    for _ in range(elem901):
                        elem903 = iprot.readString()
                        elem902 = E2EEPublicKey()
                        elem902.read(iprot)
                        self.success[elem903] = elem902
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getLastE2EEPublicKeys_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for elem905, elem904 in self.success.items():
                oprot.writeString(elem905)
                elem904.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerE2EEPublicKey_args(object):
    """
    Attributes:
     - reqSeq
     - publicKey
    """
    def __init__(self, reqSeq=None, publicKey=None):
        self.reqSeq = reqSeq
        self.publicKey = publicKey

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.publicKey = E2EEPublicKey()
                    self.publicKey.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerE2EEPublicKey_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.publicKey is not None:
            oprot.writeFieldBegin('publicKey', TType.STRUCT, 2)
            self.publicKey.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.publicKey))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class registerE2EEPublicKey_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = E2EEPublicKey()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('registerE2EEPublicKey_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getE2EEPublicKeys_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getE2EEPublicKeys_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getE2EEPublicKeys_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem906) = iprot.readListBegin()
                    for _ in range(elem906):
                        elem907 = E2EEPublicKey()
                        elem907.read(iprot)
                        self.success.append(elem907)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getE2EEPublicKeys_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem908 in self.success:
                elem908.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getE2EEPublicKeysEx_args(object):
    """
    Attributes:
     - ignoreE2EEStatus
    """
    def __init__(self, ignoreE2EEStatus=None):
        self.ignoreE2EEStatus = ignoreE2EEStatus

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.BOOL:
                    self.ignoreE2EEStatus = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getE2EEPublicKeysEx_args')
        if self.ignoreE2EEStatus is not None:
            oprot.writeFieldBegin('ignoreE2EEStatus', TType.BOOL, 2)
            oprot.writeBool(self.ignoreE2EEStatus)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.ignoreE2EEStatus))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getE2EEPublicKeysEx_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem909) = iprot.readListBegin()
                    for _ in range(elem909):
                        elem910 = E2EEPublicKey()
                        elem910.read(iprot)
                        self.success.append(elem910)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getE2EEPublicKeysEx_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem911 in self.success:
                elem911.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getReadMessageOpsInBulk_args(object):
    """
    Attributes:
     - chatIds
    """
    def __init__(self, chatIds=None):
        self.chatIds = chatIds

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.LIST:
                    self.chatIds = []
                    (_, elem912) = iprot.readListBegin()
                    for _ in range(elem912):
                        elem913 = iprot.readString()
                        self.chatIds.append(elem913)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getReadMessageOpsInBulk_args')
        if self.chatIds is not None:
            oprot.writeFieldBegin('chatIds', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.chatIds))
            for elem914 in self.chatIds:
                oprot.writeString(elem914)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.chatIds))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getReadMessageOpsInBulk_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem915) = iprot.readListBegin()
                    for _ in range(elem915):
                        elem916 = Operation()
                        elem916.read(iprot)
                        self.success.append(elem916)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getReadMessageOpsInBulk_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem917 in self.success:
                elem917.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sendEvent_args(object):
    """
    Attributes:
     - seq
     - message
    """
    def __init__(self, seq=None, message=None):
        self.seq = seq
        self.message = message

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.seq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.message = Message()
                    self.message.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sendEvent_args')
        if self.seq is not None:
            oprot.writeFieldBegin('seq', TType.I32, 1)
            oprot.writeI32(self.seq)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRUCT, 2)
            self.message.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.seq))
        value = (value * 31) ^ hash(make_hashable(self.message))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sendEvent_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Message()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sendEvent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sendMessage_args(object):
    """
    Attributes:
     - seq
     - message
    """
    def __init__(self, seq=None, message=None):
        self.seq = seq
        self.message = message

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.seq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.message = Message()
                    self.message.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sendMessage_args')
        if self.seq is not None:
            oprot.writeFieldBegin('seq', TType.I32, 1)
            oprot.writeI32(self.seq)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRUCT, 2)
            self.message.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.seq))
        value = (value * 31) ^ hash(make_hashable(self.message))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sendMessage_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Message()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sendMessage_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sendMessageIgnored_args(object):
    """
    Attributes:
     - seq
     - consumer
     - messageIds
    """
    def __init__(self, seq=None, consumer=None, messageIds=None):
        self.seq = seq
        self.consumer = consumer
        self.messageIds = messageIds

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.seq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.consumer = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.messageIds = []
                    (_, elem918) = iprot.readListBegin()
                    for _ in range(elem918):
                        elem919 = iprot.readString()
                        self.messageIds.append(elem919)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sendMessageIgnored_args')
        if self.seq is not None:
            oprot.writeFieldBegin('seq', TType.I32, 1)
            oprot.writeI32(self.seq)
            oprot.writeFieldEnd()
        if self.consumer is not None:
            oprot.writeFieldBegin('consumer', TType.STRING, 2)
            oprot.writeString(self.consumer)
            oprot.writeFieldEnd()
        if self.messageIds is not None:
            oprot.writeFieldBegin('messageIds', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.messageIds))
            for elem920 in self.messageIds:
                oprot.writeString(elem920)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.seq))
        value = (value * 31) ^ hash(make_hashable(self.consumer))
        value = (value * 31) ^ hash(make_hashable(self.messageIds))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sendMessageIgnored_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sendMessageIgnored_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sendMessageReceipt_args(object):
    """
    Attributes:
     - seq
     - consumer
     - messageIds
    """
    def __init__(self, seq=None, consumer=None, messageIds=None):
        self.seq = seq
        self.consumer = consumer
        self.messageIds = messageIds

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.seq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.consumer = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.messageIds = []
                    (_, elem921) = iprot.readListBegin()
                    for _ in range(elem921):
                        elem922 = iprot.readString()
                        self.messageIds.append(elem922)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sendMessageReceipt_args')
        if self.seq is not None:
            oprot.writeFieldBegin('seq', TType.I32, 1)
            oprot.writeI32(self.seq)
            oprot.writeFieldEnd()
        if self.consumer is not None:
            oprot.writeFieldBegin('consumer', TType.STRING, 2)
            oprot.writeString(self.consumer)
            oprot.writeFieldEnd()
        if self.messageIds is not None:
            oprot.writeFieldBegin('messageIds', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.messageIds))
            for elem923 in self.messageIds:
                oprot.writeString(elem923)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.seq))
        value = (value * 31) ^ hash(make_hashable(self.consumer))
        value = (value * 31) ^ hash(make_hashable(self.messageIds))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sendMessageReceipt_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sendMessageReceipt_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class findContactByMetaTag_args(object):
    """
    Attributes:
     - userid
     - reference
    """
    def __init__(self, userid=None, reference=None):
        self.userid = userid
        self.reference = reference

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.userid = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.reference = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('findContactByMetaTag_args')
        if self.userid is not None:
            oprot.writeFieldBegin('userid', TType.STRING, 2)
            oprot.writeString(self.userid)
            oprot.writeFieldEnd()
        if self.reference is not None:
            oprot.writeFieldBegin('reference', TType.STRING, 3)
            oprot.writeString(self.reference)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.userid))
        value = (value * 31) ^ hash(make_hashable(self.reference))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class findContactByMetaTag_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Contact()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('findContactByMetaTag_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sendMessageToMyHome_args(object):
    """
    Attributes:
     - seq
     - message
    """
    def __init__(self, seq=None, message=None):
        self.seq = seq
        self.message = message

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.seq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.message = Message()
                    self.message.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sendMessageToMyHome_args')
        if self.seq is not None:
            oprot.writeFieldBegin('seq', TType.I32, 1)
            oprot.writeI32(self.seq)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRUCT, 2)
            self.message.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.seq))
        value = (value * 31) ^ hash(make_hashable(self.message))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sendMessageToMyHome_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Message()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sendMessageToMyHome_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class setBuddyLocation_args(object):
    """
    Attributes:
     - mid
     - index
     - location
    """
    def __init__(self, mid=None, index=None, location=None):
        self.mid = mid
        self.index = index
        self.location = location

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.mid = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.location = Geolocation()
                    self.location.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('setBuddyLocation_args')
        if self.mid is not None:
            oprot.writeFieldBegin('mid', TType.STRING, 2)
            oprot.writeString(self.mid)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 3)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        if self.location is not None:
            oprot.writeFieldBegin('location', TType.STRUCT, 4)
            self.location.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.mid))
        value = (value * 31) ^ hash(make_hashable(self.index))
        value = (value * 31) ^ hash(make_hashable(self.location))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class setBuddyLocation_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('setBuddyLocation_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class setIdentityCredential_args(object):
    """
    Attributes:
     - identifier
     - verifier
     - provider
    """
    def __init__(self, identifier=None, verifier=None, provider=None):
        self.identifier = identifier
        self.verifier = verifier
        self.provider = provider

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.identifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.verifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.provider = IdentityProvider(iprot.readI32())
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('setIdentityCredential_args')
        if self.identifier is not None:
            oprot.writeFieldBegin('identifier', TType.STRING, 2)
            oprot.writeString(self.identifier)
            oprot.writeFieldEnd()
        if self.verifier is not None:
            oprot.writeFieldBegin('verifier', TType.STRING, 3)
            oprot.writeString(self.verifier)
            oprot.writeFieldEnd()
        if self.provider is not None:
            oprot.writeFieldBegin('provider', TType.I32, 4)
            oprot.writeI32(self.provider)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.identifier))
        value = (value * 31) ^ hash(make_hashable(self.verifier))
        value = (value * 31) ^ hash(make_hashable(self.provider))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class setIdentityCredential_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('setIdentityCredential_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class setNotificationsEnabled_args(object):
    """
    Attributes:
     - reqSeq
     - type
     - target
     - enablement
    """
    def __init__(self, reqSeq=None, type=None, target=None, enablement=None):
        self.reqSeq = reqSeq
        self.type = type
        self.target = target
        self.enablement = enablement

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.type = MIDType(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.target = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.enablement = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('setNotificationsEnabled_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 2)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.target is not None:
            oprot.writeFieldBegin('target', TType.STRING, 3)
            oprot.writeString(self.target)
            oprot.writeFieldEnd()
        if self.enablement is not None:
            oprot.writeFieldBegin('enablement', TType.BOOL, 4)
            oprot.writeBool(self.enablement)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.type))
        value = (value * 31) ^ hash(make_hashable(self.target))
        value = (value * 31) ^ hash(make_hashable(self.enablement))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class setNotificationsEnabled_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('setNotificationsEnabled_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class startUpdateVerification_args(object):
    """
    Attributes:
     - region
     - carrier
     - phone
     - udidHash
     - deviceInfo
     - networkCode
     - locale
    """
    def __init__(self, region=None, carrier=None, phone=None, udidHash=None, deviceInfo=None, networkCode=None, locale=None):
        self.region = region
        self.carrier = carrier
        self.phone = phone
        self.udidHash = udidHash
        self.deviceInfo = deviceInfo
        self.networkCode = networkCode
        self.locale = locale

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.region = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.carrier = CarrierCode(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.phone = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.udidHash = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.deviceInfo = DeviceInfo()
                    self.deviceInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.networkCode = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.locale = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('startUpdateVerification_args')
        if self.region is not None:
            oprot.writeFieldBegin('region', TType.STRING, 2)
            oprot.writeString(self.region)
            oprot.writeFieldEnd()
        if self.carrier is not None:
            oprot.writeFieldBegin('carrier', TType.I32, 3)
            oprot.writeI32(self.carrier)
            oprot.writeFieldEnd()
        if self.phone is not None:
            oprot.writeFieldBegin('phone', TType.STRING, 4)
            oprot.writeString(self.phone)
            oprot.writeFieldEnd()
        if self.udidHash is not None:
            oprot.writeFieldBegin('udidHash', TType.STRING, 5)
            oprot.writeString(self.udidHash)
            oprot.writeFieldEnd()
        if self.deviceInfo is not None:
            oprot.writeFieldBegin('deviceInfo', TType.STRUCT, 6)
            self.deviceInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.networkCode is not None:
            oprot.writeFieldBegin('networkCode', TType.STRING, 7)
            oprot.writeString(self.networkCode)
            oprot.writeFieldEnd()
        if self.locale is not None:
            oprot.writeFieldBegin('locale', TType.STRING, 8)
            oprot.writeString(self.locale)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.region))
        value = (value * 31) ^ hash(make_hashable(self.carrier))
        value = (value * 31) ^ hash(make_hashable(self.phone))
        value = (value * 31) ^ hash(make_hashable(self.udidHash))
        value = (value * 31) ^ hash(make_hashable(self.deviceInfo))
        value = (value * 31) ^ hash(make_hashable(self.networkCode))
        value = (value * 31) ^ hash(make_hashable(self.locale))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class startUpdateVerification_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = VerificationSessionData()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('startUpdateVerification_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class startVerification_args(object):
    """
    Attributes:
     - region
     - carrier
     - phone
     - udidHash
     - deviceInfo
     - networkCode
     - mid
     - locale
     - simInfo
     - oldUdidHash
    """
    def __init__(self, region=None, carrier=None, phone=None, udidHash=None, deviceInfo=None, networkCode=None, mid=None, locale=None, simInfo=None, oldUdidHash=None):
        self.region = region
        self.carrier = carrier
        self.phone = phone
        self.udidHash = udidHash
        self.deviceInfo = deviceInfo
        self.networkCode = networkCode
        self.mid = mid
        self.locale = locale
        self.simInfo = simInfo
        self.oldUdidHash = oldUdidHash

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.region = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.carrier = CarrierCode(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.phone = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.udidHash = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.deviceInfo = DeviceInfo()
                    self.deviceInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.networkCode = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.mid = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.locale = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.simInfo = SIMInfo()
                    self.simInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRING:
                    self.oldUdidHash = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('startVerification_args')
        if self.region is not None:
            oprot.writeFieldBegin('region', TType.STRING, 2)
            oprot.writeString(self.region)
            oprot.writeFieldEnd()
        if self.carrier is not None:
            oprot.writeFieldBegin('carrier', TType.I32, 3)
            oprot.writeI32(self.carrier)
            oprot.writeFieldEnd()
        if self.phone is not None:
            oprot.writeFieldBegin('phone', TType.STRING, 4)
            oprot.writeString(self.phone)
            oprot.writeFieldEnd()
        if self.udidHash is not None:
            oprot.writeFieldBegin('udidHash', TType.STRING, 5)
            oprot.writeString(self.udidHash)
            oprot.writeFieldEnd()
        if self.deviceInfo is not None:
            oprot.writeFieldBegin('deviceInfo', TType.STRUCT, 6)
            self.deviceInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.networkCode is not None:
            oprot.writeFieldBegin('networkCode', TType.STRING, 7)
            oprot.writeString(self.networkCode)
            oprot.writeFieldEnd()
        if self.mid is not None:
            oprot.writeFieldBegin('mid', TType.STRING, 8)
            oprot.writeString(self.mid)
            oprot.writeFieldEnd()
        if self.locale is not None:
            oprot.writeFieldBegin('locale', TType.STRING, 9)
            oprot.writeString(self.locale)
            oprot.writeFieldEnd()
        if self.simInfo is not None:
            oprot.writeFieldBegin('simInfo', TType.STRUCT, 10)
            self.simInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.oldUdidHash is not None:
            oprot.writeFieldBegin('oldUdidHash', TType.STRING, 11)
            oprot.writeString(self.oldUdidHash)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.region))
        value = (value * 31) ^ hash(make_hashable(self.carrier))
        value = (value * 31) ^ hash(make_hashable(self.phone))
        value = (value * 31) ^ hash(make_hashable(self.udidHash))
        value = (value * 31) ^ hash(make_hashable(self.deviceInfo))
        value = (value * 31) ^ hash(make_hashable(self.networkCode))
        value = (value * 31) ^ hash(make_hashable(self.mid))
        value = (value * 31) ^ hash(make_hashable(self.locale))
        value = (value * 31) ^ hash(make_hashable(self.simInfo))
        value = (value * 31) ^ hash(make_hashable(self.oldUdidHash))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class startVerification_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = VerificationSessionData()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('startVerification_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateGroupPreferenceAttribute_args(object):
    """
    Attributes:
     - reqSeq
     - groupMid
     - updatedAttrs
    """
    def __init__(self, reqSeq=None, groupMid=None, updatedAttrs=None):
        self.reqSeq = reqSeq
        self.groupMid = groupMid
        self.updatedAttrs = updatedAttrs

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.groupMid = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.updatedAttrs = {}
                    (_, _, elem924) = iprot.readMapBegin()
                    for _ in range(elem924):
                        elem926 = GroupPreferenceAttribute(iprot.readI32())
                        elem925 = iprot.readString()
                        self.updatedAttrs[elem926] = elem925
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateGroupPreferenceAttribute_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.groupMid is not None:
            oprot.writeFieldBegin('groupMid', TType.STRING, 2)
            oprot.writeString(self.groupMid)
            oprot.writeFieldEnd()
        if self.updatedAttrs is not None:
            oprot.writeFieldBegin('updatedAttrs', TType.MAP, 3)
            oprot.writeMapBegin(TType.I32, TType.STRING, len(self.updatedAttrs))
            for elem928, elem927 in self.updatedAttrs.items():
                oprot.writeI32(elem928)
                oprot.writeString(elem927)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.groupMid))
        value = (value * 31) ^ hash(make_hashable(self.updatedAttrs))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateGroupPreferenceAttribute_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateGroupPreferenceAttribute_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class createRoomV2_args(object):
    """
    Attributes:
     - reqSeq
     - contactIds
    """
    def __init__(self, reqSeq=None, contactIds=None):
        self.reqSeq = reqSeq
        self.contactIds = contactIds

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.contactIds = []
                    (_, elem929) = iprot.readListBegin()
                    for _ in range(elem929):
                        elem930 = iprot.readString()
                        self.contactIds.append(elem930)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('createRoomV2_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.contactIds is not None:
            oprot.writeFieldBegin('contactIds', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.contactIds))
            for elem931 in self.contactIds:
                oprot.writeString(elem931)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.contactIds))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class createRoomV2_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Room()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('createRoomV2_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class storeUpdateProfileAttribute_args(object):
    """
    Attributes:
     - seq
     - profileAttribute
     - value
    """
    def __init__(self, seq=None, profileAttribute=None, value=None):
        self.seq = seq
        self.profileAttribute = profileAttribute
        self.value = value

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.seq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.profileAttribute = ProfileAttribute(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('storeUpdateProfileAttribute_args')
        if self.seq is not None:
            oprot.writeFieldBegin('seq', TType.I32, 1)
            oprot.writeI32(self.seq)
            oprot.writeFieldEnd()
        if self.profileAttribute is not None:
            oprot.writeFieldBegin('profileAttribute', TType.I32, 2)
            oprot.writeI32(self.profileAttribute)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeString(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.seq))
        value = (value * 31) ^ hash(make_hashable(self.profileAttribute))
        value = (value * 31) ^ hash(make_hashable(self.value))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class storeUpdateProfileAttribute_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('storeUpdateProfileAttribute_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class syncContactBySnsIds_args(object):
    """
    Attributes:
     - reqSeq
     - modifications
    """
    def __init__(self, reqSeq=None, modifications=None):
        self.reqSeq = reqSeq
        self.modifications = modifications

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.modifications = []
                    (_, elem932) = iprot.readListBegin()
                    for _ in range(elem932):
                        elem933 = SnsFriendModification()
                        elem933.read(iprot)
                        self.modifications.append(elem933)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('syncContactBySnsIds_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.modifications is not None:
            oprot.writeFieldBegin('modifications', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.modifications))
            for elem934 in self.modifications:
                elem934.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.modifications))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class syncContactBySnsIds_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem935) = iprot.readListBegin()
                    for _ in range(elem935):
                        elem936 = SnsFriendContactRegistration()
                        elem936.read(iprot)
                        self.success.append(elem936)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('syncContactBySnsIds_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem937 in self.success:
                elem937.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class syncContacts_args(object):
    """
    Attributes:
     - reqSeq
     - localContacts
    """
    def __init__(self, reqSeq=None, localContacts=None):
        self.reqSeq = reqSeq
        self.localContacts = localContacts

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.localContacts = []
                    (_, elem938) = iprot.readListBegin()
                    for _ in range(elem938):
                        elem939 = ContactModification()
                        elem939.read(iprot)
                        self.localContacts.append(elem939)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('syncContacts_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.localContacts is not None:
            oprot.writeFieldBegin('localContacts', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.localContacts))
            for elem940 in self.localContacts:
                elem940.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.localContacts))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class syncContacts_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_, _, elem941) = iprot.readMapBegin()
                    for _ in range(elem941):
                        elem943 = iprot.readString()
                        elem942 = ContactRegistration()
                        elem942.read(iprot)
                        self.success[elem943] = elem942
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('syncContacts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for elem945, elem944 in self.success.items():
                oprot.writeString(elem945)
                elem944.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class trySendMessage_args(object):
    """
    Attributes:
     - seq
     - message
    """
    def __init__(self, seq=None, message=None):
        self.seq = seq
        self.message = message

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.seq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.message = Message()
                    self.message.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('trySendMessage_args')
        if self.seq is not None:
            oprot.writeFieldBegin('seq', TType.I32, 1)
            oprot.writeI32(self.seq)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRUCT, 2)
            self.message.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.seq))
        value = (value * 31) ^ hash(make_hashable(self.message))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class trySendMessage_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Message()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('trySendMessage_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getNextMessagesV2_args(object):
    """
    Attributes:
     - messageBoxId
     - startMessageId
     - messagesCount
    """
    def __init__(self, messageBoxId=None, startMessageId=None, messagesCount=None):
        self.messageBoxId = messageBoxId
        self.startMessageId = startMessageId
        self.messagesCount = messagesCount

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.messageBoxId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.startMessageId = MessageBoxV2MessageId()
                    self.startMessageId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.messagesCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getNextMessagesV2_args')
        if self.messageBoxId is not None:
            oprot.writeFieldBegin('messageBoxId', TType.STRING, 2)
            oprot.writeString(self.messageBoxId)
            oprot.writeFieldEnd()
        if self.startMessageId is not None:
            oprot.writeFieldBegin('startMessageId', TType.STRUCT, 3)
            self.startMessageId.write(oprot)
            oprot.writeFieldEnd()
        if self.messagesCount is not None:
            oprot.writeFieldBegin('messagesCount', TType.I32, 4)
            oprot.writeI32(self.messagesCount)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.messageBoxId))
        value = (value * 31) ^ hash(make_hashable(self.startMessageId))
        value = (value * 31) ^ hash(make_hashable(self.messagesCount))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getNextMessagesV2_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem946) = iprot.readListBegin()
                    for _ in range(elem946):
                        elem947 = Message()
                        elem947.read(iprot)
                        self.success.append(elem947)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getNextMessagesV2_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem948 in self.success:
                elem948.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getMessageBoxCompactWrapUpV2_args(object):
    """
    Attributes:
     - messageBoxId
    """
    def __init__(self, messageBoxId=None):
        self.messageBoxId = messageBoxId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.messageBoxId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getMessageBoxCompactWrapUpV2_args')
        if self.messageBoxId is not None:
            oprot.writeFieldBegin('messageBoxId', TType.STRING, 2)
            oprot.writeString(self.messageBoxId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.messageBoxId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getMessageBoxCompactWrapUpV2_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TMessageBoxWrapUp()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getMessageBoxCompactWrapUpV2_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getRecentMessagesV2_args(object):
    """
    Attributes:
     - messageBoxId
     - messagesCount
    """
    def __init__(self, messageBoxId=None, messagesCount=None):
        self.messageBoxId = messageBoxId
        self.messagesCount = messagesCount

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.messageBoxId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.messagesCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getRecentMessagesV2_args')
        if self.messageBoxId is not None:
            oprot.writeFieldBegin('messageBoxId', TType.STRING, 2)
            oprot.writeString(self.messageBoxId)
            oprot.writeFieldEnd()
        if self.messagesCount is not None:
            oprot.writeFieldBegin('messagesCount', TType.I32, 3)
            oprot.writeI32(self.messagesCount)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.messageBoxId))
        value = (value * 31) ^ hash(make_hashable(self.messagesCount))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getRecentMessagesV2_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem949) = iprot.readListBegin()
                    for _ in range(elem949):
                        elem950 = Message()
                        elem950.read(iprot)
                        self.success.append(elem950)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getRecentMessagesV2_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem951 in self.success:
                elem951.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class validateContactsOnBot_args(object):
    """
    Attributes:
     - contacts
    """
    def __init__(self, contacts=None):
        self.contacts = contacts

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.LIST:
                    self.contacts = []
                    (_, elem952) = iprot.readListBegin()
                    for _ in range(elem952):
                        elem953 = iprot.readString()
                        self.contacts.append(elem953)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('validateContactsOnBot_args')
        if self.contacts is not None:
            oprot.writeFieldBegin('contacts', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.contacts))
            for elem954 in self.contacts:
                oprot.writeString(elem954)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.contacts))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class validateContactsOnBot_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_, _, elem955) = iprot.readMapBegin()
                    for _ in range(elem955):
                        elem957 = iprot.readString()
                        elem956 = iprot.readString()
                        self.success[elem957] = elem956
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('validateContactsOnBot_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for elem959, elem958 in self.success.items():
                oprot.writeString(elem959)
                oprot.writeString(elem958)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class tryFriendRequest_args(object):
    """
    Attributes:
     - midOrEMid
     - method
     - friendRequestParams
    """
    def __init__(self, midOrEMid=None, method=None, friendRequestParams=None):
        self.midOrEMid = midOrEMid
        self.method = method
        self.friendRequestParams = friendRequestParams

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.midOrEMid = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.method = FriendRequestMethod(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.friendRequestParams = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('tryFriendRequest_args')
        if self.midOrEMid is not None:
            oprot.writeFieldBegin('midOrEMid', TType.STRING, 1)
            oprot.writeString(self.midOrEMid)
            oprot.writeFieldEnd()
        if self.method is not None:
            oprot.writeFieldBegin('method', TType.I32, 2)
            oprot.writeI32(self.method)
            oprot.writeFieldEnd()
        if self.friendRequestParams is not None:
            oprot.writeFieldBegin('friendRequestParams', TType.STRING, 3)
            oprot.writeString(self.friendRequestParams)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.midOrEMid))
        value = (value * 31) ^ hash(make_hashable(self.method))
        value = (value * 31) ^ hash(make_hashable(self.friendRequestParams))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class tryFriendRequest_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('tryFriendRequest_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class unblockContact_args(object):
    """
    Attributes:
     - reqSeq
     - id
    """
    def __init__(self, reqSeq=None, id=None):
        self.reqSeq = reqSeq
        self.id = id

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.id = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('unblockContact_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 2)
            oprot.writeString(self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.id))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class unblockContact_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('unblockContact_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class unblockRecommendation_args(object):
    """
    Attributes:
     - reqSeq
     - id
    """
    def __init__(self, reqSeq=None, id=None):
        self.reqSeq = reqSeq
        self.id = id

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.id = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('unblockRecommendation_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 2)
            oprot.writeString(self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.id))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class unblockRecommendation_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('unblockRecommendation_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class unregisterUserAndDevice_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('unregisterUserAndDevice_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class unregisterUserAndDevice_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('unregisterUserAndDevice_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateApnsDeviceToken_args(object):
    """
    Attributes:
     - apnsDeviceToken
    """
    def __init__(self, apnsDeviceToken=None):
        self.apnsDeviceToken = apnsDeviceToken

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.apnsDeviceToken = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateApnsDeviceToken_args')
        if self.apnsDeviceToken is not None:
            oprot.writeFieldBegin('apnsDeviceToken', TType.STRING, 2)
            oprot.writeBinary(self.apnsDeviceToken)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.apnsDeviceToken))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateApnsDeviceToken_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateApnsDeviceToken_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateBuddySetting_args(object):
    """
    Attributes:
     - key
     - value
    """
    def __init__(self, key=None, value=None):
        self.key = key
        self.value = value

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateBuddySetting_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeString(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.key))
        value = (value * 31) ^ hash(make_hashable(self.value))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateBuddySetting_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateBuddySetting_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateC2DMRegistrationId_args(object):
    """
    Attributes:
     - registrationId
    """
    def __init__(self, registrationId=None):
        self.registrationId = registrationId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.registrationId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateC2DMRegistrationId_args')
        if self.registrationId is not None:
            oprot.writeFieldBegin('registrationId', TType.STRING, 2)
            oprot.writeString(self.registrationId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.registrationId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateC2DMRegistrationId_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateC2DMRegistrationId_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateContactSetting_args(object):
    """
    Attributes:
     - reqSeq
     - mid
     - flag
     - value
    """
    def __init__(self, reqSeq=None, mid=None, flag=None, value=None):
        self.reqSeq = reqSeq
        self.mid = mid
        self.flag = flag
        self.value = value

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mid = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.flag = ContactSetting(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.value = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateContactSetting_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.mid is not None:
            oprot.writeFieldBegin('mid', TType.STRING, 2)
            oprot.writeString(self.mid)
            oprot.writeFieldEnd()
        if self.flag is not None:
            oprot.writeFieldBegin('flag', TType.I32, 3)
            oprot.writeI32(self.flag)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 4)
            oprot.writeString(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.mid))
        value = (value * 31) ^ hash(make_hashable(self.flag))
        value = (value * 31) ^ hash(make_hashable(self.value))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateContactSetting_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateContactSetting_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateCustomModeSettings_args(object):
    """
    Attributes:
     - customMode
     - paramMap
    """
    def __init__(self, customMode=None, paramMap=None):
        self.customMode = customMode
        self.paramMap = paramMap

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I32:
                    self.customMode = CustomMode(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.paramMap = {}
                    (_, _, elem960) = iprot.readMapBegin()
                    for _ in range(elem960):
                        elem962 = iprot.readString()
                        elem961 = iprot.readString()
                        self.paramMap[elem962] = elem961
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateCustomModeSettings_args')
        if self.customMode is not None:
            oprot.writeFieldBegin('customMode', TType.I32, 2)
            oprot.writeI32(self.customMode)
            oprot.writeFieldEnd()
        if self.paramMap is not None:
            oprot.writeFieldBegin('paramMap', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.paramMap))
            for elem964, elem963 in self.paramMap.items():
                oprot.writeString(elem964)
                oprot.writeString(elem963)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.customMode))
        value = (value * 31) ^ hash(make_hashable(self.paramMap))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateCustomModeSettings_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateCustomModeSettings_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateDeviceInfo_args(object):
    """
    Attributes:
     - deviceUid
     - deviceInfo
    """
    def __init__(self, deviceUid=None, deviceInfo=None):
        self.deviceUid = deviceUid
        self.deviceInfo = deviceInfo

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.deviceUid = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.deviceInfo = DeviceInfo()
                    self.deviceInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateDeviceInfo_args')
        if self.deviceUid is not None:
            oprot.writeFieldBegin('deviceUid', TType.STRING, 2)
            oprot.writeString(self.deviceUid)
            oprot.writeFieldEnd()
        if self.deviceInfo is not None:
            oprot.writeFieldBegin('deviceInfo', TType.STRUCT, 3)
            self.deviceInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.deviceUid))
        value = (value * 31) ^ hash(make_hashable(self.deviceInfo))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateDeviceInfo_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateDeviceInfo_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateGroup_args(object):
    """
    Attributes:
     - reqSeq
     - group
    """
    def __init__(self, reqSeq=None, group=None):
        self.reqSeq = reqSeq
        self.group = group

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.group = Group()
                    self.group.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateGroup_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.group is not None:
            oprot.writeFieldBegin('group', TType.STRUCT, 2)
            self.group.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.group))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateGroup_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateGroup_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateNotificationToken_args(object):
    """
    Attributes:
     - type
     - token
    """
    def __init__(self, type=None, token=None):
        self.type = type
        self.token = token

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 3:
                if ftype == TType.I32:
                    self.type = NotificationType(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.token = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateNotificationToken_args')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 3)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 2)
            oprot.writeString(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.type))
        value = (value * 31) ^ hash(make_hashable(self.token))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateNotificationToken_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateNotificationToken_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateNotificationTokenWithBytes_args(object):
    """
    Attributes:
     - type
     - token
    """
    def __init__(self, type=None, token=None):
        self.type = type
        self.token = token

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 3:
                if ftype == TType.I32:
                    self.type = NotificationType(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateNotificationTokenWithBytes_args')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 3)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 2)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.type))
        value = (value * 31) ^ hash(make_hashable(self.token))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateNotificationTokenWithBytes_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateNotificationTokenWithBytes_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateProfile_args(object):
    """
    Attributes:
     - reqSeq
     - profile
    """
    def __init__(self, reqSeq=None, profile=None):
        self.reqSeq = reqSeq
        self.profile = profile

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.profile = Profile()
                    self.profile.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateProfile_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.profile is not None:
            oprot.writeFieldBegin('profile', TType.STRUCT, 2)
            self.profile.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.profile))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateProfile_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateProfile_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateProfileAttribute_args(object):
    """
    Attributes:
     - reqSeq
     - attr
     - value
    """
    def __init__(self, reqSeq=None, attr=None, value=None):
        self.reqSeq = reqSeq
        self.attr = attr
        self.value = value

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.attr = ProfileAttribute(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateProfileAttribute_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.attr is not None:
            oprot.writeFieldBegin('attr', TType.I32, 2)
            oprot.writeI32(self.attr)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeString(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.attr))
        value = (value * 31) ^ hash(make_hashable(self.value))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateProfileAttribute_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateProfileAttribute_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateRegion_args(object):
    """
    Attributes:
     - region
    """
    def __init__(self, region=None):
        self.region = region

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.region = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateRegion_args')
        if self.region is not None:
            oprot.writeFieldBegin('region', TType.STRING, 2)
            oprot.writeString(self.region)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.region))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateRegion_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateRegion_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateSettings_args(object):
    """
    Attributes:
     - reqSeq
     - settings
    """
    def __init__(self, reqSeq=None, settings=None):
        self.reqSeq = reqSeq
        self.settings = settings

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.settings = Settings()
                    self.settings.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateSettings_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.settings is not None:
            oprot.writeFieldBegin('settings', TType.STRUCT, 2)
            self.settings.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.settings))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateSettings_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateSettings_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateSettings2_args(object):
    """
    Attributes:
     - reqSeq
     - settings
    """
    def __init__(self, reqSeq=None, settings=None):
        self.reqSeq = reqSeq
        self.settings = settings

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.settings = Settings()
                    self.settings.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateSettings2_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.settings is not None:
            oprot.writeFieldBegin('settings', TType.STRUCT, 2)
            self.settings.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.settings))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateSettings2_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateSettings2_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateSettingsAttribute_args(object):
    """
    Attributes:
     - reqSeq
     - attr
     - value
    """
    def __init__(self, reqSeq=None, attr=None, value=None):
        self.reqSeq = reqSeq
        self.attr = attr
        self.value = value

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.attr = SettingsAttribute(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateSettingsAttribute_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.attr is not None:
            oprot.writeFieldBegin('attr', TType.I32, 2)
            oprot.writeI32(self.attr)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeString(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.attr))
        value = (value * 31) ^ hash(make_hashable(self.value))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateSettingsAttribute_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateSettingsAttribute_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateSettingsAttributes_args(object):
    """
    Attributes:
     - reqSeq
     - attrBitset
     - settings
    """
    def __init__(self, reqSeq=None, attrBitset=None, settings=None):
        self.reqSeq = reqSeq
        self.attrBitset = attrBitset
        self.settings = settings

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.reqSeq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.attrBitset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.settings = Settings()
                    self.settings.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateSettingsAttributes_args')
        if self.reqSeq is not None:
            oprot.writeFieldBegin('reqSeq', TType.I32, 1)
            oprot.writeI32(self.reqSeq)
            oprot.writeFieldEnd()
        if self.attrBitset is not None:
            oprot.writeFieldBegin('attrBitset', TType.I32, 2)
            oprot.writeI32(self.attrBitset)
            oprot.writeFieldEnd()
        if self.settings is not None:
            oprot.writeFieldBegin('settings', TType.STRUCT, 3)
            self.settings.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.reqSeq))
        value = (value * 31) ^ hash(make_hashable(self.attrBitset))
        value = (value * 31) ^ hash(make_hashable(self.settings))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateSettingsAttributes_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateSettingsAttributes_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class verifyIdentityCredential_args(object):
    """
    Attributes:
     - identityProvider
     - identifier
     - password
    """
    def __init__(self, identityProvider=None, identifier=None, password=None):
        self.identityProvider = identityProvider
        self.identifier = identifier
        self.password = password

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 8:
                if ftype == TType.I32:
                    self.identityProvider = IdentityProvider(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.identifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.password = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('verifyIdentityCredential_args')
        if self.identityProvider is not None:
            oprot.writeFieldBegin('identityProvider', TType.I32, 8)
            oprot.writeI32(self.identityProvider)
            oprot.writeFieldEnd()
        if self.identifier is not None:
            oprot.writeFieldBegin('identifier', TType.STRING, 3)
            oprot.writeString(self.identifier)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 4)
            oprot.writeString(self.password)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.identityProvider))
        value = (value * 31) ^ hash(make_hashable(self.identifier))
        value = (value * 31) ^ hash(make_hashable(self.password))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class verifyIdentityCredential_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('verifyIdentityCredential_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class verifyIdentityCredentialWithResult_args(object):
    """
    Attributes:
     - identityCredential
    """
    def __init__(self, identityCredential=None):
        self.identityCredential = identityCredential

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.identityCredential = IdentityCredential()
                    self.identityCredential.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('verifyIdentityCredentialWithResult_args')
        if self.identityCredential is not None:
            oprot.writeFieldBegin('identityCredential', TType.STRUCT, 2)
            self.identityCredential.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.identityCredential))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class verifyIdentityCredentialWithResult_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = UserAuthStatus()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('verifyIdentityCredentialWithResult_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class verifyPhone_args(object):
    """
    Attributes:
     - sessionId
     - pinCode
     - udidHash
    """
    def __init__(self, sessionId=None, pinCode=None, udidHash=None):
        self.sessionId = sessionId
        self.pinCode = pinCode
        self.udidHash = udidHash

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.pinCode = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.udidHash = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('verifyPhone_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 2)
            oprot.writeString(self.sessionId)
            oprot.writeFieldEnd()
        if self.pinCode is not None:
            oprot.writeFieldBegin('pinCode', TType.STRING, 3)
            oprot.writeString(self.pinCode)
            oprot.writeFieldEnd()
        if self.udidHash is not None:
            oprot.writeFieldBegin('udidHash', TType.STRING, 4)
            oprot.writeString(self.udidHash)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.sessionId))
        value = (value * 31) ^ hash(make_hashable(self.pinCode))
        value = (value * 31) ^ hash(make_hashable(self.udidHash))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class verifyPhone_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = VerificationResult(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('verifyPhone_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class verifyQrcode_args(object):
    """
    Attributes:
     - verifier
     - pinCode
    """
    def __init__(self, verifier=None, pinCode=None):
        self.verifier = verifier
        self.pinCode = pinCode

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.verifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.pinCode = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('verifyQrcode_args')
        if self.verifier is not None:
            oprot.writeFieldBegin('verifier', TType.STRING, 2)
            oprot.writeString(self.verifier)
            oprot.writeFieldEnd()
        if self.pinCode is not None:
            oprot.writeFieldBegin('pinCode', TType.STRING, 3)
            oprot.writeString(self.pinCode)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.verifier))
        value = (value * 31) ^ hash(make_hashable(self.pinCode))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class verifyQrcode_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('verifyQrcode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

