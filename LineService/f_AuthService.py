#
# Autogenerated by Frugal Compiler (3.7.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#



from threading import Lock

from frugal.middleware import Method
from frugal.exceptions import TApplicationExceptionType
from frugal.exceptions import TTransportExceptionType
from frugal.processor import FBaseProcessor
from frugal.processor import FProcessorFunction
from frugal.util.deprecate import deprecated
from frugal.util import make_hashable
from thrift.Thrift import TApplicationException
from thrift.Thrift import TMessageType
from thrift.transport.TTransport import TTransportException

from .ttypes import *


class Iface(object):

    def normalizePhoneNumber(self, ctx, countryCode, phoneNumber, countryCodeHint):
        """
        Args:
            ctx: FContext
            countryCode: string
            phoneNumber: string
            countryCodeHint: string
        """
        pass

    def respondE2EELoginRequest(self, ctx, verifier, publicKey, encryptedKeyChain, hashKeyChain, errorCode):
        """
        Args:
            ctx: FContext
            verifier: string
            publicKey: E2EEPublicKey
            encryptedKeyChain: binary string
            hashKeyChain: binary string
            errorCode: ErrorCode
        """
        pass

    def confirmE2EELogin(self, ctx, verifier, deviceSecret):
        """
        Args:
            ctx: FContext
            verifier: string
            deviceSecret: binary string
        """
        pass

    def logoutZ(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def loginZ(self, ctx, loginRequest):
        """
        Args:
            ctx: FContext
            loginRequest: LoginRequest
        """
        pass

    def issueTokenForAccountMigrationSettings(self, ctx, enforce):
        """
        Args:
            ctx: FContext
            enforce: boolean
        """
        pass

    def issueTokenForAccountMigration(self, ctx, migrationSessionId):
        """
        Args:
            ctx: FContext
            migrationSessionId: string
        """
        pass

    def verifyQrcodeWithE2EE(self, ctx, verifier, pinCode, errorCode, publicKey, encryptedKeyChain, hashKeyChain):
        """
        Args:
            ctx: FContext
            verifier: string
            pinCode: string
            errorCode: ErrorCode
            publicKey: E2EEPublicKey
            encryptedKeyChain: binary string
            hashKeyChain: binary string
        """
        pass


class Client(Iface):

    def __init__(self, provider, middleware=None):
        """
        Create a new Client with an FServiceProvider containing a transport
        and protocol factory.

        Args:
            provider: FServiceProvider with TSynchronousTransport
            middleware: ServiceMiddleware or list of ServiceMiddleware
        """
        middleware = middleware or []
        if middleware and not isinstance(middleware, list):
            middleware = [middleware]
        self._transport = provider.get_transport()
        self._protocol_factory = provider.get_protocol_factory()
        self._oprot = self._protocol_factory.get_protocol(self._transport)
        self._iprot = self._protocol_factory.get_protocol(self._transport)
        self._write_lock = Lock()
        middleware += provider.get_middleware()
        self._methods = {
            'normalizePhoneNumber': Method(self._normalizePhoneNumber, middleware),
            'respondE2EELoginRequest': Method(self._respondE2EELoginRequest, middleware),
            'confirmE2EELogin': Method(self._confirmE2EELogin, middleware),
            'logoutZ': Method(self._logoutZ, middleware),
            'loginZ': Method(self._loginZ, middleware),
            'issueTokenForAccountMigrationSettings': Method(self._issueTokenForAccountMigrationSettings, middleware),
            'issueTokenForAccountMigration': Method(self._issueTokenForAccountMigration, middleware),
            'verifyQrcodeWithE2EE': Method(self._verifyQrcodeWithE2EE, middleware),
        }

    def normalizePhoneNumber(self, ctx, countryCode, phoneNumber, countryCodeHint):
        """
        Args:
            ctx: FContext
            countryCode: string
            phoneNumber: string
            countryCodeHint: string
        """
        return self._methods['normalizePhoneNumber']([ctx, countryCode, phoneNumber, countryCodeHint])

    def _normalizePhoneNumber(self, ctx, countryCode, phoneNumber, countryCodeHint):
        self._send_normalizePhoneNumber(ctx, countryCode, phoneNumber, countryCodeHint)
        return self._recv_normalizePhoneNumber(ctx)

    def _send_normalizePhoneNumber(self, ctx, countryCode, phoneNumber, countryCodeHint):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('normalizePhoneNumber', TMessageType.CALL, 0)
            args = normalizePhoneNumber_args()
            args.countryCode = countryCode
            args.phoneNumber = phoneNumber
            args.countryCodeHint = countryCodeHint
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_normalizePhoneNumber(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = normalizePhoneNumber_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "normalizePhoneNumber failed: unknown result")
        raise x

    def respondE2EELoginRequest(self, ctx, verifier, publicKey, encryptedKeyChain, hashKeyChain, errorCode):
        """
        Args:
            ctx: FContext
            verifier: string
            publicKey: E2EEPublicKey
            encryptedKeyChain: binary string
            hashKeyChain: binary string
            errorCode: ErrorCode
        """
        return self._methods['respondE2EELoginRequest']([ctx, verifier, publicKey, encryptedKeyChain, hashKeyChain, errorCode])

    def _respondE2EELoginRequest(self, ctx, verifier, publicKey, encryptedKeyChain, hashKeyChain, errorCode):
        self._send_respondE2EELoginRequest(ctx, verifier, publicKey, encryptedKeyChain, hashKeyChain, errorCode)
        self._recv_respondE2EELoginRequest(ctx)

    def _send_respondE2EELoginRequest(self, ctx, verifier, publicKey, encryptedKeyChain, hashKeyChain, errorCode):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('respondE2EELoginRequest', TMessageType.CALL, 0)
            args = respondE2EELoginRequest_args()
            args.verifier = verifier
            args.publicKey = publicKey
            args.encryptedKeyChain = encryptedKeyChain
            args.hashKeyChain = hashKeyChain
            args.errorCode = errorCode
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_respondE2EELoginRequest(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = respondE2EELoginRequest_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def confirmE2EELogin(self, ctx, verifier, deviceSecret):
        """
        Args:
            ctx: FContext
            verifier: string
            deviceSecret: binary string
        """
        return self._methods['confirmE2EELogin']([ctx, verifier, deviceSecret])

    def _confirmE2EELogin(self, ctx, verifier, deviceSecret):
        self._send_confirmE2EELogin(ctx, verifier, deviceSecret)
        return self._recv_confirmE2EELogin(ctx)

    def _send_confirmE2EELogin(self, ctx, verifier, deviceSecret):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('confirmE2EELogin', TMessageType.CALL, 0)
            args = confirmE2EELogin_args()
            args.verifier = verifier
            args.deviceSecret = deviceSecret
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_confirmE2EELogin(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = confirmE2EELogin_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "confirmE2EELogin failed: unknown result")
        raise x

    def logoutZ(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['logoutZ']([ctx])

    def _logoutZ(self, ctx):
        self._send_logoutZ(ctx)
        self._recv_logoutZ(ctx)

    def _send_logoutZ(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('logoutZ', TMessageType.CALL, 0)
            args = logoutZ_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_logoutZ(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = logoutZ_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def loginZ(self, ctx, loginRequest):
        """
        Args:
            ctx: FContext
            loginRequest: LoginRequest
        """
        return self._methods['loginZ']([ctx, loginRequest])

    def _loginZ(self, ctx, loginRequest):
        self._send_loginZ(ctx, loginRequest)
        return self._recv_loginZ(ctx)

    def _send_loginZ(self, ctx, loginRequest):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('loginZ', TMessageType.CALL, 0)
            args = loginZ_args()
            args.loginRequest = loginRequest
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_loginZ(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = loginZ_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "loginZ failed: unknown result")
        raise x

    def issueTokenForAccountMigrationSettings(self, ctx, enforce):
        """
        Args:
            ctx: FContext
            enforce: boolean
        """
        return self._methods['issueTokenForAccountMigrationSettings']([ctx, enforce])

    def _issueTokenForAccountMigrationSettings(self, ctx, enforce):
        self._send_issueTokenForAccountMigrationSettings(ctx, enforce)
        return self._recv_issueTokenForAccountMigrationSettings(ctx)

    def _send_issueTokenForAccountMigrationSettings(self, ctx, enforce):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('issueTokenForAccountMigrationSettings', TMessageType.CALL, 0)
            args = issueTokenForAccountMigrationSettings_args()
            args.enforce = enforce
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_issueTokenForAccountMigrationSettings(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = issueTokenForAccountMigrationSettings_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "issueTokenForAccountMigrationSettings failed: unknown result")
        raise x

    def issueTokenForAccountMigration(self, ctx, migrationSessionId):
        """
        Args:
            ctx: FContext
            migrationSessionId: string
        """
        return self._methods['issueTokenForAccountMigration']([ctx, migrationSessionId])

    def _issueTokenForAccountMigration(self, ctx, migrationSessionId):
        self._send_issueTokenForAccountMigration(ctx, migrationSessionId)
        return self._recv_issueTokenForAccountMigration(ctx)

    def _send_issueTokenForAccountMigration(self, ctx, migrationSessionId):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('issueTokenForAccountMigration', TMessageType.CALL, 0)
            args = issueTokenForAccountMigration_args()
            args.migrationSessionId = migrationSessionId
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_issueTokenForAccountMigration(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = issueTokenForAccountMigration_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "issueTokenForAccountMigration failed: unknown result")
        raise x

    def verifyQrcodeWithE2EE(self, ctx, verifier, pinCode, errorCode, publicKey, encryptedKeyChain, hashKeyChain):
        """
        Args:
            ctx: FContext
            verifier: string
            pinCode: string
            errorCode: ErrorCode
            publicKey: E2EEPublicKey
            encryptedKeyChain: binary string
            hashKeyChain: binary string
        """
        return self._methods['verifyQrcodeWithE2EE']([ctx, verifier, pinCode, errorCode, publicKey, encryptedKeyChain, hashKeyChain])

    def _verifyQrcodeWithE2EE(self, ctx, verifier, pinCode, errorCode, publicKey, encryptedKeyChain, hashKeyChain):
        self._send_verifyQrcodeWithE2EE(ctx, verifier, pinCode, errorCode, publicKey, encryptedKeyChain, hashKeyChain)
        return self._recv_verifyQrcodeWithE2EE(ctx)

    def _send_verifyQrcodeWithE2EE(self, ctx, verifier, pinCode, errorCode, publicKey, encryptedKeyChain, hashKeyChain):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('verifyQrcodeWithE2EE', TMessageType.CALL, 0)
            args = verifyQrcodeWithE2EE_args()
            args.verifier = verifier
            args.pinCode = pinCode
            args.errorCode = errorCode
            args.publicKey = publicKey
            args.encryptedKeyChain = encryptedKeyChain
            args.hashKeyChain = hashKeyChain
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_verifyQrcodeWithE2EE(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = verifyQrcodeWithE2EE_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "verifyQrcodeWithE2EE failed: unknown result")
        raise x

class Processor(FBaseProcessor):

    def __init__(self, handler, middleware=None):
        """
        Create a new Processor.

        Args:
            handler: Iface
        """
        if middleware and not isinstance(middleware, list):
            middleware = [middleware]

        super(Processor, self).__init__()
        self.add_to_processor_map('normalizePhoneNumber', _normalizePhoneNumber(Method(handler.normalizePhoneNumber, middleware), self.get_write_lock()))
        self.add_to_processor_map('respondE2EELoginRequest', _respondE2EELoginRequest(Method(handler.respondE2EELoginRequest, middleware), self.get_write_lock()))
        self.add_to_processor_map('confirmE2EELogin', _confirmE2EELogin(Method(handler.confirmE2EELogin, middleware), self.get_write_lock()))
        self.add_to_processor_map('logoutZ', _logoutZ(Method(handler.logoutZ, middleware), self.get_write_lock()))
        self.add_to_processor_map('loginZ', _loginZ(Method(handler.loginZ, middleware), self.get_write_lock()))
        self.add_to_processor_map('issueTokenForAccountMigrationSettings', _issueTokenForAccountMigrationSettings(Method(handler.issueTokenForAccountMigrationSettings, middleware), self.get_write_lock()))
        self.add_to_processor_map('issueTokenForAccountMigration', _issueTokenForAccountMigration(Method(handler.issueTokenForAccountMigration, middleware), self.get_write_lock()))
        self.add_to_processor_map('verifyQrcodeWithE2EE', _verifyQrcodeWithE2EE(Method(handler.verifyQrcodeWithE2EE, middleware), self.get_write_lock()))


class _normalizePhoneNumber(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_normalizePhoneNumber, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = normalizePhoneNumber_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = normalizePhoneNumber_result()
        try:
            result.success = self._handler([ctx, args.countryCode, args.phoneNumber, args.countryCodeHint])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "normalizePhoneNumber", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "normalizePhoneNumber", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('normalizePhoneNumber', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "normalizePhoneNumber", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _respondE2EELoginRequest(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_respondE2EELoginRequest, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = respondE2EELoginRequest_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = respondE2EELoginRequest_result()
        try:
            self._handler([ctx, args.verifier, args.publicKey, args.encryptedKeyChain, args.hashKeyChain, args.errorCode])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "respondE2EELoginRequest", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "respondE2EELoginRequest", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('respondE2EELoginRequest', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "respondE2EELoginRequest", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _confirmE2EELogin(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_confirmE2EELogin, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = confirmE2EELogin_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = confirmE2EELogin_result()
        try:
            result.success = self._handler([ctx, args.verifier, args.deviceSecret])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "confirmE2EELogin", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "confirmE2EELogin", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('confirmE2EELogin', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "confirmE2EELogin", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _logoutZ(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_logoutZ, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = logoutZ_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = logoutZ_result()
        try:
            self._handler([ctx])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "logoutZ", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "logoutZ", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('logoutZ', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "logoutZ", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _loginZ(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_loginZ, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = loginZ_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = loginZ_result()
        try:
            result.success = self._handler([ctx, args.loginRequest])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "loginZ", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "loginZ", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('loginZ', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "loginZ", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _issueTokenForAccountMigrationSettings(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_issueTokenForAccountMigrationSettings, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = issueTokenForAccountMigrationSettings_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = issueTokenForAccountMigrationSettings_result()
        try:
            result.success = self._handler([ctx, args.enforce])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "issueTokenForAccountMigrationSettings", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "issueTokenForAccountMigrationSettings", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('issueTokenForAccountMigrationSettings', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "issueTokenForAccountMigrationSettings", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _issueTokenForAccountMigration(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_issueTokenForAccountMigration, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = issueTokenForAccountMigration_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = issueTokenForAccountMigration_result()
        try:
            result.success = self._handler([ctx, args.migrationSessionId])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "issueTokenForAccountMigration", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "issueTokenForAccountMigration", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('issueTokenForAccountMigration', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "issueTokenForAccountMigration", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _verifyQrcodeWithE2EE(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_verifyQrcodeWithE2EE, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = verifyQrcodeWithE2EE_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = verifyQrcodeWithE2EE_result()
        try:
            result.success = self._handler([ctx, args.verifier, args.pinCode, args.errorCode, args.publicKey, args.encryptedKeyChain, args.hashKeyChain])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "verifyQrcodeWithE2EE", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "verifyQrcodeWithE2EE", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('verifyQrcodeWithE2EE', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "verifyQrcodeWithE2EE", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


def _write_application_exception(ctx, oprot, method, ex_code=None, message=None, exception=None):
    if exception is not None:
        x = exception
    else:
        x = TApplicationException(type=ex_code, message=message)
    oprot.write_response_headers(ctx)
    oprot.writeMessageBegin(method, TMessageType.EXCEPTION, 0)
    x.write(oprot)
    oprot.writeMessageEnd()
    oprot.get_transport().flush()
    return x

class normalizePhoneNumber_args(object):
    """
    Attributes:
     - countryCode
     - phoneNumber
     - countryCodeHint
    """
    def __init__(self, countryCode=None, phoneNumber=None, countryCodeHint=None):
        self.countryCode = countryCode
        self.phoneNumber = phoneNumber
        self.countryCodeHint = countryCodeHint

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.countryCode = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.phoneNumber = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.countryCodeHint = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('normalizePhoneNumber_args')
        if self.countryCode is not None:
            oprot.writeFieldBegin('countryCode', TType.STRING, 2)
            oprot.writeString(self.countryCode)
            oprot.writeFieldEnd()
        if self.phoneNumber is not None:
            oprot.writeFieldBegin('phoneNumber', TType.STRING, 3)
            oprot.writeString(self.phoneNumber)
            oprot.writeFieldEnd()
        if self.countryCodeHint is not None:
            oprot.writeFieldBegin('countryCodeHint', TType.STRING, 4)
            oprot.writeString(self.countryCodeHint)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.countryCode))
        value = (value * 31) ^ hash(make_hashable(self.phoneNumber))
        value = (value * 31) ^ hash(make_hashable(self.countryCodeHint))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class normalizePhoneNumber_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('normalizePhoneNumber_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class respondE2EELoginRequest_args(object):
    """
    Attributes:
     - verifier
     - publicKey
     - encryptedKeyChain
     - hashKeyChain
     - errorCode
    """
    def __init__(self, verifier=None, publicKey=None, encryptedKeyChain=None, hashKeyChain=None, errorCode=None):
        self.verifier = verifier
        self.publicKey = publicKey
        self.encryptedKeyChain = encryptedKeyChain
        self.hashKeyChain = hashKeyChain
        self.errorCode = errorCode

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.verifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.publicKey = E2EEPublicKey()
                    self.publicKey.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.encryptedKeyChain = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.hashKeyChain = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.errorCode = ErrorCode(iprot.readI32())
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('respondE2EELoginRequest_args')
        if self.verifier is not None:
            oprot.writeFieldBegin('verifier', TType.STRING, 1)
            oprot.writeString(self.verifier)
            oprot.writeFieldEnd()
        if self.publicKey is not None:
            oprot.writeFieldBegin('publicKey', TType.STRUCT, 2)
            self.publicKey.write(oprot)
            oprot.writeFieldEnd()
        if self.encryptedKeyChain is not None:
            oprot.writeFieldBegin('encryptedKeyChain', TType.STRING, 3)
            oprot.writeBinary(self.encryptedKeyChain)
            oprot.writeFieldEnd()
        if self.hashKeyChain is not None:
            oprot.writeFieldBegin('hashKeyChain', TType.STRING, 4)
            oprot.writeBinary(self.hashKeyChain)
            oprot.writeFieldEnd()
        if self.errorCode is not None:
            oprot.writeFieldBegin('errorCode', TType.I32, 5)
            oprot.writeI32(self.errorCode)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.verifier))
        value = (value * 31) ^ hash(make_hashable(self.publicKey))
        value = (value * 31) ^ hash(make_hashable(self.encryptedKeyChain))
        value = (value * 31) ^ hash(make_hashable(self.hashKeyChain))
        value = (value * 31) ^ hash(make_hashable(self.errorCode))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class respondE2EELoginRequest_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('respondE2EELoginRequest_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class confirmE2EELogin_args(object):
    """
    Attributes:
     - verifier
     - deviceSecret
    """
    def __init__(self, verifier=None, deviceSecret=None):
        self.verifier = verifier
        self.deviceSecret = deviceSecret

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.verifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.deviceSecret = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('confirmE2EELogin_args')
        if self.verifier is not None:
            oprot.writeFieldBegin('verifier', TType.STRING, 1)
            oprot.writeString(self.verifier)
            oprot.writeFieldEnd()
        if self.deviceSecret is not None:
            oprot.writeFieldBegin('deviceSecret', TType.STRING, 2)
            oprot.writeBinary(self.deviceSecret)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.verifier))
        value = (value * 31) ^ hash(make_hashable(self.deviceSecret))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class confirmE2EELogin_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('confirmE2EELogin_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class logoutZ_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('logoutZ_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class logoutZ_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('logoutZ_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class loginZ_args(object):
    """
    Attributes:
     - loginRequest
    """
    def __init__(self, loginRequest=None):
        self.loginRequest = loginRequest

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.loginRequest = LoginRequest()
                    self.loginRequest.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('loginZ_args')
        if self.loginRequest is not None:
            oprot.writeFieldBegin('loginRequest', TType.STRUCT, 2)
            self.loginRequest.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.loginRequest))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class loginZ_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = LoginResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('loginZ_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class issueTokenForAccountMigrationSettings_args(object):
    """
    Attributes:
     - enforce
    """
    def __init__(self, enforce=None):
        self.enforce = enforce

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.BOOL:
                    self.enforce = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('issueTokenForAccountMigrationSettings_args')
        if self.enforce is not None:
            oprot.writeFieldBegin('enforce', TType.BOOL, 2)
            oprot.writeBool(self.enforce)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.enforce))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class issueTokenForAccountMigrationSettings_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = SecurityCenterResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('issueTokenForAccountMigrationSettings_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class issueTokenForAccountMigration_args(object):
    """
    Attributes:
     - migrationSessionId
    """
    def __init__(self, migrationSessionId=None):
        self.migrationSessionId = migrationSessionId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.migrationSessionId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('issueTokenForAccountMigration_args')
        if self.migrationSessionId is not None:
            oprot.writeFieldBegin('migrationSessionId', TType.STRING, 2)
            oprot.writeString(self.migrationSessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.migrationSessionId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class issueTokenForAccountMigration_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = SecurityCenterResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('issueTokenForAccountMigration_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class verifyQrcodeWithE2EE_args(object):
    """
    Attributes:
     - verifier
     - pinCode
     - errorCode
     - publicKey
     - encryptedKeyChain
     - hashKeyChain
    """
    def __init__(self, verifier=None, pinCode=None, errorCode=None, publicKey=None, encryptedKeyChain=None, hashKeyChain=None):
        self.verifier = verifier
        self.pinCode = pinCode
        self.errorCode = errorCode
        self.publicKey = publicKey
        self.encryptedKeyChain = encryptedKeyChain
        self.hashKeyChain = hashKeyChain

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.verifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.pinCode = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.errorCode = ErrorCode(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.publicKey = E2EEPublicKey()
                    self.publicKey.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.encryptedKeyChain = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.hashKeyChain = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('verifyQrcodeWithE2EE_args')
        if self.verifier is not None:
            oprot.writeFieldBegin('verifier', TType.STRING, 2)
            oprot.writeString(self.verifier)
            oprot.writeFieldEnd()
        if self.pinCode is not None:
            oprot.writeFieldBegin('pinCode', TType.STRING, 3)
            oprot.writeString(self.pinCode)
            oprot.writeFieldEnd()
        if self.errorCode is not None:
            oprot.writeFieldBegin('errorCode', TType.I32, 4)
            oprot.writeI32(self.errorCode)
            oprot.writeFieldEnd()
        if self.publicKey is not None:
            oprot.writeFieldBegin('publicKey', TType.STRUCT, 5)
            self.publicKey.write(oprot)
            oprot.writeFieldEnd()
        if self.encryptedKeyChain is not None:
            oprot.writeFieldBegin('encryptedKeyChain', TType.STRING, 6)
            oprot.writeBinary(self.encryptedKeyChain)
            oprot.writeFieldEnd()
        if self.hashKeyChain is not None:
            oprot.writeFieldBegin('hashKeyChain', TType.STRING, 7)
            oprot.writeBinary(self.hashKeyChain)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.verifier))
        value = (value * 31) ^ hash(make_hashable(self.pinCode))
        value = (value * 31) ^ hash(make_hashable(self.errorCode))
        value = (value * 31) ^ hash(make_hashable(self.publicKey))
        value = (value * 31) ^ hash(make_hashable(self.encryptedKeyChain))
        value = (value * 31) ^ hash(make_hashable(self.hashKeyChain))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class verifyQrcodeWithE2EE_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('verifyQrcodeWithE2EE_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

