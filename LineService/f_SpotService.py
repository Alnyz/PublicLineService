#
# Autogenerated by Frugal Compiler (3.7.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#



from threading import Lock

from frugal.middleware import Method
from frugal.exceptions import TApplicationExceptionType
from frugal.exceptions import TTransportExceptionType
from frugal.processor import FBaseProcessor
from frugal.processor import FProcessorFunction
from frugal.util.deprecate import deprecated
from frugal.util import make_hashable
from thrift.Thrift import TApplicationException
from thrift.Thrift import TMessageType
from thrift.transport.TTransport import TTransportException

from .ttypes import *


class Iface(object):

    def lookupByPhoneNumber(self, ctx, countryAreaCode, phoneNumber):
        """
        Args:
            ctx: FContext
            countryAreaCode: string
            phoneNumber: string
        """
        pass

    def lookupNearby(self, ctx, location, category, query, countryAreaCode):
        """
        Args:
            ctx: FContext
            location: Location
            category: SpotCategory
            query: string
            countryAreaCode: string
        """
        pass


class Client(Iface):

    def __init__(self, provider, middleware=None):
        """
        Create a new Client with an FServiceProvider containing a transport
        and protocol factory.

        Args:
            provider: FServiceProvider with TSynchronousTransport
            middleware: ServiceMiddleware or list of ServiceMiddleware
        """
        middleware = middleware or []
        if middleware and not isinstance(middleware, list):
            middleware = [middleware]
        self._transport = provider.get_transport()
        self._protocol_factory = provider.get_protocol_factory()
        self._oprot = self._protocol_factory.get_protocol(self._transport)
        self._iprot = self._protocol_factory.get_protocol(self._transport)
        self._write_lock = Lock()
        middleware += provider.get_middleware()
        self._methods = {
            'lookupByPhoneNumber': Method(self._lookupByPhoneNumber, middleware),
            'lookupNearby': Method(self._lookupNearby, middleware),
        }

    def lookupByPhoneNumber(self, ctx, countryAreaCode, phoneNumber):
        """
        Args:
            ctx: FContext
            countryAreaCode: string
            phoneNumber: string
        """
        return self._methods['lookupByPhoneNumber']([ctx, countryAreaCode, phoneNumber])

    def _lookupByPhoneNumber(self, ctx, countryAreaCode, phoneNumber):
        self._send_lookupByPhoneNumber(ctx, countryAreaCode, phoneNumber)
        return self._recv_lookupByPhoneNumber(ctx)

    def _send_lookupByPhoneNumber(self, ctx, countryAreaCode, phoneNumber):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('lookupByPhoneNumber', TMessageType.CALL, 0)
            args = lookupByPhoneNumber_args()
            args.countryAreaCode = countryAreaCode
            args.phoneNumber = phoneNumber
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_lookupByPhoneNumber(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = lookupByPhoneNumber_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "lookupByPhoneNumber failed: unknown result")
        raise x

    def lookupNearby(self, ctx, location, category, query, countryAreaCode):
        """
        Args:
            ctx: FContext
            location: Location
            category: SpotCategory
            query: string
            countryAreaCode: string
        """
        return self._methods['lookupNearby']([ctx, location, category, query, countryAreaCode])

    def _lookupNearby(self, ctx, location, category, query, countryAreaCode):
        self._send_lookupNearby(ctx, location, category, query, countryAreaCode)
        return self._recv_lookupNearby(ctx)

    def _send_lookupNearby(self, ctx, location, category, query, countryAreaCode):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('lookupNearby', TMessageType.CALL, 0)
            args = lookupNearby_args()
            args.location = location
            args.category = category
            args.query = query
            args.countryAreaCode = countryAreaCode
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_lookupNearby(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = lookupNearby_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "lookupNearby failed: unknown result")
        raise x

class Processor(FBaseProcessor):

    def __init__(self, handler, middleware=None):
        """
        Create a new Processor.

        Args:
            handler: Iface
        """
        if middleware and not isinstance(middleware, list):
            middleware = [middleware]

        super(Processor, self).__init__()
        self.add_to_processor_map('lookupByPhoneNumber', _lookupByPhoneNumber(Method(handler.lookupByPhoneNumber, middleware), self.get_write_lock()))
        self.add_to_processor_map('lookupNearby', _lookupNearby(Method(handler.lookupNearby, middleware), self.get_write_lock()))


class _lookupByPhoneNumber(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_lookupByPhoneNumber, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = lookupByPhoneNumber_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = lookupByPhoneNumber_result()
        try:
            result.success = self._handler([ctx, args.countryAreaCode, args.phoneNumber])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "lookupByPhoneNumber", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "lookupByPhoneNumber", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('lookupByPhoneNumber', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "lookupByPhoneNumber", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _lookupNearby(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_lookupNearby, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = lookupNearby_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = lookupNearby_result()
        try:
            result.success = self._handler([ctx, args.location, args.category, args.query, args.countryAreaCode])
        except TalkException as e:
            result.e = e
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "lookupNearby", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "lookupNearby", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('lookupNearby', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "lookupNearby", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


def _write_application_exception(ctx, oprot, method, ex_code=None, message=None, exception=None):
    if exception is not None:
        x = exception
    else:
        x = TApplicationException(type=ex_code, message=message)
    oprot.write_response_headers(ctx)
    oprot.writeMessageBegin(method, TMessageType.EXCEPTION, 0)
    x.write(oprot)
    oprot.writeMessageEnd()
    oprot.get_transport().flush()
    return x

class lookupByPhoneNumber_args(object):
    """
    Attributes:
     - countryAreaCode
     - phoneNumber
    """
    def __init__(self, countryAreaCode=None, phoneNumber=None):
        self.countryAreaCode = countryAreaCode
        self.phoneNumber = phoneNumber

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.countryAreaCode = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.phoneNumber = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('lookupByPhoneNumber_args')
        if self.countryAreaCode is not None:
            oprot.writeFieldBegin('countryAreaCode', TType.STRING, 2)
            oprot.writeString(self.countryAreaCode)
            oprot.writeFieldEnd()
        if self.phoneNumber is not None:
            oprot.writeFieldBegin('phoneNumber', TType.STRING, 3)
            oprot.writeString(self.phoneNumber)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.countryAreaCode))
        value = (value * 31) ^ hash(make_hashable(self.phoneNumber))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class lookupByPhoneNumber_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = SpotPhoneNumberResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('lookupByPhoneNumber_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class lookupNearby_args(object):
    """
    Attributes:
     - location
     - category
     - query
     - countryAreaCode
    """
    def __init__(self, location=None, category=None, query=None, countryAreaCode=None):
        self.location = location
        self.category = category
        self.query = query
        self.countryAreaCode = countryAreaCode

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.location = Location()
                    self.location.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.category = SpotCategory(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.query = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.countryAreaCode = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('lookupNearby_args')
        if self.location is not None:
            oprot.writeFieldBegin('location', TType.STRUCT, 2)
            self.location.write(oprot)
            oprot.writeFieldEnd()
        if self.category is not None:
            oprot.writeFieldBegin('category', TType.I32, 3)
            oprot.writeI32(self.category)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRING, 4)
            oprot.writeString(self.query)
            oprot.writeFieldEnd()
        if self.countryAreaCode is not None:
            oprot.writeFieldBegin('countryAreaCode', TType.STRING, 5)
            oprot.writeString(self.countryAreaCode)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.location))
        value = (value * 31) ^ hash(make_hashable(self.category))
        value = (value * 31) ^ hash(make_hashable(self.query))
        value = (value * 31) ^ hash(make_hashable(self.countryAreaCode))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class lookupNearby_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = SpotNearbyResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('lookupNearby_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

